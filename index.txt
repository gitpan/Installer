#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Installer.pm"} = <<'APP_INSTALLER';
  package App::Installer;
  BEGIN {
    $App::Installer::AUTHORITY = 'cpan:GETTY';
  }
  {
    $App::Installer::VERSION = '0.004';
  }
  # ABSTRACT: Application class for Installer
  
  use Moo;
  use Path::Class;
  use IO::All;
  use namespace::clean;
  
  has 'target' => (
    is => 'ro',
    required => 1,
  );
  
  has 'file' => (
    is => 'ro',
    lazy => 1,
    default => sub { '.installer' },
  );
  
  has 'url' => (
    is => 'ro',
    predicate => 1,
  );
  
  has file_path => (
    is => 'ro',
    lazy => 1,
    default => sub { file($_[0]->file)->absolute->stringify },
  );
  
  sub install_to_target {
    my ( $self ) = @_;
    my $target = $self->target;
    $target = dir($target)->absolute->stringify;
    my $installer_code;
    if ($self->has_url) {
      $installer_code = io($self->url)->get->content;
    } else {
      $installer_code = io($self->file_path)->all;
    }
    my $target_class = 'App::Installer::Sandbox'.$$;
  
    my ( $err );
    {
      local $@;
      eval <<EVAL;
  package $target_class;
  no strict;
  no warnings;
  use Installer;
  
  install_to '$target' => sub {
    $installer_code;
  };
  
  EVAL
      $err = $@;
    }
  
    if ($err) { die "$err" };
  
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  App::Installer - Application class for Installer
  
  =head1 VERSION
  
  version 0.004
  
  =head1 DESCRIPTION
  
  See L<installer> and for more information
  
  =encoding utf8
  
  =head1 AUTHOR
  
  Torsten Raudssus <torsten@raudss.us>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Torsten Raudssus.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
APP_INSTALLER

$fatpacked{"B/Hooks/EndOfScope.pm"} = <<'B_HOOKS_ENDOFSCOPE';
  package B::Hooks::EndOfScope;
  BEGIN {
    $B::Hooks::EndOfScope::AUTHORITY = 'cpan:FLORA';
  }
  {
    $B::Hooks::EndOfScope::VERSION = '0.12';
  }
  # ABSTRACT: Execute code after a scope finished compilation
  
  use strict;
  use warnings;
  
  # note - a %^H tie() fallback will probably work on 5.6 as well,
  # if you need to go that low - sane patches passing *all* tests
  # will be gladly accepted
  use 5.008001;
  
  BEGIN {
    require Module::Implementation;
    my $impl = Module::Implementation::implementation_for('B::Hooks::EndOfScope') || do {
      Module::Implementation::build_loader_sub(
        implementations => [ 'XS', 'PP' ],
        symbols => [ 'on_scope_end' ],
      )->();
      Module::Implementation::implementation_for('B::Hooks::EndOfScope');
    };
  
    *on_scope_end = $impl eq 'XS'
      ? \&B::Hooks::EndOfScope::XS::on_scope_end
      : \&B::Hooks::EndOfScope::PP::on_scope_end
    ;
  }
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ 'on_scope_end' ],
    groups  => { default => ['on_scope_end'] },
  };
  
  
  1;
  
  __END__
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope - Execute code after a scope finished compilation
  
  =head1 SYNOPSIS
  
      on_scope_end { ... };
  
  =head1 DESCRIPTION
  
  This module allows you to execute code when perl finished compiling the
  surrounding scope.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 PURE-PERL MODE CAVEAT
  
  While L<Variable::Magic> has access to some very dark sorcery to make it
  possible to throw an exception from within a callback, the pure-perl
  implementation does not have access to these hacks. Therefore, what
  would have been a compile-time exception is instead converted to a
  warning, and your execution will continue as if the exception never
  happened.
  
  To explicitly request an XS (or PP) implementation one has two choices. Either
  to import from the desired implementation explicitly:
  
   use B::Hooks::EndOfScope::XS
     or
   use B::Hooks::EndOfScope::PP
  
  or by setting C<$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}> to either C<XS> or
  C<PP>.
  
  =head1 SEE ALSO
  
  L<Sub::Exporter>
  
  L<Variable::Magic>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
B_HOOKS_ENDOFSCOPE

$fatpacked{"B/Hooks/EndOfScope/PP.pm"} = <<'B_HOOKS_ENDOFSCOPE_PP';
  package B::Hooks::EndOfScope::PP;
  BEGIN {
    $B::Hooks::EndOfScope::PP::AUTHORITY = 'cpan:FLORA';
  }
  {
    $B::Hooks::EndOfScope::PP::VERSION = '0.12';
  }
  # ABSTRACT: Execute code after a scope finished compilation - PP implementation
  
  use warnings;
  use strict;
  
  use Module::Runtime 'require_module';
  use constant _PERL_VERSION => "$]";
  
  BEGIN {
    if (_PERL_VERSION =~ /^5\.009/) {
      # CBA to figure out where %^H got broken and which H::U::HH is sane enough
      die "By design B::Hooks::EndOfScope does not operate in pure-perl mode on perl 5.9.X\n"
    }
    elsif (_PERL_VERSION < '5.010') {
      require_module('B::Hooks::EndOfScope::PP::HintHash');
      *on_scope_end = \&B::Hooks::EndOfScope::PP::HintHash::on_scope_end;
    }
    else {
      require_module('B::Hooks::EndOfScope::PP::FieldHash');
      *on_scope_end = \&B::Hooks::EndOfScope::PP::FieldHash::on_scope_end;
    }
  }
  
  use Sub::Exporter::Progressive -setup => {
    exports => ['on_scope_end'],
    groups  => { default => ['on_scope_end'] },
  };
  
  sub __invoke_callback {
    local $@;
    eval { $_[0]->(); 1 } or do {
      my $err = $@;
      require Carp;
      Carp::cluck( (join ' ',
        'A scope-end callback raised an exception, which can not be propagated when',
        'B::Hooks::EndOfScope operates in pure-perl mode. Your program will CONTINUE',
        'EXECUTION AS IF NOTHING HAPPENED AFTER THIS WARNING. Below is the complete',
        'exception text, followed by a stack-trace of the callback execution:',
      ) . "\n\n$err\n\r" );
  
      sleep 1 if -t *STDERR;  # maybe a bad idea...?
    };
  }
  
  
  1;
  
  __END__
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::PP - Execute code after a scope finished compilation - PP implementation
  
  =head1 DESCRIPTION
  
  This is the pure-perl implementation of L<B::Hooks::EndOfScope> based only on
  modules available as part of the perl core. Its leaner sibling
  L<B::Hooks::EndOfScope::XS> will be automatically preferred if all
  dependencies are available and C<$ENV{B_HOOKS_ENDOFSCOPE_IMPLEMENTATION}> is
  not set to C<'PP'>.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
B_HOOKS_ENDOFSCOPE_PP

$fatpacked{"B/Hooks/EndOfScope/PP/FieldHash.pm"} = <<'B_HOOKS_ENDOFSCOPE_PP_FIELDHASH';
  # Implementtion of a pure-perl on_scope_end for perls > 5.10
  # (relies on Hash::Util:FieldHash)
  
  package # hide from pause
    B::Hooks::EndOfScope::PP::FieldHash;
  
  use strict;
  use warnings;
  
  use warnings;
  use strict;
  
  use Tie::Hash ();
  use Hash::Util::FieldHash 'fieldhash';
  
  # Here we rely on a combination of several behaviors:
  #
  # * %^H is deallocated on scope exit, so any references to it disappear
  # * A lost weakref in a fieldhash causes the corresponding key to be deleted
  # * Deletion of a key on a tied hash triggers DELETE
  #
  # Therefore the DELETE of a tied fieldhash containing a %^H reference will
  # be the hook to fire all our callbacks.
  
  fieldhash my %hh;
  {
    package # hide from pause too
      B::Hooks::EndOfScope::PP::_TieHintHashFieldHash;
    use base 'Tie::StdHash';
    sub DELETE {
      my $ret = shift->SUPER::DELETE(@_);
      B::Hooks::EndOfScope::PP::__invoke_callback($_) for @$ret;
      $ret;
    }
  }
  
  sub on_scope_end (&) {
    $^H |= 0x020000;
  
    tie(%hh, 'B::Hooks::EndOfScope::PP::_TieHintHashFieldHash')
      unless tied %hh;
  
    push @{ $hh{\%^H} ||= [] }, shift;
  }
  
  1;
  
  __END__
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::PP::FieldHash
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
B_HOOKS_ENDOFSCOPE_PP_FIELDHASH

$fatpacked{"B/Hooks/EndOfScope/PP/HintHash.pm"} = <<'B_HOOKS_ENDOFSCOPE_PP_HINTHASH';
  # Implementtion of a pure-perl on_scope_end for perl 5.8.X
  # (relies on lack of compile/runtime duality of %^H before 5.10
  # which makes guard object operation possible)
  
  package # hide from the pauses
    B::Hooks::EndOfScope::PP::HintHash;
  
  use strict;
  use warnings;
  use Scalar::Util ();
  
  # This is the original implementation, which sadly is broken
  # on perl 5.10+ within string evals
  sub on_scope_end (&) {
    $^H |= 0x020000;
  
    # localised %^H behaves funny on 5.8 - a
    # 'local %^H;'
    # is in effect the same as
    # 'local %^H = %^H;'
    # therefore make sure we use different keys so that things do not
    # fire too early due to hashkey overwrite
    push @{
      $^H{sprintf '__B_H_EOS__guardstack_0X%x', Scalar::Util::refaddr(\%^H) }
        ||= bless ([], 'B::Hooks::EndOfScope::PP::_SG_STACK')
    }, shift;
  }
  
  package # hide from the pauses
    B::Hooks::EndOfScope::PP::_SG_STACK;
  
  use warnings;
  use strict;
  
  sub DESTROY {
    B::Hooks::EndOfScope::PP::__invoke_callback($_) for @{$_[0]};
  }
  
  1;
  
  __END__
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::PP::HintHash
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
B_HOOKS_ENDOFSCOPE_PP_HINTHASH

$fatpacked{"B/Hooks/EndOfScope/XS.pm"} = <<'B_HOOKS_ENDOFSCOPE_XS';
  package B::Hooks::EndOfScope::XS;
  BEGIN {
    $B::Hooks::EndOfScope::XS::AUTHORITY = 'cpan:FLORA';
  }
  {
    $B::Hooks::EndOfScope::XS::VERSION = '0.12';
  }
  # ABSTRACT: Execute code after a scope finished compilation - XS implementation
  
  use strict;
  use warnings;
  
  BEGIN {
    require Module::Runtime;
    # Adjust the Makefile.PL if changing this minimum version
    Module::Runtime::use_module('Variable::Magic', '0.48');
  }
  
  use Sub::Exporter::Progressive -setup => {
    exports => ['on_scope_end'],
    groups  => { default => ['on_scope_end'] },
  };
  
  my $wiz = Variable::Magic::wizard
    data => sub { [$_[1]] },
    free => sub { $_->() for @{ $_[1] }; () },
    # When someone localise %^H, our magic doesn't want to be copied
    # down. We want it to be around only for the scope we've initially
    # attached ourselfs to. Merely having MGf_LOCAL and a noop svt_local
    # callback achieves this. If anything wants to attach more magic of our
    # kind to a localised %^H, things will continue to just work as we'll be
    # attached with a new and empty callback list.
    local => \undef
  ;
  
  sub on_scope_end (&) {
    my $cb = shift;
  
    $^H |= 0x020000;
  
    if (my $stack = Variable::Magic::getdata %^H, $wiz) {
      push @{ $stack }, $cb;
    }
    else {
      Variable::Magic::cast %^H, $wiz, $cb;
    }
  }
  
  
  
  1;
  
  __END__
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  B::Hooks::EndOfScope::XS - Execute code after a scope finished compilation - XS implementation
  
  =head1 DESCRIPTION
  
  This is the implementation of L<B::Hooks::EndOfScope> based on
  L<Variable::Magic>, which is an XS module dependent on a compiler. It will
  always be automatically preferred if L<Variable::Magic> is available.
  
  =head1 FUNCTIONS
  
  =head2 on_scope_end
  
      on_scope_end { ... };
  
      on_scope_end $code;
  
  Registers C<$code> to be executed after the surrounding scope has been
  compiled.
  
  This is exported by default. See L<Sub::Exporter> on how to customize it.
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Florian Ragwitz.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
B_HOOKS_ENDOFSCOPE_XS

$fatpacked{"Devel/GlobalDestruction.pm"} = <<'DEVEL_GLOBALDESTRUCTION';
  package Devel::GlobalDestruction;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.11';
  
  use Sub::Exporter::Progressive -setup => {
    exports => [ qw(in_global_destruction) ],
    groups  => { default => [ -all ] },
  };
  
  # we run 5.14+ - everything is in core
  #
  if (defined ${^GLOBAL_PHASE}) {
    eval 'sub in_global_destruction () { ${^GLOBAL_PHASE} eq q[DESTRUCT] }; 1'
      or die $@;
  }
  # try to load the xs version if it was compiled
  #
  elsif (eval {
    require Devel::GlobalDestruction::XS;
    no warnings 'once';
    *in_global_destruction = \&Devel::GlobalDestruction::XS::in_global_destruction;
    1;
  }) {
    # the eval already installed everything, nothing to do
  }
  else {
    # internally, PL_main_start is nulled immediately before entering global destruction
    # and we can use B to detect that.  It will also be null before the main runloop starts,
    # so we check install a CHECK if needed to detect that.
    require B;
    my $started = !B::main_start()->isa(q[B::NULL]);
    unless ($started) {
      # work around 5.6 eval bug
      eval '0 && $started; CHECK { $started = 1 }; 1'
        or die $@;
    }
    eval '0 && $started; sub in_global_destruction () { $started && B::main_start()->isa(q[B::NULL]) }; 1'
      or die $@;
  }
  
  1;  # keep require happy
  
  
  __END__
  
  =head1 NAME
  
  Devel::GlobalDestruction - Provides function returning the equivalent of
  C<${^GLOBAL_PHASE} eq 'DESTRUCT'> for older perls.
  
  =head1 SYNOPSIS
  
      package Foo;
      use Devel::GlobalDestruction;
  
      use namespace::clean; # to avoid having an "in_global_destruction" method
  
      sub DESTROY {
          return if in_global_destruction;
  
          do_something_a_little_tricky();
      }
  
  =head1 DESCRIPTION
  
  Perl's global destruction is a little tricky to deal with WRT finalizers
  because it's not ordered and objects can sometimes disappear.
  
  Writing defensive destructors is hard and annoying, and usually if global
  destruction is happenning you only need the destructors that free up non
  process local resources to actually execute.
  
  For these constructors you can avoid the mess by simply bailing out if global
  destruction is in effect.
  
  =head1 EXPORTS
  
  This module uses L<Sub::Exporter::Progressive> so the exports may be renamed,
  aliased, etc. if L<Sub::Exporter> is present.
  
  =over 4
  
  =item in_global_destruction
  
  Returns true if the interpreter is in global destruction. In perl 5.14+, this
  returns C<${^GLOBAL_PHASE} eq 'DESTRUCT'>, and on earlier perls, detects it using
  the value of C<PL_main_start> or C<PL_dirty>.
  
  =back
  
  =head1 AUTHORS
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  Florian Ragwitz E<lt>rafl@debian.orgE<gt>
  
  Jesse Luehrs E<lt>doy@tozt.netE<gt>
  
  Peter Rabbitson E<lt>ribasushi@cpan.orgE<gt>
  
  Arthur Axel 'fREW' Schmidt E<lt>frioux@gmail.comE<gt>
  
  Elizabeth Mattijsen E<lt>liz@dijkmat.nlE<gt>
  
  Greham Knop E<lt>haarg@haarg.orgE<gt>
  
  =head1 COPYRIGHT
  
      Copyright (c) 2008 Yuval Kogman. All rights reserved
      This program is free software; you can redistribute
      it and/or modify it under the same terms as Perl itself.
  
  =cut
DEVEL_GLOBALDESTRUCTION

$fatpacked{"IO/All.pm"} = <<'IO_ALL';
  package IO::All;
  use 5.006001;
  use strict;
  use warnings;
  
  require Carp;
  # So one can use Carp::carp "$message" - without the parenthesis.
  sub Carp::carp;
  
  use IO::All::Base -base;
  
  use File::Spec();
  use Symbol();
  use Fcntl;
  
  our $VERSION = '0.46';
  our @EXPORT = qw(io);
  
  #===============================================================================
  # Object creation and setup methods
  #===============================================================================
  my $autoload = {
      qw(
          touch file
  
          dir_handle dir
          All dir
          all_files dir
          All_Files dir
          all_dirs dir
          All_Dirs dir
          all_links dir
          All_Links dir
          mkdir dir
          mkpath dir
          next dir
  
          stdin stdio
          stdout stdio
          stderr stdio
  
          socket_handle socket
          accept socket
          shutdown socket
  
          readlink link
          symlink link
      )
  };
  
  # XXX - These should die if the given argument exists but is not a
  # link, dbm, etc.
  sub link {my $self = shift; require IO::All::Link; IO::All::Link::link($self, @_) }
  sub dbm {my $self = shift; require IO::All::DBM; IO::All::DBM::dbm($self, @_) }
  sub mldbm {my $self = shift; require IO::All::MLDBM; IO::All::MLDBM::mldbm($self, @_) }
  
  sub autoload {my $self = shift; $autoload }
  
  sub AUTOLOAD {
      my $self = shift;
      my $method = $IO::All::AUTOLOAD;
      $method =~ s/.*:://;
      my $pkg = ref($self) || $self;
      $self->throw(qq{Can't locate object method "$method" via package "$pkg"})
        if $pkg ne $self->package;
      my $class = $self->autoload_class($method);
      my $foo = "$self";
      bless $self, $class;
      $self->$method(@_);
  }
  
  sub autoload_class {
      my $self = shift;
      my $method = shift;
      my $class_id = $self->autoload->{$method} || $method;
      my $ucfirst_class_name = 'IO::All::' . ucfirst($class_id);
      my $ucfirst_class_fn = "IO/All/" . ucfirst($class_id) . ".pm";
      return $ucfirst_class_name if $INC{$ucfirst_class_fn};
      return "IO::All::\U$class_id" if $INC{"IO/All/\U$class_id\E.pm"};
      require IO::All::Temp;
      if (eval "require $ucfirst_class_name; 1") {
          my $class = $ucfirst_class_name;
          my $return = $class->can('new')
          ? $class
          : do { # (OS X hack)
              my $value = $INC{$ucfirst_class_fn};
              delete $INC{$ucfirst_class_fn};
              $INC{"IO/All/\U$class_id\E.pm"} = $value;
              "IO::All::\U$class_id";
          };
          return $return;
      }
      elsif (eval "require IO::All::\U$class_id; 1") {
          return "IO::All::\U$class_id";
      }
      $self->throw("Can't find a class for method '$method'");
  }
  
  sub new {
      my $self = shift;
      my $package = ref($self) || $self;
      my $new = bless Symbol::gensym(), $package;
      $new->package($package);
      $new->_copy_from($self) if ref($self);
      my $name = shift;
      return $name if UNIVERSAL::isa($name, 'IO::All');
      return $new->_init unless defined $name;
      return $new->handle($name)
        if UNIVERSAL::isa($name, 'GLOB') or ref(\ $name) eq 'GLOB';
      # WWW - link is first because a link to a dir returns true for
      # both -l and -d.
      return $new->link($name) if -l $name;
      return $new->file($name) if -f $name;
      return $new->dir($name) if -d $name;
      return $new->$1($name) if $name =~ /^([a-z]{3,8}):/;
      return $new->socket($name) if $name =~ /^[\w\-\.]*:\d{1,5}$/;
      return $new->pipe($name)
        if $name =~ s/^\s*\|\s*// or $name =~ s/\s*\|\s*$//;
      return $new->string if $name eq '$';
      return $new->stdio if $name eq '-';
      return $new->stderr if $name eq '=';
      return $new->temp if $name eq '?';
      $new->name($name);
      $new->_init;
  }
  
  sub _copy_from {
      my $self = shift;
      my $other = shift;
      for (keys(%{*$other})) {
          # XXX Need to audit exclusions here
          next if /^(_handle|io_handle|is_open)$/;
          *$self->{$_} = *$other->{$_};
      }
  }
  
  sub handle {
      my $self = shift;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  # Tie Interface
  #===============================================================================
  sub tie {
      my $self = shift;
      tie *$self, $self;
      return $self;
  }
  
  sub TIEHANDLE {
      return $_[0] if ref $_[0];
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->init(@_);
  }
  
  sub READLINE {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub DESTROY {
      my $self = shift;
      no warnings;
      unless ( $] < 5.008 ) {
          untie *$self if tied *$self;
      }
      $self->close if $self->is_open;
  }
  
  sub BINMODE {
      my $self = shift;
      binmode *$self->io_handle;
  }
  
  {
      no warnings;
      *GETC   = \&getc;
      *PRINT  = \&print;
      *PRINTF = \&printf;
      *READ   = \&read;
      *WRITE  = \&write;
      *SEEK   = \&seek;
      *TELL   = \&getpos;
      *EOF    = \&eof;
      *CLOSE  = \&close;
      *FILENO = \&fileno;
  }
  
  #===============================================================================
  # Overloading support
  #===============================================================================
  my $old_warn_handler = $SIG{__WARN__};
  $SIG{__WARN__} = sub {
      if ($_[0] !~ /^Useless use of .+ \(.+\) in void context/) {
          goto &$old_warn_handler if $old_warn_handler;
          warn(@_);
      }
  };
  
  use overload '""' => 'overload_stringify';
  use overload '|' => 'overload_bitwise_or';
  use overload '<<' => 'overload_left_bitshift';
  use overload '>>' => 'overload_right_bitshift';
  use overload '<' => 'overload_less_than';
  use overload '>' => 'overload_greater_than';
  use overload '${}' => 'overload_string_deref';
  use overload '@{}' => 'overload_array_deref';
  use overload '%{}' => 'overload_hash_deref';
  use overload '&{}' => 'overload_code_deref';
  
  sub overload_bitwise_or {my $self = shift; $self->overload_handler(@_, '|') }
  sub overload_left_bitshift {my $self = shift; $self->overload_handler(@_, '<<') }
  sub overload_right_bitshift {my $self = shift; $self->overload_handler(@_, '>>') }
  sub overload_less_than {my $self = shift; $self->overload_handler(@_, '<') }
  sub overload_greater_than {my $self = shift; $self->overload_handler(@_, '>') }
  sub overload_string_deref {my $self = shift; $self->overload_handler(@_, '${}') }
  sub overload_array_deref {my $self = shift; $self->overload_handler(@_, '@{}') }
  sub overload_hash_deref {my $self = shift; $self->overload_handler(@_, '%{}') }
  sub overload_code_deref {my $self = shift; $self->overload_handler(@_, '&{}') }
  
  sub overload_handler {
      my ($self) = @_;
      my $method = $self->get_overload_method(@_);
      $self->$method(@_);
  }
  
  my $op_swap = {
      '>' => '<', '>>' => '<<',
      '<' => '>', '<<' => '>>',
  };
  
  sub overload_table {
      my $self = shift;
      (
          '* > *' => 'overload_any_to_any',
          '* < *' => 'overload_any_from_any',
          '* >> *' => 'overload_any_addto_any',
          '* << *' => 'overload_any_addfrom_any',
  
          '* < scalar' => 'overload_scalar_to_any',
          '* > scalar' => 'overload_any_to_scalar',
          '* << scalar' => 'overload_scalar_addto_any',
          '* >> scalar' => 'overload_any_addto_scalar',
      )
  };
  
  sub get_overload_method {
      my ($self, $arg1, $arg2, $swap, $operator) = @_;
      if ($swap) {
          $operator = $op_swap->{$operator} || $operator;
      }
      my $arg1_type = $self->get_argument_type($arg1);
      my $table1 = { $arg1->overload_table };
  
      if ($operator =~ /\{\}$/) {
          my $key = "$operator $arg1_type";
          return $table1->{$key} || $self->overload_undefined($key);
      }
  
      my $arg2_type = $self->get_argument_type($arg2);
      my @table2 = UNIVERSAL::isa($arg2, "IO::All")
      ? ($arg2->overload_table)
      : ();
      my $table = { %$table1, @table2 };
  
      my @keys = (
          "$arg1_type $operator $arg2_type",
          "* $operator $arg2_type",
      );
      push @keys, "$arg1_type $operator *", "* $operator *"
        unless $arg2_type =~ /^(scalar|array|hash|code|ref)$/;
  
      for (@keys) {
          return $table->{$_}
            if defined $table->{$_};
      }
  
      return $self->overload_undefined($keys[0]);
  }
  
  sub get_argument_type {
      my $self = shift;
      my $argument = shift;
      my $ref = ref($argument);
      return 'scalar' unless $ref;
      return 'code' if $ref eq 'CODE';
      return 'array' if $ref eq 'ARRAY';
      return 'hash' if $ref eq 'HASH';
      return 'ref' unless $argument->isa('IO::All');
      $argument->file
        if defined $argument->pathname and not $argument->type;
      return $argument->type || 'unknown';
  }
  
  sub overload_stringify {
      my $self = shift;
      my $name = $self->pathname;
      return defined($name) ? $name : overload::StrVal($self);
  }
  
  sub overload_undefined {
      my $self = shift;
      require Carp;
      my $key = shift;
      Carp::carp "Undefined behavior for overloaded IO::All operation: '$key'"
        if $^W;
      return 'overload_noop';
  }
  
  sub overload_noop {
      my $self = shift;
      return;
  }
  
  sub overload_any_addfrom_any {
      $_[1]->append($_[2]->all);
      $_[1];
  }
  
  sub overload_any_addto_any {
      $_[2]->append($_[1]->all);
      $_[2];
  }
  
  sub overload_any_from_any {
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]->all);
      $_[1];
  }
  
  sub overload_any_to_any {
      $_[2]->close if $_[2]->is_file and $_[2]->is_open;
      $_[2]->print($_[1]->all);
      $_[2];
  }
  
  sub overload_any_to_scalar {
      $_[2] = $_[1]->all;
  }
  
  sub overload_any_addto_scalar {
      $_[2] .= $_[1]->all;
      $_[2];
  }
  
  sub overload_scalar_addto_any {
      $_[1]->append($_[2]);
      $_[1];
  }
  
  sub overload_scalar_to_any {
      local $\;
      $_[1]->close if $_[1]->is_file and $_[1]->is_open;
      $_[1]->print($_[2]);
      $_[1];
  }
  
  #===============================================================================
  # Private Accessors
  #===============================================================================
  field 'package';
  field _binary => undef;
  field _binmode => undef;
  field _strict => undef;
  field _encoding => undef;
  field _utf8 => undef;
  field _handle => undef;
  
  #===============================================================================
  # Public Accessors
  #===============================================================================
  field constructor => undef;
  chain block_size => 1024;
  chain errors => undef;
  field io_handle => undef;
  field is_open => 0;
  chain mode => undef;
  chain name => undef;
  chain perms => undef;
  chain separator => $/;
  field type => '';
  sub pathname {my $self = shift; $self->name(@_) }
  
  #===============================================================================
  # Chainable option methods (write only)
  #===============================================================================
  option 'assert';
  option 'autoclose' => 1;
  option 'backwards';
  option 'chomp';
  option 'confess';
  option 'lock';
  option 'rdonly';
  option 'rdwr';
  option 'strict';
  
  #===============================================================================
  # IO::Handle proxy methods
  #===============================================================================
  proxy 'autoflush';
  proxy 'eof';
  proxy 'fileno';
  proxy 'stat';
  proxy 'tell';
  proxy 'truncate';
  
  #===============================================================================
  # IO::Handle proxy methods that open the handle if needed
  #===============================================================================
  proxy_open print => '>';
  proxy_open printf => '>';
  proxy_open sysread => O_RDONLY;
  proxy_open syswrite => O_CREAT | O_WRONLY;
  proxy_open seek => $^O eq 'MSWin32' ? '<' : '+<';
  proxy_open 'getc';
  
  #===============================================================================
  # File::Spec Interface
  #===============================================================================
  sub canonpath {my $self = shift; File::Spec->canonpath($self->pathname) }
  sub catdir {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->dir(File::Spec->catdir(@args));
  }
  sub catfile {
      my $self = shift;
      my @args = grep defined, $self->name, @_;
      $self->constructor->()->file(File::Spec->catfile(@args));
  }
  sub join {my $self = shift; $self->catfile(@_) }
  sub curdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->curdir);
  }
  sub devnull {
      my $self = shift;
      $self->constructor->()->file(File::Spec->devnull);
  }
  sub rootdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->rootdir);
  }
  sub tmpdir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->tmpdir);
  }
  sub updir {
      my $self = shift;
      $self->constructor->()->dir(File::Spec->updir);
  }
  sub case_tolerant {
      my $self = shift;
      File::Spec->case_tolerant;
  }
  sub is_absolute {
      my $self = shift;
      File::Spec->file_name_is_absolute($self->pathname);
  }
  sub path {
      my $self = shift;
      map { $self->constructor->()->dir($_) } File::Spec->path;
  }
  sub splitpath {
      my $self = shift;
      File::Spec->splitpath($self->pathname);
  }
  sub splitdir {
      my $self = shift;
      File::Spec->splitdir($self->pathname);
  }
  sub catpath {
      my $self = shift;
      $self->constructor->(File::Spec->catpath(@_));
  }
  sub abs2rel {
      my $self = shift;
      File::Spec->abs2rel($self->pathname, @_);
  }
  sub rel2abs {
      my $self = shift;
      File::Spec->rel2abs($self->pathname, @_);
  }
  
  #===============================================================================
  # Public IO Action Methods
  #===============================================================================
  sub absolute {
      my $self = shift;
      $self->pathname(File::Spec->rel2abs($self->pathname))
        unless $self->is_absolute;
      $self->is_absolute(1);
      return $self;
  }
  
  sub all {
      my $self = shift;
      $self->assert_open('<');
      local $/;
      my $all = $self->io_handle->getline;
      $self->error_check;
      $self->_autoclose && $self->close;
      return $all;
  }
  
  sub append {
      my $self = shift;
      $self->assert_open('>>');
      $self->print(@_);
  }
  
  sub appendln {
      my $self = shift;
      $self->assert_open('>>');
      $self->println(@_);
  }
  
  sub binary {
      my $self = shift;
      binmode($self->io_handle)
        if $self->is_open;
      $self->_binary(1);
      return $self;
  }
  
  sub binmode {
      my $self = shift;
      my $layer = shift;
      if ($self->is_open) {
          $layer
          ? CORE::binmode($self->io_handle, $layer)
          : CORE::binmode($self->io_handle);
      }
      $self->_binmode($layer);
      return $self;
  }
  
  sub buffer {
      my $self = shift;
      if (not @_) {
          *$self->{buffer} = do {my $x = ''; \ $x}
            unless exists *$self->{buffer};
          return *$self->{buffer};
      }
      my $buffer_ref = ref($_[0]) ? $_[0] : \ $_[0];
      $$buffer_ref = '' unless defined $$buffer_ref;
      *$self->{buffer} = $buffer_ref;
      return $self;
  }
  
  sub clear {
      my $self = shift;
      my $buffer = *$self->{buffer};
      $$buffer = '';
      return $self;
  }
  
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->io_handle(undef);
      $self->mode(undef);
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $message =
        "Can't call empty on an object that is neither file nor directory";
      $self->throw($message);
  }
  
  sub exists {my $self = shift; -e $self->pathname }
  
  sub getline {
      my $self = shift;
      return $self->getline_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my $line;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          $line = $self->io_handle->getline;
          chomp($line) if $self->_chomp and defined $line;
      }
      $self->error_check;
      return $line if defined $line;
      $self->close if $self->_autoclose;
      return undef;
  }
  
  sub getlines {
      my $self = shift;
      return $self->getlines_backwards
        if $self->_backwards;
      $self->assert_open('<');
      my @lines;
      {
          local $/ = @_ ? shift(@_) : $self->separator;
          @lines = $self->io_handle->getlines;
          if ($self->_chomp) {
              chomp for @lines;
          }
      }
      $self->error_check;
      return (@lines) or
             $self->_autoclose && $self->close && () or
             ();
  }
  
  sub is_dir {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Dir') }
  sub is_dbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::DBM') }
  sub is_file {my $self = shift; UNIVERSAL::isa($self, 'IO::All::File') }
  sub is_link {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Link') }
  sub is_mldbm {my $self = shift; UNIVERSAL::isa($self, 'IO::All::MLDBM') }
  sub is_socket {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Socket') }
  sub is_stdio {my $self = shift; UNIVERSAL::isa($self, 'IO::All::STDIO') }
  sub is_string {my $self = shift; UNIVERSAL::isa($self, 'IO::All::String') }
  sub is_temp {my $self = shift; UNIVERSAL::isa($self, 'IO::All::Temp') }
  
  sub length {
      my $self = shift;
      length(${$self->buffer});
  }
  
  sub open {
      my $self = shift;
      return $self if $self->is_open;
      $self->is_open(1);
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args;
      unless ($self->is_dir) {
          push @args, $self->mode;
          push @args, $self->perms if defined $self->perms;
      }
      if (defined $self->pathname and not $self->type) {
          $self->file;
          return $self->open(@args);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_binmode;
  }
  
  sub println {
      my $self = shift;
      $self->print(map {/\n\z/ ? ($_) : ($_, "\n")} @_);
  }
  
  sub read {
      my $self = shift;
      $self->assert_open('<');
      my $length = (@_ or $self->type eq 'dir')
      ? $self->io_handle->read(@_)
      : $self->io_handle->read(
          ${$self->buffer},
          $self->block_size,
          $self->length,
      );
      $self->error_check;
      return $length || $self->_autoclose && $self->close && 0;
  }
  
  {
      no warnings;
      *readline = \&getline;
  }
  
  # deprecated
  sub scalar {
      my $self = shift;
      $self->all(@_);
  }
  
  sub slurp {
      my $self = shift;
      my $slurp = $self->all;
      return $slurp unless wantarray;
      my $separator = $self->separator;
      if ($self->_chomp) {
          local $/ = $separator;
          map {chomp; $_} split /(?<=\Q$separator\E)/, $slurp;
      }
      else {
          split /(?<=\Q$separator\E)/, $slurp;
      }
  }
  
  sub utf8 {
      my $self = shift;
      if ($] < 5.008) {
          die "IO::All -utf8 not supported on Perl older than 5.8";
      }
      CORE::binmode($self->io_handle, ':utf8')
        if $self->is_open;
      $self->_utf8(1);
      $self->encoding('utf8');
      return $self;
  }
  
  sub encoding {
      my $self = shift;
      my $encoding = shift
        or die "No encoding value passed to IO::All::encoding";
      if ($] < 5.008) {
          die "IO::All -encoding not supported on Perl older than 5.8";
      }
      CORE::binmode($self->io_handle, ":$encoding")
        if $self->is_open;
      $self->_encoding($encoding);
      return $self;
  }
  
  sub write {
      my $self = shift;
      $self->assert_open('>');
      my $length = @_
      ? $self->io_handle->write(@_)
      : $self->io_handle->write(${$self->buffer}, $self->length);
      $self->error_check;
      $self->clear unless @_;
      return $length;
  }
  
  #===============================================================================
  # Implementation methods. Subclassable.
  #===============================================================================
  sub throw {
      my $self = shift;
      require Carp;
      ;
      return &{$self->errors}(@_)
        if $self->errors;
      return Carp::confess(@_)
        if $self->_confess;
      return Carp::croak(@_);
  }
  
  #===============================================================================
  # Private instance methods
  #===============================================================================
  sub assert_dirpath {
      my $self = shift;
      my $dir_name = shift;
      return $dir_name if -d $dir_name or
        CORE::mkdir($self->pathname, $self->perms || 0755) or
        do {
            require File::Path;
            File::Path::mkpath($dir_name);
        } or
        $self->throw("Can't make $dir_name");
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->file unless $self->type;
      return $self->open(@_);
  }
  
  sub error_check {
      my $self = shift;
      return unless $self->io_handle->can('error');
      return unless $self->io_handle->error;
      $self->throw($!);
  }
  
  sub copy {
      my $self = shift;
      my $copy;
      for (keys %{*$self}) {
          $copy->{$_} = *$self->{$_};
      }
      $copy->{io_handle} = 'defined'
        if defined $copy->{io_handle};
      return $copy;
  }
  
  sub set_binmode {
      my $self = shift;
      if (my $encoding = $self->_encoding) {
          CORE::binmode($self->io_handle, ":encoding($encoding)");
      }
      elsif ($self->_binary) {
          CORE::binmode($self->io_handle);
      }
      elsif ($self->_binmode) {
          CORE::binmode($self->io_handle, $self->_binmode);
      }
      return $self;
  }
  
  #===============================================================================
  # Stat Methods
  #===============================================================================
  BEGIN {
      no strict 'refs';
      my @stat_fields = qw(
          device inode modes nlink uid gid device_id size atime mtime
          ctime blksize blocks
      );
      foreach my $stat_field_idx (0 .. $#stat_fields)
      {
          my $idx = $stat_field_idx;
          my $name = $stat_fields[$idx];
  
          *$name = sub {
              my $self = shift;
              return (stat($self->io_handle || $self->pathname))[$idx];
          };
      }
  }
  
IO_ALL

$fatpacked{"IO/All/Base.pm"} = <<'IO_ALL_BASE';
  package IO::All::Base;
  use strict;
  use warnings;
  use Fcntl;
  
  sub import {
      my $class = shift;
      my $flag = $_[0] || '';
      my $package = caller;
      no strict 'refs';
      if ($flag eq '-base') {
          push @{$package . "::ISA"}, $class;
          *{$package . "::$_"} = \&$_
            for qw'field const option chain proxy proxy_open';
      }
      elsif ($flag eq -mixin) {
          mixin_import(scalar(caller(0)), $class, @_);
      }
      else {
          my @flags = @_;
          for my $export (@{$class . '::EXPORT'}) {
              *{$package . "::$export"} = $export eq 'io'
              ? $class->generate_constructor(@flags)
              : \&{$class . "::$export"};
          }
      }
  }
  
  sub generate_constructor {
      my $class = shift;
      my (@flags, %flags, $key);
      for (@_) {
          if (s/^-//) {
              push @flags, $_;
              $flags{$_} = 1;
              $key = $_;
          }
          else {
              $flags{$key} = $_ if $key;
          }
      }
      my $constructor;
      $constructor = sub {
          my $self = $class->new(@_);
          for (@flags) {
              $self->$_($flags{$_});
          }
          $self->constructor($constructor);
          return $self;
      }
  }
  
  sub _init {
      my $self = shift;
      $self->io_handle(undef);
      $self->is_open(0);
      return $self;
  }
  
  #===============================================================================
  # Closure generating functions
  #===============================================================================
  sub option {
      my $package = caller;
      my ($field, $default) = @_;
      $default ||= 0;
      field("_$field", $default);
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            *$self->{"_$field"} = @_ ? shift(@_) : 1;
            return $self;
        };
  }
  
  sub chain {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            if (@_) {
                *$self->{$field} = shift;
                return $self;
            }
            return $default unless exists *$self->{$field};
            return *$self->{$field};
        };
  }
  
  sub field {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} =
        sub {
            my $self = shift;
            unless (exists *$self->{$field}) {
                *$self->{$field} =
                  ref($default) eq 'ARRAY' ? [] :
                  ref($default) eq 'HASH' ? {} :
                  $default;
            }
            return *$self->{$field} unless @_;
            *$self->{$field} = shift;
        };
  }
  
  sub const {
      my $package = caller;
      my ($field, $default) = @_;
      no strict 'refs';
      return if defined &{"${package}::$field"};
      *{"${package}::$field"} = sub { $default };
  }
  
  sub proxy {
      my $package = caller;
      my ($proxy) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      *{"${package}::$proxy"} =
        sub {
            my $self = shift;
            my @return = $self->io_handle->$proxy(@_);
            $self->error_check;
            wantarray ? @return : $return[0];
        };
  }
  
  sub proxy_open {
      my $package = caller;
      my ($proxy, @args) = @_;
      no strict 'refs';
      return if defined &{"${package}::$proxy"};
      my $method = sub {
          my $self = shift;
          $self->assert_open(@args);
          my @return = $self->io_handle->$proxy(@_);
          $self->error_check;
          wantarray ? @return : $return[0];
      };
      *{"$package\::$proxy"} =
      (@args and $args[0] eq '>') ?
      sub {
          my $self = shift;
          $self->$method(@_);
          return $self;
      }
      : $method;
  }
  
  sub mixin_import {
      my $target_class = shift;
      $target_class = caller(0)
        if $target_class eq 'mixin';
      my $mixin_class = shift
        or die "Nothing to mixin";
      eval "require $mixin_class";
      my $pseudo_class = CORE::join '-', $target_class, $mixin_class;
      my %methods = mixin_methods($mixin_class);
      no strict 'refs';
      no warnings;
      @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
      @{"$target_class\::ISA"} = ($pseudo_class);
      for (keys %methods) {
          *{"$pseudo_class\::$_"} = $methods{$_};
      }
  }
  
  sub mixin_methods {
      my $mixin_class = shift;
      no strict 'refs';
      my %methods = all_methods($mixin_class);
      map {
          $methods{$_}
            ? ($_, \ &{"$methods{$_}\::$_"})
            : ($_, \ &{"$mixin_class\::$_"})
      } (keys %methods);
  }
  
  sub all_methods {
      no strict 'refs';
      my $class = shift;
      my %methods = map {
          ($_, $class)
      } grep {
          defined &{"$class\::$_"} and not /^_/
      } keys %{"$class\::"};
      return (%methods);
  }
  
  1;
IO_ALL_BASE

$fatpacked{"IO/All/DBM.pm"} = <<'IO_ALL_DBM';
  package IO::All::DBM;
  use strict;
  use warnings;
  use IO::All::File -base;
  use Fcntl;
  
  field _dbm_list => [];
  field '_dbm_class';
  field _dbm_extra => [];
  
  sub dbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_dbm_list([@_]);
      return $self;
  }
  
  sub assert_open {
      my $self = shift;
      return $self->tied_file
        if $self->tied_file;
      $self->open;
  }
  
  sub assert_filepath {
      my $self = shift;
      $self->SUPER::assert_filepath(@_);
      if ($self->_rdonly and not -e $self->pathname) {
          my $rdwr = $self->_rdwr;
          $self->assert(0)->rdwr(1)->rdonly(0)->open;
          $self->close;
          $self->assert(1)->rdwr($rdwr)->rdonly(1);
      }
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      return $self->tied_file if $self->tied_file;
      $self->assert_filepath if $self->_assert;
      my $dbm_list = $self->_dbm_list;
      my @dbm_list = @$dbm_list ? @$dbm_list :
        (qw(DB_File GDBM_File NDBM_File ODBM_File SDBM_File));
      my $dbm_class;
      for my $module (@dbm_list) {
          (my $file = "$module.pm") =~ s{::}{/}g;
          if (defined $INC{$file} || eval "eval 'use $module; 1'") {
              $self->_dbm_class($module);
              last;
          }
      }
      $self->throw("No module available for IO::All DBM operation")
        unless defined $self->_dbm_class;
      my $mode = $self->_rdonly ? O_RDONLY : O_RDWR;
      if ($self->_dbm_class eq 'DB_File::Lock') {
          $self->_dbm_class->import;
          my $type = eval '$DB_HASH'; die $@ if $@;
          # XXX Not sure about this warning
          warn "Using DB_File::Lock in IO::All without the rdonly or rdwr method\n"
            if not ($self->_rdwr or $self->_rdonly);
          my $flag = $self->_rdwr ? 'write' : 'read';
          $mode = $self->_rdwr ? O_RDWR : O_RDONLY;
          $self->_dbm_extra([$type, $flag]);
      }
      $mode |= O_CREAT if $mode & O_RDWR;
      $self->mode($mode);
      $self->perms(0666) unless defined $self->perms;
      return $self->tie_dbm;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $hash;
      my $filename = $self->name;
      my $db = tie %$hash, $self->_dbm_class, $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as DBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_utf8;
      $self->tied_file($hash);
  }
  
  sub add_utf8_dbm_filter {
      my $self = shift;
      my $db = shift;
      $db->filter_store_key(sub { utf8::encode($_) });
      $db->filter_store_value(sub { utf8::encode($_) });
      $db->filter_fetch_key(sub { utf8::decode($_) });
      $db->filter_fetch_value(sub { utf8::decode($_) });
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::DBM - DBM Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_DBM

$fatpacked{"IO/All/Dir.pm"} = <<'IO_ALL_DIR';
  package IO::All::Dir;
  use strict;
  use warnings;
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::Dir;
  
  #===============================================================================
  const type => 'dir';
  option 'sort' => 1;
  chain filter => undef;
  option 'deep';
  field 'chdir_from';
  
  #===============================================================================
  sub dir {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub dir_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_dirpath($self->pathname)
        if $self->pathname and $self->_assert;
      my $handle = IO::Dir->new;
      $self->io_handle($handle);
      $handle->open($self->pathname)
        or $self->throw($self->open_msg);
      return $self;
  }
  
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      return qq{Can't open directory$name:\n$!};
  }
  
  #===============================================================================
  sub All {
      my $self = shift;
      $self->all(0);
  }
  
  sub all {
      my $self = shift;
      my $depth = @_ ? shift(@_) : $self->_deep ? 0 : 1;
      my $first = not @_;
      my @all;
      while (my $io = $self->next) {
          push @all, $io;
          push(@all, $io->all($depth - 1, 1))
            if $depth != 1 and $io->is_dir;
      }
      @all = grep {&{$self->filter}} @all
        if $self->filter;
      return @all unless $first and $self->_sort;
      return sort {$a->pathname cmp $b->pathname} @all;
  }
  
  sub All_Dirs {
      my $self = shift;
      $self->all_dirs(0);
  }
  
  sub all_dirs {
      my $self = shift;
      grep {$_->is_dir} $self->all(@_);
  }
  
  sub All_Files {
      my $self = shift;
      $self->all_files(0);
  }
  
  sub all_files {
      my $self = shift;
      grep {$_->is_file} $self->all(@_);
  }
  
  sub All_Links {
      my $self = shift;
      $self->all_links(0);
  }
  
  sub all_links {
      my $self = shift;
      grep {$_->is_link} $self->all(@_);
  }
  
  sub chdir {
      my $self = shift;
      require Cwd;
      $self->chdir_from(Cwd::cwd());
      CORE::chdir($self->pathname);
      return $self;
  }
  
  sub empty {
      my $self = shift;
      my $dh;
      opendir($dh, $self->pathname) or die;
      while (my $dir = readdir($dh)) {
         return 0 unless $dir =~ /^\.{1,2}$/;
      }
      return 1;
  }
  
  sub mkdir {
      my $self = shift;
      defined($self->perms)
      ? CORE::mkdir($self->pathname, $self->perms)
      : CORE::mkdir($self->pathname);
      return $self;
  }
  
  sub mkpath {
      my $self = shift;
      require File::Path;
      File::Path::mkpath($self->pathname, @_);
      return $self;
  }
  
  sub next {
      my $self = shift;
      $self->assert_open;
      my $name = $self->readdir;
      return unless defined $name;
      my $io = $self->constructor->(File::Spec->catfile($self->pathname, $name));
      $io->absolute if $self->is_absolute;
      return $io;
  }
  
  sub readdir {
      my $self = shift;
      $self->assert_open;
      if (wantarray) {
          my @return = grep {
              not /^\.{1,2}$/
          } $self->io_handle->read;
          $self->close;
          return @return;
      }
      my $name = '.';
      while ($name =~ /^\.{1,2}$/) {
          $name = $self->io_handle->read;
          unless (defined $name) {
              $self->close;
              return;
          }
      }
      return $name;
  }
  
  sub rmdir {
      my $self = shift;
      rmdir $self->pathname;
  }
  
  sub rmtree {
      my $self = shift;
      require File::Path;
      File::Path::rmtree($self->pathname, @_);
  }
  
  sub DESTROY {
      my $self = shift;
      CORE::chdir($self->chdir_from)
        if $self->chdir_from;
        # $self->SUPER::DESTROY(@_);
  }
  
  #===============================================================================
  sub overload_table {
      (
          '${} dir' => 'overload_as_scalar',
          '@{} dir' => 'overload_as_array',
          '%{} dir' => 'overload_as_hash',
      )
  }
  
  sub overload_as_scalar {
      \ $_[1];
  }
  
  sub overload_as_array {
      [ $_[1]->all ];
  }
  
  sub overload_as_hash {
      +{
          map {
              (my $name = $_->pathname) =~ s/.*[\/\\]//;
              ($name, $_);
          } $_[1]->all
      };
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Dir - Directory Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_DIR

$fatpacked{"IO/All/File.pm"} = <<'IO_ALL_FILE';
  package IO::All::File;
  use strict;
  use warnings;
  use IO::All::Filesys -base;
  use IO::All -base;
  use IO::File;
  
  #===============================================================================
  const type => 'file';
  field tied_file => undef;
  
  #===============================================================================
  sub file {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub file_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  #===============================================================================
  sub assert_filepath {
      my $self = shift;
      my $name = $self->pathname
        or return;
      my $directory;
      (undef, $directory) = File::Spec->splitpath($self->pathname);
      $self->assert_dirpath($directory);
  }
  
  sub assert_open_backwards {
      my $self = shift;
      return if $self->is_open;
      require File::ReadBackwards;
      my $file_name = $self->pathname;
      my $io_handle = File::ReadBackwards->new($file_name)
        or $self->throw("Can't open $file_name for backwards:\n$!");
      $self->io_handle($io_handle);
      $self->is_open(1);
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub assert_tied_file {
      my $self = shift;
      return $self->tied_file || do {
          eval {require Tie::File};
          $self->throw("Tie::File required for file array operations:\n$@")
            if $@;
          my $array_ref = do { my @array; \@array };
          my $name = $self->pathname;
          my @options = $self->_rdonly ? (mode => O_RDONLY) : ();
          push @options, (recsep => "\n");
          tie @$array_ref, 'Tie::File', $name, @options;
          $self->throw("Can't tie 'Tie::File' to '$name':\n$!")
            unless tied @$array_ref;
          $self->tied_file($array_ref);
      };
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      $self->assert_filepath if $self->_assert;
      my ($mode, $perms) = @_;
      $self->mode($mode) if defined $mode;
      $self->mode('<') unless defined $self->mode;
      $self->perms($perms) if defined $perms;
      my @args = ($self->mode);
      push @args, $self->perms if defined $self->perms;
      if (defined $self->pathname) {
          $self->io_handle(IO::File->new);
          $self->io_handle->open($self->pathname, @args)
            or $self->throw($self->open_msg);
      }
      elsif (defined $self->_handle and
             not $self->io_handle->opened
            ) {
          # XXX Not tested
          $self->io_handle->fdopen($self->_handle, @args);
      }
      $self->set_lock;
      $self->set_binmode;
  }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->pathname
        ? " '" . $self->pathname . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open file$name$direction:\n$!};
  }
  
  #===============================================================================
  sub close {
      my $self = shift;
      return unless $self->is_open;
      $self->is_open(0);
      my $io_handle = $self->io_handle;
      $self->unlock;
      $self->io_handle(undef);
      $self->mode(undef);
      if (my $tied_file = $self->tied_file) {
          if (ref($tied_file) eq 'ARRAY') {
              untie @$tied_file;
          }
          else {
              untie %$tied_file;
          }
          $self->tied_file(undef);
          return 1;
      }
      $io_handle->close(@_)
        if defined $io_handle;
      return $self;
  }
  
  sub empty {
      my $self = shift;
      -z $self->pathname;
  }
  
  sub filepath {
      my $self = shift;
      my ($volume, $path) = $self->splitpath;
      return File::Spec->catpath($volume, $path, '');
  }
  
  sub getline_backwards {
      my $self = shift;
      $self->assert_open_backwards;
      return $self->io_handle->readline;
  }
  
  sub getlines_backwards {
      my $self = shift;
      my @lines;
      while (defined (my $line = $self->getline_backwards)) {
          push @lines, $line;
      }
      return @lines;
  }
  
  sub head {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
      while ($lines--) {
          push @return, ($self->getline or last);
      }
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub tail {
      my $self = shift;
      my $lines = shift || 10;
      my @return;
      $self->close;
      while ($lines--) {
          unshift @return, ($self->getline_backwards or last);
      }
      $self->close;
      return wantarray ? @return : join '', @return;
  }
  
  sub touch {
      my $self = shift;
      return $self->SUPER::touch(@_)
        if -e $self->pathname;
      return $self if $self->is_open;
      my $mode = $self->mode;
      $self->mode('>>')->open->close;
      $self->mode($mode);
      return $self;
  }
  
  sub unlink {
      my $self = shift;
      unlink $self->pathname;
  }
  
  #===============================================================================
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          'file > file' => 'overload_file_to_file',
          'file < file' => 'overload_file_from_file',
          '${} file' => 'overload_file_as_scalar',
          '@{} file' => 'overload_file_as_array',
          '%{} file' => 'overload_file_as_dbm',
      )
  }
  
  sub overload_file_to_file {
      require File::Copy;
      File::Copy::copy($_[1]->pathname, $_[2]->pathname);
      $_[2];
  }
  
  sub overload_file_from_file {
      require File::Copy;
      File::Copy::copy($_[2]->pathname, $_[1]->pathname);
      $_[1];
  }
  
  sub overload_file_as_array {
      $_[1]->assert_tied_file;
  }
  
  sub overload_file_as_dbm {
      $_[1]->dbm
        unless $_[1]->isa('IO::All::DBM');
      $_[1]->assert_open;
  }
  
  sub overload_file_as_scalar {
      my $scalar = $_[1]->scalar;
      return \$scalar;
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::File - File Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_FILE

$fatpacked{"IO/All/Filesys.pm"} = <<'IO_ALL_FILESYS';
  package IO::All::Filesys;
  use strict;
  use warnings;
  use IO::All::Base -base;
  use Fcntl qw(:flock);
  
  sub exists { my $self = shift; -e $self->name }
  
  sub filename {
      my $self = shift;
      my $filename;
      (undef, undef, $filename) = $self->splitpath;
      return $filename;
  }
  
  sub is_absolute {
      my $self = shift;
      return *$self->{is_absolute} = shift if @_;
      return *$self->{is_absolute}
        if defined *$self->{is_absolute};
      *$self->{is_absolute} = IO::All::is_absolute($self) ? 1 : 0;
  }
  
  sub is_executable { my $self = shift; -x $self->name }
  sub is_readable { my $self = shift; -r $self->name }
  sub is_writable { my $self = shift; -w $self->name }
  {
      no warnings 'once';
      *is_writeable = \&is_writable;
  }
  
  sub pathname {
      my $self = shift;
      return *$self->{pathname} = shift if @_;
      return *$self->{pathname} if defined *$self->{pathname};
      return $self->name;
  }
  
  sub relative {
      my $self = shift;
      $self->pathname(File::Spec->abs2rel($self->pathname))
        if $self->is_absolute;
      $self->is_absolute(0);
      return $self;
  }
  
  sub rename {
      my $self = shift;
      my $new = shift;
      rename($self->name, "$new")
        ? UNIVERSAL::isa($new, 'IO::All')
          ? $new
          : $self->constructor->($new)
        : undef;
  }
  
  sub set_lock {
      my $self = shift;
      return unless $self->_lock;
      my $io_handle = $self->io_handle;
      my $flag = $self->mode =~ /^>>?$/
      ? LOCK_EX
      : LOCK_SH;
      flock $io_handle, $flag;
  }
  
  sub stat {
      my $self = shift;
      return IO::All::stat($self, @_)
        if $self->is_open;
        CORE::stat($self->pathname);
  }
  
  sub touch {
      my $self = shift;
      $self->utime;
  }
  
  sub unlock {
      my $self = shift;
      flock $self->io_handle, LOCK_UN
        if $self->_lock;
  }
  
  sub utime {
      my $self = shift;
      my $atime = shift;
      my $mtime = shift;
      $atime = time unless defined $atime;
      $mtime = $atime unless defined $mtime;
      utime($atime, $mtime, $self->name);
      return $self;
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Filesys - File System Methods Mixin for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
IO_ALL_FILESYS

$fatpacked{"IO/All/Link.pm"} = <<'IO_ALL_LINK';
  package IO::All::Link;
  use strict;
  use warnings;
  use IO::All::File -base;
  
  const type => 'link';
  
  sub link {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      $self->_init;
  }
  
  sub readlink {
      my $self = shift;
      $self->constructor->(CORE::readlink($self->name));
  }
  
  sub symlink {
      my $self = shift;
      my $target = shift;
      $self->assert_filepath if $self->_assert;
      CORE::symlink($target, $self->pathname);
  }
  
  sub AUTOLOAD {
      my $self = shift;
      our $AUTOLOAD;
      (my $method = $AUTOLOAD) =~ s/.*:://;
      my $target = $self->target;
      unless ($target) {
          $self->throw("Can't call $method on symlink");
          return;
      }
      $target->$method(@_);
  }
  
  sub target {
      my $self = shift;
      return *$self->{target} if *$self->{target};
      my %seen;
      my $link = $self;
      my $new;
      while ($new = $link->readlink) {
          my $type = $new->type or return;
          last if $type eq 'file';
          last if $type eq 'dir';
          return unless $type eq 'link';
          return if $seen{$new->name}++;
          $link = $new;
      }
      *$self->{target} = $new;
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Link - Symbolic Link Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_LINK

$fatpacked{"IO/All/MLDBM.pm"} = <<'IO_ALL_MLDBM';
  package IO::All::MLDBM;
  use strict;
  use warnings;
  use IO::All::DBM -base;
  
  field _serializer => 'Data::Dumper';
  
  sub mldbm {
      my $self = shift;
      bless $self, __PACKAGE__;
      my ($serializer) = grep { /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_serializer($serializer) if defined $serializer;
      my @dbm_list = grep { not /^(Storable|Data::Dumper|FreezeThaw)$/ } @_;
      $self->_dbm_list([@dbm_list]);
      return $self;
  }
  
  sub tie_dbm {
      my $self = shift;
      my $filename = $self->name;
      my $dbm_class = $self->_dbm_class;
      my $serializer = $self->_serializer;
      eval "use MLDBM qw($dbm_class $serializer)";
      $self->throw("Can't open '$filename' as MLDBM:\n$@") if $@;
      my $hash;
      my $db = tie %$hash, 'MLDBM', $filename, $self->mode, $self->perms,
          @{$self->_dbm_extra}
        or $self->throw("Can't open '$filename' as MLDBM file:\n$!");
      $self->add_utf8_dbm_filter($db)
        if $self->_utf8;
      $self->tied_file($hash);
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::MLDBM - MLDBM Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_MLDBM

$fatpacked{"IO/All/Pipe.pm"} = <<'IO_ALL_PIPE';
  package IO::All::Pipe;
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'pipe';
  
  sub pipe {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      require IO::Handle;
      $self->io_handle(IO::Handle->new)
        unless defined $self->io_handle;
      my $command = $self->name;
      $command =~ s/(^\||\|$)//;
      my $mode = shift || $self->mode || '<';
      my $pipe_mode =
        $mode eq '>' ? '|-' :
        $mode eq '<' ? '-|' :
        $self->throw("Invalid usage mode '$mode' for pipe");
      CORE::open($self->io_handle, $pipe_mode, $command);
      $self->set_binmode;
  }
  
  my %mode_msg = (
      '>' => 'output',
      '<' => 'input',
      '>>' => 'append',
  );
  sub open_msg {
      my $self = shift;
      my $name = defined $self->name
        ? " '" . $self->name . "'"
        : '';
      my $direction = defined $mode_msg{$self->mode}
        ? ' for ' . $mode_msg{$self->mode}
        : '';
      return qq{Can't open pipe$name$direction:\n$!};
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Pipe - Pipe Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_PIPE

$fatpacked{"IO/All/STDIO.pm"} = <<'IO_ALL_STDIO';
  package IO::All::STDIO;
  use strict;
  use warnings;
  use IO::All -base;
  use IO::File;
  
  const type => 'stdio';
  
  sub stdio {
      my $self = shift;
      bless $self, __PACKAGE__;
      return $self->_init;
  }
  
  sub stdin {
      my $self = shift;
      $self->open('<');
      return $self;
  }
  
  sub stdout {
      my $self = shift;
      $self->open('>');
      return $self;
  }
  
  sub stderr {
      my $self = shift;
      $self->open_stderr;
      return $self;
  }
  
  sub open {
      my $self = shift;
      $self->is_open(1);
      my $mode = shift || $self->mode || '<';
      my $fileno = $mode eq '>'
      ? fileno(STDOUT)
      : fileno(STDIN);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen($fileno, $mode);
      $self->set_binmode;
  }
  
  sub open_stderr {
      my $self = shift;
      $self->is_open(1);
      $self->io_handle(IO::File->new);
      $self->io_handle->fdopen(fileno(STDERR), '>') ? $self : 0;
  }
  
  # XXX Add overload support
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::STDIO - STDIO Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_STDIO

$fatpacked{"IO/All/Socket.pm"} = <<'IO_ALL_SOCKET';
  package IO::All::Socket;
  use strict;
  use warnings;
  use IO::All -base;
  use IO::Socket;
  
  const type => 'socket';
  field _listen => undef;
  option 'fork';
  const domain_default => 'localhost';
  chain domain => undef;
  chain port => undef;
  proxy_open 'recv';
  proxy_open 'send';
  
  sub socket {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->name(shift) if @_;
      return $self->_init;
  }
  
  sub socket_handle {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_handle(shift) if @_;
      return $self->_init;
  }
  
  sub accept {
      my $self = shift;
      use POSIX ":sys_wait_h";
      sub REAPER {
          while (waitpid(-1, WNOHANG) > 0) {}
          $SIG{CHLD} = \&REAPER;
      }
      local $SIG{CHLD};
      $self->_listen(1);
      $self->assert_open;
      my $server = $self->io_handle;
      my $socket;
      while (1) {
          $socket = $server->accept;
          last unless $self->_fork;
          next unless defined $socket;
          $SIG{CHLD} = \&REAPER;
          my $pid = CORE::fork;
          $self->throw("Unable to fork for IO::All::accept")
            unless defined $pid;
          last unless $pid;
          close $socket;
          undef $socket;
      }
      close $server if $self->_fork;
      my $io = ref($self)->new->socket_handle($socket);
      $io->io_handle($socket);
      $io->is_open(1);
      return $io;
  }
  
  sub shutdown {
      my $self = shift;
      my $how = @_ ? shift : 2;
      my $handle = $self->io_handle;
      $handle->shutdown(2)
        if defined $handle;
  }
  
  sub assert_open {
      my $self = shift;
      return if $self->is_open;
      $self->mode(shift) unless $self->mode;
      $self->open;
  }
  
  sub open {
      my $self = shift;
      return if $self->is_open;
      $self->is_open(1);
      $self->get_socket_domain_port;
      my @args = $self->_listen
      ? (
          LocalAddr => $self->domain,
          LocalPort => $self->port,
          Proto => 'tcp',
          Listen => 1,
          Reuse => 1,
      )
      : (
          PeerAddr => $self->domain,
          PeerPort => $self->port,
          Proto => 'tcp',
      );
      my $socket = IO::Socket::INET->new(@args)
        or $self->throw("Can't open socket");
      $self->io_handle($socket);
      $self->set_binmode;
  }
  
  sub get_socket_domain_port {
      my $self = shift;
      my ($domain, $port);
      ($domain, $port) = split /:/, $self->name
        if defined $self->name;
      $self->domain($domain) unless defined $self->domain;
      $self->domain($self->domain_default) unless $self->domain;
      $self->port($port) unless defined $self->port;
      return $self;
  }
  
  sub overload_table {
      my $self = shift;
      (
          $self->SUPER::overload_table(@_),
          '&{} socket' => 'overload_socket_as_code',
      )
  }
  
  sub overload_socket_as_code {
      my $self = shift;
      sub {
          my $coderef = shift;
          while ($self->is_open) {
              $_ = $self->getline;
              &$coderef($self);
          }
      }
  }
  
  sub overload_any_from_any {
      my $self = shift;
      $self->SUPER::overload_any_from_any(@_);
      $self->close;
  }
  
  sub overload_any_to_any {
      my $self = shift;
      $self->SUPER::overload_any_to_any(@_);
      $self->close;
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Socket - Socket Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008, 2010. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_SOCKET

$fatpacked{"IO/All/String.pm"} = <<'IO_ALL_STRING';
  package IO::All::String;
  use strict;
  use warnings;
  use IO::All -base;
  use IO::String;
  
  const type => 'string';
  proxy 'string_ref';
  
  sub string {
      my $self = shift;
      bless $self, __PACKAGE__;
      $self->_init;
  }
  
  sub open {
      my $self = shift;
      $self->io_handle(IO::String->new);
      $self->set_binmode;
      $self->is_open(1);
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::String - String IO Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson. All rights reserved.
  
  Copyright (c) 2006, 2008. Ingy döt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_STRING

$fatpacked{"IO/All/Temp.pm"} = <<'IO_ALL_TEMP';
  package IO::All::Temp;
  use strict;
  use warnings;
  use IO::All::File -base;
  
  sub temp {
      my $self = shift;
      bless $self, __PACKAGE__;
      my $temp_file = IO::File::new_tmpfile()
        or $self->throw("Can't create temporary file");
      $self->io_handle($temp_file);
      $self->error_check;
      $self->autoclose(0);
      $self->is_open(1);
      return $self;
  }
  
  =encoding utf8
  
  =head1 NAME
  
  IO::All::Temp - Temporary File Support for IO::All
  
  =head1 SYNOPSIS
  
  See L<IO::All>.
  
  =head1 DESCRIPTION
  
  =head1 AUTHOR
  
  Ingy döt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004. Brian Ingerson.
  
  Copyright (c) 2006, 2008. Ingy döt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See http://www.perl.com/perl/misc/Artistic.html
  
  =cut
  
  1;
IO_ALL_TEMP

$fatpacked{"Installer.pm"} = <<'INSTALLER';
  package Installer;
  BEGIN {
    $Installer::AUTHORITY = 'cpan:GETTY';
  }
  {
    $Installer::VERSION = '0.004';
  }
  # ABSTRACT: What does it do? It installs stuff....
  
  use strict;
  use warnings;
  use Installer::Target;
  
  our @functions = qw(
  
    run
    url
    file
    perl
    cpanm
    pip
  
  );
  
  sub import {
    my $pkg = caller;
    {
      no strict 'refs';
      *{"$pkg\::install_to"} = sub {
        my ( $target_directory, $installer_code ) = @_;
        my $installer_target = Installer::Target->new(
          target_directory => $target_directory,
          installer_code => $installer_code,
        );
        $installer_target->installation;
      };
    }
    for my $command (@functions) {
      my $function = 'install_'.$command;
      no strict 'refs';
      *{"$pkg\::$command"} = sub {
        die "Not inside installation" unless defined $Installer::Target::current;
        $Installer::Target::current->$function(@_);
      };
    }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Installer - What does it do? It installs stuff....
  
  =head1 VERSION
  
  version 0.004
  
  =head1 SYNOPSIS
  
    use Installer;
  
    install_to $ENV{HOME}.'/myenv' => sub {
      perl "5.18.1";
      url "http://ftp.postgresql.org/pub/source/v9.2.4/postgresql-9.2.4.tar.gz", with => {
        pgport => 15432,
      };
      url "http://download.osgeo.org/gdal/1.10.1/gdal-1.10.1.tar.gz";
      url "http://download.osgeo.org/geos/geos-3.4.2.tar.bz2";
      url "http://download.osgeo.org/postgis/source/postgis-2.1.0.tar.gz", custom_test => sub {
        $_[0]->run($_[0]->unpack_path,'make','check');
      };
      cpanm "DBD::Pg";
    };
  
  Or in class usage (not suggested):
  
    use Installer::Target;
  
    my $target = Installer::Target->new(
      target_directory => $ENV{HOME}.'/myenv',
      output_code => sub {
        your_own_logger(join(" ",@_));
      },
    );
  
    $target->prepare_installation;
    $target->install_perl("5.18.1");
    $target->install_file("postgresql-9.2.4.tar.gz", with => {
      pgport => 15432,
    });
    $target->install_cpanm("DBD::Pg","Plack");
    # will run in the target directory
    $target->install_run("command","--with-args");
    $target->finish_installation;
  
    # to get the filename of the log produced on the installation
    print $target->log_filename;
  
    my $other_usage = Installer::Target->new(
      target_directory => $ENV{HOME}.'/otherenv',
      installer_code => sub {
        $_[0]->install_perl("5.18.1");
        $_[0]->install_cpanm("Task::Kensho");
      },
    );
  
    $other_usage->installation;
  
  =head1 DESCRIPTION
  
  See L<installer> for more information.
  
  B<TOTALLY BETA, PLEASE TEST :D>
  
  =encoding utf8
  
  =head1 AUTHOR
  
  Torsten Raudssus <torsten@raudss.us>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Torsten Raudssus.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
INSTALLER

$fatpacked{"Installer/Software.pm"} = <<'INSTALLER_SOFTWARE';
  package Installer::Software;
  BEGIN {
    $Installer::Software::AUTHORITY = 'cpan:GETTY';
  }
  {
    $Installer::Software::VERSION = '0.004';
  }
  # ABSTRACT: A software installation
  
  use Moo;
  use IO::All;
  use JSON_File;
  use Path::Class;
  use File::chdir;
  use Archive::Extract;
  use namespace::clean;
  
  has target => (
    is => 'ro',
    required => 1,
  );
  sub log_print { shift->target->log_print(@_) }
  sub run { shift->target->run(@_) }
  sub target_directory { shift->target->target->stringify }
  sub target_path { shift->target->target_path(@_) }
  sub target_file { shift->target->target_file(@_) }
  
  has archive_url => (
    is => 'ro',
    predicate => 1,
  );
  
  has archive => (
    is => 'ro',
    predicate => 1,
  );
  
  for (qw( custom_configure custom_test post_install export_sh )) {
    has $_ => (
      is => 'ro',
      predicate => 1,
    );
  }
  
  for (qw( with enable disable without )) {
    has $_ => (
      is => 'ro',
      predicate => 1,
    );
  }
  
  has alias => (
    is => 'ro',
    lazy => 1,
    default => sub {
      my ( $self ) = @_;
      if ($self->has_archive_url) {
        return (split('-',(split('/',io($self->archive_url)->uri->path))[-1]))[0];
      } elsif ($self->has_archive) {
        return (split('-',(split('/',$self->archive))[-1]))[0];
      }
      die "Can't produce an alias for this sofware";
    },
  );
  
  has meta => (
    is => 'ro',
    lazy => 1,
    default => sub {
      my ( $self ) = @_;
      tie(my %meta,'JSON_File',file($self->target->installer_dir,$_[0]->alias.'.json')->stringify,, pretty => 1 );
      return \%meta;
    },
  );
  
  has testable => (
    is => 'ro',
    lazy => 1,
    default => sub { $_[0]->has_custom_test ? 1 : 0 },
  );
  
  sub installation {
    my ( $self ) = @_;
    $self->fetch;
    $self->unpack;
    $self->configure;
    $self->compile;
    $self->test if $self->testable;
    $self->install;
  }
  
  sub fetch {
    my ( $self ) = @_;
    return if defined $self->meta->{fetch};
    if ($self->has_archive_url) {
      my $sio = io($self->archive_url);
      my $filename = (split('/',$sio->uri->path))[-1];
      $self->log_print("Downloading ".$self->archive_url." as ".$filename." ...");
      my $full_filename = file($self->target->src_dir,$filename)->stringify;
      io($full_filename)->print(io($self->archive_url)->get->content);
      $self->meta->{fetch} = $full_filename;
    } elsif ($self->has_archive) {
      $self->meta->{fetch} = file($self->archive)->absolute->stringify;
    }
    die "Unable to get an archive for unpacking for this software" unless defined $self->meta->{fetch};
  }
  sub fetch_path { file(shift->meta->{fetch}) }
  
  sub unpack {
    my ( $self ) = @_;
    return if defined $self->meta->{unpack};
    $self->log_print("Extracting ".$self->fetch_path." ...");
    my $archive = Archive::Extract->new( archive => $self->fetch_path );
    local $CWD = $self->target->src_dir;
    $archive->extract;
    for (@{$archive->files}) {
      $self->target->log($_);
    }
    my $src_path = dir($archive->extract_path)->absolute->stringify;
    $self->log_print("Extracted to ".$src_path." ...");
    $self->meta->{unpack} = $src_path;
  }
  sub unpack_path { dir(shift->meta->{unpack},@_) }
  sub unpack_file { file(shift->meta->{unpack},@_) }
  
  sub run_configure {
    my ( $self, @configure_args ) = @_;
    if ($self->has_with) {
      for my $key (keys %{$self->with}) {
        my $value = $self->with->{$key};
        if (defined $value && $value ne "") {
          push @configure_args, '--with-'.$key.'='.$value;
        } else {
          push @configure_args, '--with-'.$key;
        }
      }
    }
    for my $func (qw( enable disable without )) {
      my $has_func = 'has_'.$func;
      if ($self->$has_func) {
        for my $value (@{$self->$func}) {
          push @configure_args, '--'.$func.'-'.$value;
        }
      }
    }
    $self->run($self->unpack_path,'./configure','--prefix='.$self->target_directory,@configure_args);
  }
  
  sub configure {
    my ( $self ) = @_;
    return if defined $self->meta->{configure};
    $self->log_print("Configuring ".$self->unpack_path." ...");
    if ($self->has_custom_configure) {
      $self->custom_configure->($self);
    } else {
      if (-f $self->unpack_file('autogen.sh')) {
        $self->run($self->unpack_path,'./autogen.sh');
      }
      if (-f $self->unpack_file('configure')) {
        $self->run_configure;
      } elsif (-f $self->unpack_path('setup.py')) {
        # no configure
      } elsif ($self->unpack_file('Makefile.PL')) {
        $self->run($self->unpack_path,'perl','Makefile.PL');
      }
    }
    $self->meta->{configure} = 1;
  }
  
  sub compile {
    my ( $self ) = @_;
    return if defined $self->meta->{compile};
    $self->log_print("Compiling ".$self->unpack_path." ...");
    if (-f $self->unpack_file('setup.py') and !-f $self->unpack_file('configure')) {
      $self->run($self->unpack_path,'python','setup.py','build');
    } elsif (-f $self->unpack_file('Makefile')) {
      $self->run($self->unpack_path,'make');
    }
    $self->meta->{compile} = 1;
  }
  
  sub test {
    my ( $self ) = @_;
    return if defined $self->meta->{test};
    $self->log_print("Testing ".$self->unpack_path." ...");
    if ($self->has_custom_test) {
      $self->custom_test->($self);
    } else {
      if (-f $self->unpack_file('Makefile')) {
        $self->run($self->unpack_path,'make','test');
      }
    }
    $self->meta->{test} = 1;
  }
  
  sub install {
    my ( $self ) = @_;
    return if defined $self->meta->{install};
    $self->log_print("Installing ".$self->unpack_path." ...");
    if (-f $self->unpack_file('setup.py') and !-f $self->unpack_file('configure')) {
      $self->run($self->unpack_path,'python','setup.py','install');
    } elsif (-f $self->unpack_file('Makefile')) {
      $self->run($self->unpack_path,'make','install');
    }
    $self->meta->{install} = 1;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Installer::Software - A software installation
  
  =head1 VERSION
  
  version 0.004
  
  =head1 AUTHOR
  
  Torsten Raudssus <torsten@raudss.us>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Torsten Raudssus.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
INSTALLER_SOFTWARE

$fatpacked{"Installer/Target.pm"} = <<'INSTALLER_TARGET';
  package Installer::Target;
  BEGIN {
    $Installer::Target::AUTHORITY = 'cpan:GETTY';
  }
  {
    $Installer::Target::VERSION = '0.004';
  }
  # ABSTRACT: Currently running project
  
  use Moo;
  use IO::All;
  use IPC::Open3 ();
  use Installer::Software;
  use JSON_File;
  use File::chdir;
  use CPAN::Perl::Releases qw[perl_tarballs];
  use CPAN;
  use Path::Class;
  use namespace::clean;
  
  has output_code => (
    is => 'ro',
    lazy => 1,
    default => sub { sub {
      print @_, "\n";
    } },
  );
  
  has installer_code => (
    is => 'ro',
    required => 1,
  );
  
  has target_directory => (
    is => 'ro',
    required => 1,
  );
  
  has target => (
    is => 'ro',
    lazy => 1,
    default => sub { dir($_[0]->target_directory)->absolute },
  );
  sub target_path { dir(shift->target,@_) }
  sub target_file { file(shift->target,@_) }
  
  has installer_dir => (
    is => 'ro',
    lazy => 1,
    default => sub { dir($_[0]->target,'installer') },
  );
  
  has software => (
    is => 'ro',
    lazy => 1,
    default => sub {{}},
  );
  
  has actions => (
    is => 'ro',
    lazy => 1,
    default => sub {[]},
  );
  
  has src_dir => (
    is => 'ro',
    lazy => 1,
    default => sub { dir($_[0]->target,'src') },
  );
  
  has log_filename => (
    is => 'ro',
    lazy => 1,
    default => sub { file($_[0]->installer_dir,'build.'.(time).'.log') },
  );
  
  has log_io => (
    is => 'ro',
    lazy => 1,
    default => sub { io($_[0]->log_filename) },
  );
  
  has meta => (
    is => 'ro',
    lazy => 1,
    default => sub {
      my ( $self ) = @_;
      tie(my %meta,'JSON_File',file($self->installer_dir,'meta.json')->absolute->stringify, pretty => 1);
      return \%meta;
    },
  );
  
  sub install_software {
    my ( $self, $software ) = @_;
    $self->software->{$software->alias} = $software;
    $software->installation;
    $self->meta->{software_packages_done} = [keys %{$self->software}];
    push @{$self->actions}, $software;
    $self->update_env;
    if (!defined $software->meta->{post_install} && $software->has_post_install) {
      $software->post_install->($software);
      $software->meta->{post_install} = 1;
    }
  }
  
  sub install_url {
    my ( $self, $url, %args ) = @_;
    $self->install_software(Installer::Software->new(
      target => $self,
      archive_url => $url,
      %args,
    ));
  }
  
  sub install_file {
    my ( $self, $file, %args ) = @_;
    $self->install_software(Installer::Software->new(
      target => $self,
      archive => rel2abs(catfile($file)),
      %args,
    ));
  }
  
  sub install_perl {
    my ( $self, $perl_version, %args ) = @_;
    my $hashref = perl_tarballs($perl_version);
    my $src = 'http://www.cpan.org/authors/id/'.$hashref->{'tar.gz'};
    $self->install_software(Installer::Software->new(
      target => $self,
      archive_url => $src,
      testable => 1,
      custom_configure => sub {
        my ( $self ) = @_;
        $self->run($self->unpack_path,'./Configure','-des','-Dprefix='.$self->target_directory);
      },
      post_install => sub {
        my ( $self ) = @_;
        $self->log_print("Installing App::cpanminus ...");
        my $cpanm_filename = file($self->target->installer_dir,'cpanm');
        io($cpanm_filename)->print(io('http://cpanmin.us/')->get->content);
        chmod(0755,$cpanm_filename);
        $self->run(undef,$cpanm_filename,'-L',$self->target_path('perl5'),qw(
          App::cpanminus
          local::lib
          Module::CPANfile
        ));
      },
      export_sh => sub {
        my ( $self ) = @_;
        return 'eval $( perl -I'.$self->target_path('perl5','lib','perl5').' -Mlocal::lib='.$self->target_path('perl5').' )';
      },
      %args,
    ));
  }
  
  sub install_cpanm {
    my ( $self, @modules ) = @_;
    $self->run(undef,'cpanm',@modules);
  }
  
  sub install_pip {
    my ( $self, @modules ) = @_;
    for (@modules) {
      $self->run(undef,'pip','install',$_);    
    }
  }
  
  sub setup_env {
    my ( $self ) = @_;
    if (defined $self->meta->{PATH} && @{$self->meta->{PATH}}) {
      $ENV{PATH} = (join(':',@{$self->meta->{PATH}})).':'.$ENV{PATH};
    }
    if (defined $self->meta->{LD_LIBRARY_PATH} && @{$self->meta->{LD_LIBRARY_PATH}}) {
      $ENV{LD_LIBRARY_PATH} = (join(':',@{$self->meta->{LD_LIBRARY_PATH}})).(defined $ENV{LD_LIBRARY_PATH} ? ':'.$ENV{LD_LIBRARY_PATH} : '');
    }
  }
  
  sub update_env {
    my ( $self ) = @_;
    my %seen = defined $self->meta->{seen_dirs}
      ? %{$self->meta->{seen_dirs}}
      : ();
    if (!$seen{'bin'} and -e $self->target_path('bin')) {
      my @bindirs = defined $self->meta->{PATH}
        ? @{$self->meta->{PATH}}
        : ();
      my $bindir = $self->target_path('bin')->absolute->stringify;
      push @bindirs, $bindir;
      $self->meta->{PATH} = \@bindirs;
      $ENV{PATH} = $bindir.':'.$ENV{PATH};
      $seen{'bin'} = 1;
    }
    if (!$seen{'lib'} and -e $self->target_path('lib')) {
      my @libdirs = defined $self->meta->{LD_LIBRARY_PATH}
        ? @{$self->meta->{LD_LIBRARY_PATH}}
        : ();
      my $libdir = $self->target_path('lib')->absolute->stringify;
      push @libdirs, $libdir;
      $self->meta->{LD_LIBRARY_PATH} = \@libdirs;
      $ENV{LD_LIBRARY_PATH} = $libdir.(defined $ENV{LD_LIBRARY_PATH} ? ':'.$ENV{LD_LIBRARY_PATH} : '');
      $seen{'lib'} = 1;
    }
    $self->meta->{seen_dirs} = \%seen;
  }
  
  sub install_run {
    my ( $self, @args ) = @_;
    $self->run($self->target,@args);
    push @{$self->actions}, {
      run => \@args,
    };
  }
  
  sub run {
    my ( $self, $dir, @args ) = @_;
    $dir = $self->target_path unless $dir;
    local $CWD = "$dir";
    $self->log_print("Executing in $dir: ".join(" ",@args));
    $|=1;
    my $run_log = "";
    my $pid = IPC::Open3::open3(my ( $in, $out ), undef, join(" ",@args));
    while(defined(my $line = <$out>)){
      $run_log .= $line;
      chomp($line);
      $self->log($line);
    }
    waitpid($pid, 0);
    my $status = $? >> 8;
    if ($status) {
      print $run_log;
      print "\n";
      print "     Command: ".join(" ",@args)."\n";
      print "in Directory: ".$dir."\n";
      print "exited with status $status\n\n";
      print "\n";
      die "Error on run ".$self->log_filename;
    }
  }
  
  sub log {
    my ( $self, @line ) = @_;
    $self->log_io->append(join(" ",@line),"\n");
  }
  
  sub log_print {
    my ( $self, @line ) = @_;
    $self->log("#" x 80);
    $self->log("##");
    $self->log("## ",@line);
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
    $self->log("## ",sprintf("%.2d.%.2d.%.4d %.2d:%.2d:%.2d",$mday,$mon,$year+1900,$hour,$min,$sec));
    $self->log("##");
    $self->log("#" x 80);
    $self->output_code->(@line);
  }
  
  sub write_export {
    my ( $self ) = @_;
    my $export_filename = $self->target_file('export.sh');
    $self->log_print("Generating ".$export_filename." ...");
    my $export_sh = "#!/bin/sh\n#\n# Installer auto generated export.sh\n#\n".("#" x 60)."\n\n";
    if (defined $self->meta->{PATH} && @{$self->meta->{PATH}}) {
      $export_sh .= 'export PATH="'.join(':',@{$self->meta->{PATH}}).':$PATH"'."\n";
    }
    if (defined $self->meta->{LD_LIBRARY_PATH} && @{$self->meta->{LD_LIBRARY_PATH}}) {
      $export_sh .= 'export LD_LIBRARY_PATH="'.join(':',@{$self->meta->{LD_LIBRARY_PATH}}).':$LD_LIBRARY_PATH"'."\n";
    }
    $export_sh .= "\n";
    for (@{$self->meta->{software_packages_done}}) {
      my $software = $self->software->{$_};
      if ($software->has_export_sh) {
        my @lines = $software->export_sh->($software);
        $export_sh .= "# export.sh addition by ".$software->alias."\n";
        $export_sh .= join("\n",@lines)."\n\n";
      }
    }
    $export_sh .= ("#" x 60)."\n";
    io($export_filename)->print($export_sh);
    chmod(0755,$export_filename);
  }
  
  our $current;
  
  sub prepare_installation {
    my ( $self ) = @_;
    die "Target directory is a file" if -f $self->target;
    $current = $self;
    $self->target->mkpath unless -d $self->target;
    $self->installer_dir->mkpath unless -d $self->installer_dir;
    $self->src_dir->mkpath unless -d $self->src_dir;
    $self->log_io->print(("#" x 80)."\nStarting new log ".(time)."\n".("#" x 80)."\n\n");
    $self->meta->{last_run} = time;
    $self->meta->{preinstall_ENV} = \%ENV;
    $self->setup_env;
  }
  
  sub finish_installation {
    my ( $self ) = @_;
    $self->write_export;
    $self->log_print("Done");
    %ENV = %{$self->meta->{preinstall_ENV}};
    delete $self->meta->{preinstall_ENV};
    $current = undef;
  }
  
  sub installation {
    my ( $self ) = @_;
    $self->prepare_installation;
    $self->installer_code->($self);
    $self->finish_installation;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Installer::Target - Currently running project
  
  =head1 VERSION
  
  version 0.004
  
  =head1 AUTHOR
  
  Torsten Raudssus <torsten@raudss.us>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Torsten Raudssus.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
INSTALLER_TARGET

$fatpacked{"Method/Generate/Accessor.pm"} = <<'METHOD_GENERATE_ACCESSOR';
  package Method::Generate::Accessor;
  
  use strictures 1;
  use Moo::_Utils;
  use base qw(Moo::Object);
  use Sub::Quote;
  use B 'perlstring';
  use Scalar::Util 'blessed';
  use overload ();
  use Module::Runtime qw(use_module);
  BEGIN {
    our $CAN_HAZ_XS =
      !$ENV{MOO_XS_DISABLE}
        &&
      _maybe_load_module('Class::XSAccessor')
        &&
      (eval { Class::XSAccessor->VERSION('1.07') })
    ;
  }
  
  sub _SIGDIE
  {
    our ($CurrentAttribute, $OrigSigDie);
    $OrigSigDie ||= sub { die $_[0] };
    
    return $OrigSigDie->(@_) if ref($_[0]);
    
    my $attr_desc = _attr_desc(@$CurrentAttribute{qw(name init_arg)});
    $OrigSigDie->("$CurrentAttribute->{step} for $attr_desc failed: $_[0]");
  }
  
  sub _die_overwrite
  {
    my ($pkg, $method, $type) = @_;
    die "You cannot overwrite a locally defined method ($method) with @{[ $type || 'an accessor' ]}";
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    $spec->{allow_overwrite}++ if $name =~ s/^\+//;
    die "Must have an is" unless my $is = $spec->{is};
    if ($is eq 'ro') {
      $spec->{reader} = $name unless exists $spec->{reader};
    } elsif ($is eq 'rw') {
      $spec->{accessor} = $name unless exists $spec->{accessor}
        or ( $spec->{reader} and $spec->{writer} );
    } elsif ($is eq 'lazy') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{lazy} = 1;
      $spec->{builder} ||= '_build_'.$name unless $spec->{default};
    } elsif ($is eq 'rwp') {
      $spec->{reader} = $name unless exists $spec->{reader};
      $spec->{writer} = "_set_${name}" unless exists $spec->{writer};
    } elsif ($is ne 'bare') {
      die "Unknown is ${is}";
    }
    if (exists $spec->{builder}) {
      if(ref $spec->{builder}) {
        $self->_validate_codulatable('builder', $spec->{builder},
          "$into->$name", 'or a method name');
        $spec->{builder_sub} = $spec->{builder};
        $spec->{builder} = 1;
      }
      $spec->{builder} = '_build_'.$name if ($spec->{builder}||0) eq 1;
      die "Invalid builder for $into->$name - not a valid method name"
        if $spec->{builder} !~ /\A[A-Za-z_][A-Za-z0-9_]*(?:::[A-Za-z_][A-Za-z0-9_]*)*\z/;
    }
    if (($spec->{predicate}||0) eq 1) {
      $spec->{predicate} = $name =~ /^_/ ? "_has${name}" : "has_${name}";
    }
    if (($spec->{clearer}||0) eq 1) {
      $spec->{clearer} = $name =~ /^_/ ? "_clear${name}" : "clear_${name}";
    }
    if (($spec->{trigger}||0) eq 1) {
      $spec->{trigger} = quote_sub('shift->_trigger_'.$name.'(@_)');
    }
  
    for my $setting (qw( isa coerce )) {
      next if !exists $spec->{$setting};
      $self->_validate_codulatable($setting, $spec->{$setting}, "$into->$name");
    }
  
    if (exists $spec->{default}) {
      if (!defined $spec->{default} || ref $spec->{default}) {
        $self->_validate_codulatable('default', $spec->{default}, "$into->$name", 'or a non-ref');
      }
    }
  
    if (exists $spec->{moosify}) {
      if (ref $spec->{moosify} ne 'ARRAY') {
        $spec->{moosify} = [$spec->{moosify}];
      }
  
      for my $spec (@{$spec->{moosify}}) {
        $self->_validate_codulatable('moosify', $spec, "$into->$name");
      }
    }
  
    my %methods;
    if (my $reader = $spec->{reader}) {
      _die_overwrite($into, $reader, 'a reader')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${reader}")}{CODE};
      if (our $CAN_HAZ_XS && $self->is_simple_get($name, $spec)) {
        $methods{$reader} = $self->_generate_xs(
          getters => $into, $reader, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$reader} =
          quote_sub "${into}::${reader}"
            => '    die "'.$reader.' is a read-only accessor" if @_ > 1;'."\n"
               .$self->_generate_get($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $accessor = $spec->{accessor}) {
      _die_overwrite($into, $accessor, 'an accessor')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${accessor}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_get($name, $spec)
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$accessor} = $self->_generate_xs(
          accessors => $into, $accessor, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$accessor} =
          quote_sub "${into}::${accessor}"
            => $self->_generate_getset($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $writer = $spec->{writer}) {
      _die_overwrite($into, $writer, 'a writer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${writer}")}{CODE};
      if (
        our $CAN_HAZ_XS
        && $self->is_simple_set($name, $spec)
      ) {
        $methods{$writer} = $self->_generate_xs(
          setters => $into, $writer, $name, $spec
        );
      } else {
        $self->{captures} = {};
        $methods{$writer} =
          quote_sub "${into}::${writer}"
            => $self->_generate_set($name, $spec)
            => delete $self->{captures}
          ;
      }
    }
    if (my $pred = $spec->{predicate}) {
      _die_overwrite($into, $pred, 'a predicate')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${pred}")}{CODE};
      $methods{$pred} =
        quote_sub "${into}::${pred}" =>
          '    '.$self->_generate_simple_has('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $pred = $spec->{builder_sub}) {
      _install_coderef( "${into}::$spec->{builder}" => $spec->{builder_sub} );
    }
    if (my $cl = $spec->{clearer}) {
      _die_overwrite($into, $cl, 'a clearer')
        if !$spec->{allow_overwrite} && *{_getglob("${into}::${cl}")}{CODE};
      $methods{$cl} =
        quote_sub "${into}::${cl}" => 
          $self->_generate_simple_clear('$_[0]', $name, $spec)."\n"
        ;
    }
    if (my $hspec = $spec->{handles}) {
      my $asserter = $spec->{asserter} ||= '_assert_'.$name;
      my @specs = do {
        if (ref($hspec) eq 'ARRAY') {
          map [ $_ => $_ ], @$hspec;
        } elsif (ref($hspec) eq 'HASH') {
          map [ $_ => ref($hspec->{$_}) ? @{$hspec->{$_}} : $hspec->{$_} ],
            keys %$hspec;
        } elsif (!ref($hspec)) {
          map [ $_ => $_ ], use_module('Role::Tiny')->methods_provided_by(use_module($hspec))
        } else {
          die "You gave me a handles of ${hspec} and I have no idea why";
        }
      };
      foreach my $delegation_spec (@specs) {
        my ($proxy, $target, @args) = @$delegation_spec;
        _die_overwrite($into, $proxy, 'a delegation')
          if !$spec->{allow_overwrite} && *{_getglob("${into}::${proxy}")}{CODE};
        $self->{captures} = {};
        $methods{$proxy} =
          quote_sub "${into}::${proxy}" =>
            $self->_generate_delegation($asserter, $target, \@args),
            delete $self->{captures}
          ;
      }
    }
    if (my $asserter = $spec->{asserter}) {
      $self->{captures} = {};
  
  
      $methods{$asserter} =
        quote_sub "${into}::${asserter}" => $self->_generate_asserter($name, $spec),
          delete $self->{captures}
        ;
    }
    \%methods;
  }
  
  sub is_simple_attribute {
    my ($self, $name, $spec) = @_;
    # clearer doesn't have to be listed because it doesn't
    # affect whether defined/exists makes a difference
    !grep $spec->{$_},
      qw(lazy default builder coerce isa trigger predicate weak_ref);
  }
  
  sub is_simple_get {
    my ($self, $name, $spec) = @_;
    !($spec->{lazy} and ($spec->{default} or $spec->{builder}));
  }
  
  sub is_simple_set {
    my ($self, $name, $spec) = @_;
    !grep $spec->{$_}, qw(coerce isa trigger weak_ref);
  }
  
  sub has_eager_default {
    my ($self, $name, $spec) = @_;
    (!$spec->{lazy} and (exists $spec->{default} or $spec->{builder}));
  }
  
  sub _generate_get {
    my ($self, $name, $spec) = @_;
    my $simple = $self->_generate_simple_get('$_[0]', $name, $spec);
    if ($self->is_simple_get($name, $spec)) {
      $simple;
    } else {
      $self->_generate_use_default(
        '$_[0]', $name, $spec,
        $self->_generate_simple_has('$_[0]', $name, $spec),
      );
    }
  }
  
  sub generate_simple_has {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_simple_has(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_simple_has {
    my ($self, $me, $name) = @_;
    "exists ${me}->{${\perlstring $name}}";
  }
  
  sub _generate_simple_clear {
    my ($self, $me, $name) = @_;
    "    delete ${me}->{${\perlstring $name}}\n"
  }
  
  sub generate_get_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_get_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub generate_use_default {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_use_default(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_use_default {
    my ($self, $me, $name, $spec, $test) = @_;
    my $get_value = $self->_generate_get_default($me, $name, $spec);
    if ($spec->{coerce}) {
      $get_value = $self->_generate_coerce(
        $name, $get_value,
        $spec->{coerce}
      )
    }
    $test." ? \n"
    .$self->_generate_simple_get($me, $name, $spec)."\n:"
    .($spec->{isa}
      ? "    do {\n      my \$value = ".$get_value.";\n"
        ."      ".$self->_generate_isa_check($name, '$value', $spec->{isa}).";\n"
        ."      ".$self->_generate_simple_set($me, $name, $spec, '$value')."\n"
        ."    }\n"
      : '    ('.$self->_generate_simple_set($me, $name, $spec, $get_value).")\n");
  }
  
  sub _generate_get_default {
    my ($self, $me, $name, $spec) = @_;
    if (exists $spec->{default}) {
      ref $spec->{default}
        ? $self->_generate_call_code($name, 'default', $me, $spec->{default})
        : perlstring $spec->{default};
    }
    else {
      "${me}->${\$spec->{builder}}"
    }
  }
  
  sub generate_simple_get {
    my ($self, @args) = @_;
    $self->_generate_simple_get(@args);
  }
  
  sub _generate_simple_get {
    my ($self, $me, $name) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}}";
  }
  
  sub _generate_set {
    my ($self, $name, $spec) = @_;
    if ($self->is_simple_set($name, $spec)) {
      $self->_generate_simple_set('$_[0]', $name, $spec, '$_[1]');
    } else {
      my ($coerce, $trigger, $isa_check) = @{$spec}{qw(coerce trigger isa)};
      my $value_store = '$_[0]';
      my $code;
      if ($coerce) {
        $value_store = '$value';
        $code = "do { my (\$self, \$value) = \@_;\n"
          ."        \$value = "
          .$self->_generate_coerce($name, $value_store, $coerce).";\n";
      }
      else {
        $code = "do { my \$self = shift;\n";
      }
      if ($isa_check) {
        $code .= 
          "        ".$self->_generate_isa_check($name, $value_store, $isa_check).";\n";
      }
      my $simple = $self->_generate_simple_set('$self', $name, $spec, $value_store);
      if ($trigger) {
        my $fire = $self->_generate_trigger($name, '$self', $value_store, $trigger);
        $code .=
          "        ".$simple.";\n        ".$fire.";\n"
          ."        $value_store;\n";
      } else {
        $code .= "        ".$simple.";\n";
      }
      $code .= "      }";
      $code;
    }
  }
  
  sub generate_coerce {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_coerce(@_);
    ($code, delete $self->{captures});
  }
  
  sub _attr_desc {
    my ($name, $init_arg) = @_;
    return perlstring($name) if !defined($init_arg) or $init_arg eq $name;
    return perlstring($name).' (constructor argument: '.perlstring($init_arg).')';
  }
  
  sub _generate_coerce {
    my ($self, $name, $value, $coerce, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "coercion",
      $init_arg,
      $self->_generate_call_code($name, 'coerce', "${value}", $coerce)
    );
  }
   
  sub generate_trigger {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_trigger(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_trigger {
    my ($self, $name, $obj, $value, $trigger) = @_;
    $self->_generate_call_code($name, 'trigger', "${obj}, ${value}", $trigger);
  }
  
  sub generate_isa_check {
    my ($self, @args) = @_;
    $self->{captures} = {};
    my $code = $self->_generate_isa_check(@args);
    ($code, delete $self->{captures});
  }
  
  sub _generate_die_prefix {
    my ($self, $name, $prefix, $arg, $inside) = @_;
    "do {\n"
    .'  local $Method::Generate::Accessor::CurrentAttribute = {'
    .'    init_arg => '.(defined $arg ? B::perlstring($arg) : 'undef') . ",\n"
    .'    name     => '.B::perlstring($name).",\n"
    .'    step     => '.B::perlstring($prefix).",\n"
    ."  };\n"
    .'  local $Method::Generate::Accessor::OrigSigDie = $SIG{__DIE__};'."\n"
    .'  local $SIG{__DIE__} = \&Method::Generate::Accessor::_SIGDIE;'."\n"
    .$inside
    ."}\n"
  }
  
  sub _generate_isa_check {
    my ($self, $name, $value, $check, $init_arg) = @_;
    $self->_generate_die_prefix(
      $name,
      "isa check",
      $init_arg,
      $self->_generate_call_code($name, 'isa_check', $value, $check)
    );
  }
  
  sub _generate_call_code {
    my ($self, $name, $type, $values, $sub) = @_;
    $sub = \&{$sub} if blessed($sub);  # coderef if blessed
    if (my $quoted = quoted_from_sub($sub)) {
      my $local = 1;
      if ($values eq '@_' || $values eq '$_[0]') {
        $local = 0;
        $values = '@_';
      }
      my $code = $quoted->[1];
      if (my $captures = $quoted->[2]) {
        my $cap_name = qq{\$${type}_captures_for_${name}};
        $self->{captures}->{$cap_name} = \$captures;
        Sub::Quote::inlinify(
          $code, $values, Sub::Quote::capture_unroll($cap_name, $captures, 6), $local
        );
      } else {
        Sub::Quote::inlinify($code, $values, undef, $local);
      }
    } else {
      my $cap_name = qq{\$${type}_for_${name}};
      $self->{captures}->{$cap_name} = \$sub;
      "${cap_name}->(${values})";
    }
  }
  
  sub generate_populate_set {
    my $self = shift;
    $self->{captures} = {};
    my $code = $self->_generate_populate_set(@_);
    ($code, delete $self->{captures});
  }
  
  sub _generate_populate_set {
    my ($self, $me, $name, $spec, $source, $test, $init_arg) = @_;
    if ($self->has_eager_default($name, $spec)) {
      my $get_indent = ' ' x ($spec->{isa} ? 6 : 4);
      my $get_default = $self->_generate_get_default(
                          '$new', $name, $spec
                        );
      my $get_value = 
        defined($spec->{init_arg})
          ? "(\n${get_indent}  ${test}\n${get_indent}   ? ${source}\n${get_indent}   : "
              .$get_default
              ."\n${get_indent})"
          : $get_default;
      if ($spec->{coerce}) {
        $get_value = $self->_generate_coerce(
          $name, $get_value,
          $spec->{coerce}, $init_arg
        )
      }
      ($spec->{isa}
        ? "    {\n      my \$value = ".$get_value.";\n      "
          .$self->_generate_isa_check(
            $name, '$value', $spec->{isa}, $init_arg
          ).";\n"
          .'      '.$self->_generate_simple_set($me, $name, $spec, '$value').";\n"
          ."    }\n"
        : '    '.$self->_generate_simple_set($me, $name, $spec, $get_value).";\n"
      )
      .($spec->{trigger}
        ? '    '
          .$self->_generate_trigger(
            $name, $me, $self->_generate_simple_get($me, $name, $spec),
            $spec->{trigger}
          )." if ${test};\n"
        : ''
      );
    } else {
      "    if (${test}) {\n"
        .($spec->{coerce}
          ? "      $source = "
            .$self->_generate_coerce(
              $name, $source,
              $spec->{coerce}, $init_arg
            ).";\n"
          : ""
        )
        .($spec->{isa}
          ? "      "
            .$self->_generate_isa_check(
              $name, $source, $spec->{isa}, $init_arg
            ).";\n"
          : ""
        )
        ."      ".$self->_generate_simple_set($me, $name, $spec, $source).";\n"
        .($spec->{trigger}
          ? "      "
            .$self->_generate_trigger(
              $name, $me, $self->_generate_simple_get($me, $name, $spec),
              $spec->{trigger}
            ).";\n"
          : ""
        )
        ."    }\n";
    }
  }
  
  sub _generate_core_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    "${me}->{${name_str}} = ${value}";
  }
  
  sub _generate_simple_set {
    my ($self, $me, $name, $spec, $value) = @_;
    my $name_str = perlstring $name;
    my $simple = $self->_generate_core_set($me, $name, $spec, $value);
  
    if ($spec->{weak_ref}) {
      require Scalar::Util;
      my $get = $self->_generate_simple_get($me, $name, $spec);
  
      # Perl < 5.8.3 can't weaken refs to readonly vars
      # (e.g. string constants). This *can* be solved by:
      #
      #Internals::SetReadWrite($foo);
      #Scalar::Util::weaken ($foo);
      #Internals::SetReadOnly($foo);
      #
      # but requires XS and is just too damn crazy
      # so simply throw a better exception
      my $weak_simple = "do { Scalar::Util::weaken(${simple}); no warnings 'void'; $get }";
      Moo::_Utils::lt_5_8_3() ? <<"EOC" : $weak_simple;
        eval { Scalar::Util::weaken($simple); 1 }
          ? do { no warnings 'void'; $get }
          : do {
            if( \$@ =~ /Modification of a read-only value attempted/) {
              require Carp;
              Carp::croak( sprintf (
                'Reference to readonly value in "%s" can not be weakened on Perl < 5.8.3',
                $name_str,
              ) );
            } else {
              die \$@;
            }
          }
  EOC
    } else {
      $simple;
    }
  }
  
  sub _generate_getset {
    my ($self, $name, $spec) = @_;
    q{(@_ > 1}."\n      ? ".$self->_generate_set($name, $spec)
      ."\n      : ".$self->_generate_get($name, $spec)."\n    )";
  }
  
  sub _generate_asserter {
    my ($self, $name, $spec) = @_;
  
    "do {\n"
     ."  my \$val = ".$self->_generate_get($name, $spec).";\n"
     ."  unless (".$self->_generate_simple_has('$_[0]', $name, $spec).") {\n"
     .qq!    die "Attempted to access '${name}' but it is not set";\n!
     ."  }\n"
     ."  \$val;\n"
     ."}\n";
  }
  sub _generate_delegation {
    my ($self, $asserter, $target, $args) = @_;
    my $arg_string = do {
      if (@$args) {
        # I could, I reckon, linearise out non-refs here using perlstring
        # plus something to check for numbers but I'm unsure if it's worth it
        $self->{captures}{'@curries'} = $args;
        '@curries, @_';
      } else {
        '@_';
      }
    };
    "shift->${asserter}->${target}(${arg_string});";
  }
  
  sub _generate_xs {
    my ($self, $type, $into, $name, $slot) = @_;
    Class::XSAccessor->import(
      class => $into,
      $type => { $name => $slot },
      replace => 1,
    );
    $into->can($name);
  }
  
  sub default_construction_string { '{}' }
  
  sub _validate_codulatable {
    my ($self, $setting, $value, $into, $appended) = @_;
    my $invalid = "Invalid $setting '" . overload::StrVal($value)
      . "' for $into not a coderef";
    $invalid .= " $appended" if $appended;
  
    unless (ref $value and (ref $value eq 'CODE' or blessed($value))) {
      die "$invalid or code-convertible object";
    }
  
    unless (eval { \&$value }) {
      die "$invalid and could not be converted to a coderef: $@";
    }
  
    1;
  }
  
  1;
METHOD_GENERATE_ACCESSOR

$fatpacked{"Method/Generate/BuildAll.pm"} = <<'METHOD_GENERATE_BUILDALL';
  package Method::Generate::BuildAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B 'perlstring';
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::BUILDALL", join '',
      $self->_handle_subbuild($into),
      qq{    my \$self = shift;\n},
      $self->buildall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
  }
  
  sub _handle_subbuild {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::BUILDALL(@_)'.";\n".
    '    }'."\n";
  }
  
  sub buildall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @builds =
      grep *{_getglob($_)}{CODE},
      map "${_}::BUILD",
      reverse @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @builds;
  }
  
  1;
METHOD_GENERATE_BUILDALL

$fatpacked{"Method/Generate/Constructor.pm"} = <<'METHOD_GENERATE_CONSTRUCTOR';
  package Method::Generate::Constructor;
  
  use strictures 1;
  use Sub::Quote;
  use base qw(Moo::Object);
  use Sub::Defer;
  use B 'perlstring';
  use Moo::_Utils qw(_getstash);
  
  sub register_attribute_specs {
    my ($self, @new_specs) = @_;
    my $specs = $self->{attribute_specs}||={};
    while (my ($name, $new_spec) = splice @new_specs, 0, 2) {
      if ($name =~ s/^\+//) {
        die "has '+${name}' given but no ${name} attribute already exists"
          unless my $old_spec = $specs->{$name};
        foreach my $key (keys %$old_spec) {
          if (!exists $new_spec->{$key}) {
            $new_spec->{$key} = $old_spec->{$key}
              unless $key eq 'handles';
          }
          elsif ($key eq 'moosify') {
            $new_spec->{$key} = [
              map { ref $_ eq 'ARRAY' ? @$_ : $_ }
                ($old_spec->{$key}, $new_spec->{$key})
            ];
          }
        }
      }
      $new_spec->{index} = scalar keys %$specs
        unless defined $new_spec->{index};
      $specs->{$name} = $new_spec;
    }
    $self;
  }
  
  sub all_attribute_specs {
    $_[0]->{attribute_specs}
  }
  
  sub accessor_generator {
    $_[0]->{accessor_generator}
  }
  
  sub construction_string {
    my ($self) = @_;
    $self->{construction_string}
      ||= $self->_build_construction_string;
  }
  
  sub _build_construction_string {
    'bless('
      .$_[0]->accessor_generator->default_construction_string
      .', $class);'
  }
  
  sub install_delayed {
    my ($self) = @_;
    my $package = $self->{package};
    defer_sub "${package}::new" => sub {
      unquote_sub $self->generate_method(
        $package, 'new', $self->{attribute_specs}, { no_install => 1 }
      )
    };
    $self;
  }
  
  sub generate_method {
    my ($self, $into, $name, $spec, $quote_opts) = @_;
    foreach my $no_init (grep !exists($spec->{$_}{init_arg}), keys %$spec) {
      $spec->{$no_init}{init_arg} = $no_init;
    }
    local $self->{captures} = {};
    my $body = '    my $class = shift;'."\n"
              .'    $class = ref($class) if ref($class);'."\n";
    $body .= $self->_handle_subconstructor($into, $name);
    my $into_buildargs = $into->can('BUILDARGS');
    if ( $into_buildargs && $into_buildargs != \&Moo::Object::BUILDARGS ) {
        $body .= $self->_generate_args_via_buildargs;
    } else {
        $body .= $self->_generate_args;
    }
    $body .= $self->_check_required($spec);
    $body .= '    my $new = '.$self->construction_string.";\n";
    $body .= $self->_assign_new($spec);
    if ($into->can('BUILD')) {
      require Method::Generate::BuildAll;
      $body .= Method::Generate::BuildAll->new->buildall_body_for(
        $into, '$new', '$args'
      );
    }
    $body .= '    return $new;'."\n";
    if ($into->can('DEMOLISH')) {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new->generate_method($into);
    }
    quote_sub
      "${into}::${name}" => $body,
      $self->{captures}, $quote_opts||{}
    ;
  }
  
  sub _handle_subconstructor {
    my ($self, $into, $name) = @_;
    if (my $gen = $self->{subconstructor_handler}) {
      '    if ($class ne '.perlstring($into).') {'."\n".
      $gen.
      '    }'."\n";
    } else {
      ''
    }
  }
  
  sub _cap_call {
    my ($self, $code, $captures) = @_;
    @{$self->{captures}}{keys %$captures} = values %$captures if $captures;
    $code;
  }
  
  sub _generate_args_via_buildargs {
    my ($self) = @_;
    q{    my $args = $class->BUILDARGS(@_);}."\n"
    .q{    die "BUILDARGS did not return a hashref" unless ref($args) eq 'HASH';}
    ."\n";
  }
  
  # inlined from Moo::Object - update that first.
  sub _generate_args {
    my ($self) = @_;
    return <<'_EOA';
      my $args;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          $args = { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          $args = {@_};
      }
  _EOA
  
  }
  
  sub _assign_new {
    my ($self, $spec) = @_;
    my $ag = $self->accessor_generator;
    my %test;
    NAME: foreach my $name (sort keys %$spec) {
      my $attr_spec = $spec->{$name};
      next NAME unless defined($attr_spec->{init_arg})
                         or $ag->has_eager_default($name, $attr_spec);
      $test{$name} = $attr_spec->{init_arg};
    }
    join '', map {
      my $arg_key = perlstring($test{$_});
      my $test = "exists \$args->{$arg_key}";
      my $source = "\$args->{$arg_key}";
      my $attr_spec = $spec->{$_};
      $self->_cap_call($ag->generate_populate_set(
        '$new', $_, $attr_spec, $source, $test, $test{$_},
      ));
    } sort keys %test;
  }
  
  sub _check_required {
    my ($self, $spec) = @_;
    my @required_init =
      map $spec->{$_}{init_arg},
        grep {
          my %s = %{$spec->{$_}}; # ignore required if default or builder set
          $s{required} and not($s{builder} or $s{default})
        } sort keys %$spec;
    return '' unless @required_init;
    '    if (my @missing = grep !exists $args->{$_}, qw('
      .join(' ',@required_init).')) {'."\n"
      .q{      die "Missing required arguments: ".join(', ', sort @missing);}."\n"
      ."    }\n";
  }
  
  use Moo;
  Moo->_constructor_maker_for(__PACKAGE__)->register_attribute_specs(
    attribute_specs => {
      is => 'ro',
      reader => 'all_attribute_specs',
    },
    accessor_generator => { is => 'ro' },
    construction_string => { is => 'lazy' },
    subconstructor_handler => { is => 'ro' },
    package => { is => 'ro' },
  );
  
  1;
METHOD_GENERATE_CONSTRUCTOR

$fatpacked{"Method/Generate/DemolishAll.pm"} = <<'METHOD_GENERATE_DEMOLISHALL';
  package Method::Generate::DemolishAll;
  
  use strictures 1;
  use base qw(Moo::Object);
  use Sub::Quote;
  use Moo::_Utils;
  use B qw(perlstring);
  
  sub generate_method {
    my ($self, $into) = @_;
    quote_sub "${into}::DEMOLISHALL", join '',
      $self->_handle_subdemolish($into),
      qq{    my \$self = shift;\n},
      $self->demolishall_body_for($into, '$self', '@_'),
      qq{    return \$self\n};
    quote_sub "${into}::DESTROY", join '',
      q!    my $self = shift;
      my $e = do {
        local $?;
        local $@;
        require Moo::_Utils;
        eval {
          $self->DEMOLISHALL(Moo::_Utils::_in_global_destruction);
        };
        $@;
      };
    
      no warnings 'misc';
      die $e if $e; # rethrow
    !;
  }
  
  sub demolishall_body_for {
    my ($self, $into, $me, $args) = @_;
    my @demolishers =
      grep *{_getglob($_)}{CODE},
      map "${_}::DEMOLISH",
      @{Moo::_Utils::_get_linear_isa($into)};
    join '', map qq{    ${me}->${_}(${args});\n}, @demolishers;
  }
  
  sub _handle_subdemolish {
    my ($self, $into) = @_;
    '    if (ref($_[0]) ne '.perlstring($into).') {'."\n".
    '      return shift->Moo::Object::DEMOLISHALL(@_)'.";\n".
    '    }'."\n";
  }
  
  1;
METHOD_GENERATE_DEMOLISHALL

$fatpacked{"Method/Inliner.pm"} = <<'METHOD_INLINER';
  package Method::Inliner;
  
  use strictures 1;
  use Text::Balanced qw(extract_bracketed);
  use Sub::Quote ();
  
  sub slurp { do { local (@ARGV, $/) = $_[0]; <> } }
  sub splat {
    open my $out, '>', $_[1] or die "can't open $_[1]: $!";
    print $out $_[0] or die "couldn't write to $_[1]: $!";
  }
  
  sub inlinify {
    my $file = $_[0];
    my @chunks = split /(^sub.*?^}$)/sm, slurp $file;
    warn join "\n--\n", @chunks;
    my %code;
    foreach my $chunk (@chunks) {
      if (my ($name, $body) =
        $chunk =~ /^sub (\S+) {\n(.*)\n}$/s
      ) {
        $code{$name} = $body;
      }
    }
    foreach my $chunk (@chunks) {
      my ($me) = $chunk =~ /^sub.*{\n  my \((\$\w+).*\) = \@_;\n/ or next;
      my $meq = quotemeta $me;
      #warn $meq, $chunk;
      my $copy = $chunk;
      my ($fixed, $rest);
      while ($copy =~ s/^(.*?)${meq}->(\S+)(?=\()//s) {
        my ($front, $name) = ($1, $2);
        ((my $body), $rest) = extract_bracketed($copy, '()');
        warn "spotted ${name} - ${body}";
        if ($code{$name}) {
        warn "replacing";
          s/^\(//, s/\)$// for $body;
          $body = "${me}, ".$body;
          $fixed .= $front.Sub::Quote::inlinify($code{$name}, $body);
        } else {
  	$fixed .= $front.$me.'->'.$name.$body;
        }
        #warn $fixed; warn $rest;
        $copy = $rest;
      }
      $fixed .= $rest if $fixed;
      warn $fixed if $fixed;
      $chunk = $fixed if $fixed;
    }
    print join '', @chunks;
  }
  
  1;
METHOD_INLINER

$fatpacked{"Module/Implementation.pm"} = <<'MODULE_IMPLEMENTATION';
  package Module::Implementation;
  {
    $Module::Implementation::VERSION = '0.06';
  }
  
  use strict;
  use warnings;
  
  use Module::Runtime 0.012 qw( require_module );
  use Try::Tiny;
  
  my %Implementation;
  
  sub build_loader_sub {
      my $caller = caller();
  
      return _build_loader( $caller, @_ );
  }
  
  sub _build_loader {
      my $package = shift;
      my %args    = @_;
  
      my @implementations = @{ $args{implementations} };
      my @symbols = @{ $args{symbols} || [] };
  
      my $implementation;
      my $env_var = uc $package;
      $env_var =~ s/::/_/g;
      $env_var .= '_IMPLEMENTATION';
  
      return sub {
          my ( $implementation, $loaded ) = _load_implementation(
              $package,
              $ENV{$env_var},
              \@implementations,
          );
  
          $Implementation{$package} = $implementation;
  
          _copy_symbols( $loaded, $package, \@symbols );
  
          return $loaded;
      };
  }
  
  sub implementation_for {
      my $package = shift;
  
      return $Implementation{$package};
  }
  
  sub _load_implementation {
      my $package         = shift;
      my $env_value       = shift;
      my $implementations = shift;
  
      if ($env_value) {
          die "$env_value is not a valid implementation for $package"
              unless grep { $_ eq $env_value } @{$implementations};
  
          my $loaded = "${package}::$env_value";
  
          # Values from the %ENV hash are tainted. We know it's safe to untaint
          # this value because the value was one of our known implementations.
          ($loaded) = $loaded =~ /^(.+)$/;
  
          try {
              require_module($loaded);
          }
          catch {
              require Carp;
              Carp::croak("Could not load $loaded: $_");
          };
  
          return ( $env_value, $loaded );
      }
      else {
          my $err;
          for my $possible ( @{$implementations} ) {
              my $load = "${package}::$possible";
  
              my $ok;
              try {
                  require_module($load);
                  $ok = 1;
              }
              catch {
                  $err .= $_;
              };
  
              return ( $possible, $load ) if $ok;
          }
  
          require Carp;
          Carp::croak(
              "Could not find a suitable $package implementation: $err");
      }
  }
  
  sub _copy_symbols {
      my $from_package = shift;
      my $to_package   = shift;
      my $symbols      = shift;
  
      for my $sym ( @{$symbols} ) {
          my $type = $sym =~ s/^([\$\@\%\&\*])// ? $1 : '&';
  
          my $from = "${from_package}::$sym";
          my $to   = "${to_package}::$sym";
  
          {
              no strict 'refs';
              no warnings 'once';
  
              # Copied from Exporter
              *{$to}
                  = $type eq '&' ? \&{$from}
                  : $type eq '$' ? \${$from}
                  : $type eq '@' ? \@{$from}
                  : $type eq '%' ? \%{$from}
                  : $type eq '*' ? *{$from}
                  : die
                  "Can't copy symbol from $from_package to $to_package: $type$sym";
          }
      }
  }
  
  1;
  
  # ABSTRACT: Loads one of several alternate underlying implementations for a module
  
  
  
  =pod
  
  =head1 NAME
  
  Module::Implementation - Loads one of several alternate underlying implementations for a module
  
  =head1 VERSION
  
  version 0.06
  
  =head1 SYNOPSIS
  
    package Foo::Bar;
  
    use Module::Implementation;
  
    BEGIN {
        my $loader = Module::Implementation::build_loader_sub(
            implementations => [ 'XS',  'PurePerl' ],
            symbols         => [ 'run', 'check' ],
        );
  
        $loader->();
    }
  
    package Consumer;
  
    # loads the first viable implementation
    use Foo::Bar;
  
  =head1 DESCRIPTION
  
  This module abstracts out the process of choosing one of several underlying
  implementations for a module. This can be used to provide XS and pure Perl
  implementations of a module, or it could be used to load an implementation for
  a given OS or any other case of needing to provide multiple implementations.
  
  This module is only useful when you know all the implementations ahead of
  time. If you want to load arbitrary implementations then you probably want
  something like a plugin system, not this module.
  
  =head1 API
  
  This module provides two subroutines, neither of which are exported.
  
  =head2 Module::Implementation::<build_loader_sub(...)
  
  This subroutine takes the following arguments.
  
  =over 4
  
  =item * implementations
  
  This should be an array reference of implementation names. Each name should
  correspond to a module in the caller's namespace.
  
  In other words, using the example in the L</SYNOPSIS>, this module will look
  for the C<Foo::Bar::XS> and C<Foo::Bar::PurePerl> modules will be installed
  
  This argument is required.
  
  =item * symbols
  
  A list of symbols to copy from the implementation package to the calling
  package.
  
  These can be prefixed with a variable type: C<$>, C<@>, C<%>, C<&>, or
  C<*)>. If no prefix is given, the symbol is assumed to be a subroutine.
  
  This argument is optional.
  
  =back
  
  This subroutine I<returns> the implementation loader as a sub reference.
  
  It is up to you to call this loader sub in your code.
  
  I recommend that you I<do not> call this loader in an C<import()> sub. If a
  caller explicitly requests no imports, your C<import()> sub will not be run at
  all, which can cause weird breakage.
  
  =head2 Module::Implementation::implementation_for($package)
  
  Given a package name, this subroutine returns the implementation that was
  loaded for the package. This is not a full package name, just the suffix that
  identifies the implementation. For the L</SYNOPSIS> example, this subroutine
  would be called as C<Module::Implementation::implementation_for('Foo::Bar')>,
  and it would return "XS" or "PurePerl".
  
  =head1 HOW THE IMPLEMENTATION LOADER WORKS
  
  The implementation loader works like this ...
  
  First, it checks for an C<%ENV> var specifying the implementation to load. The
  env var is based on the package name which loads the implementations. The
  C<::> package separator is replaced with C<_>, and made entirely
  upper-case. Finally, we append "_IMPLEMENTATION" to this name.
  
  So in our L</SYNOPSIS> example, the corresponding C<%ENV> key would be
  C<FOO_BAR_IMPLEMENTATION>.
  
  If this is set, then the loader will B<only> try to load this one
  implementation.
  
  If the env var requests an implementation which doesn't match one of the
  implementations specified when the loader was created, an error is thrown.
  
  If this one implementation fails to load then loader throws an error. This is
  useful for testing. You can request a specific implementation in a test file
  by writing something like this:
  
    BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = 'XS' }
    use Foo::Bar;
  
  If the environment variable is I<not> set, then the loader simply tries the
  implementations originally passed to C<Module::Implementation>. The
  implementations are tried in the order in which they were originally passed.
  
  The loader will use the first implementation that loads without an error. It
  will copy any requested symbols from this implementation.
  
  If none of the implementations can be loaded, then the loader throws an
  exception.
  
  The loader returns the name of the package it loaded.
  
  =head1 AUTHOR
  
  Dave Rolsky <autarch@urth.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2012 by Dave Rolsky.
  
  This is free software, licensed under:
  
    The Artistic License 2.0 (GPL Compatible)
  
  =cut
  
  
  __END__
  
MODULE_IMPLEMENTATION

$fatpacked{"Module/Runtime.pm"} = <<'MODULE_RUNTIME';
  =head1 NAME
  
  Module::Runtime - runtime module handling
  
  =head1 SYNOPSIS
  
  	use Module::Runtime qw(
  		$module_name_rx is_module_name check_module_name
  		module_notional_filename require_module
  	);
  
  	if($module_name =~ /\A$module_name_rx\z/o) { ...
  	if(is_module_name($module_name)) { ...
  	check_module_name($module_name);
  
  	$notional_filename = module_notional_filename($module_name);
  	require_module($module_name);
  
  	use Module::Runtime qw(use_module use_package_optimistically);
  
  	$bi = use_module("Math::BigInt", 1.31)->new("1_234");
  	$widget = use_package_optimistically("Local::Widget")->new;
  
  	use Module::Runtime qw(
  		$top_module_spec_rx $sub_module_spec_rx
  		is_module_spec check_module_spec
  		compose_module_name
  	);
  
  	if($spec =~ /\A$top_module_spec_rx\z/o) { ...
  	if($spec =~ /\A$sub_module_spec_rx\z/o) { ...
  	if(is_module_spec("Standard::Prefix", $spec)) { ...
  	check_module_spec("Standard::Prefix", $spec);
  
  	$module_name =
  		compose_module_name("Standard::Prefix", $spec);
  
  =head1 DESCRIPTION
  
  The functions exported by this module deal with runtime handling of
  Perl modules, which are normally handled at compile time.  This module
  avoids using any other modules, so that it can be used in low-level
  infrastructure.
  
  The parts of this module that work with module names apply the same
  syntax that is used for barewords in Perl source.  In principle this
  syntax can vary between versions of Perl, and this module applies the
  syntax of the Perl on which it is running.  In practice the usable syntax
  hasn't changed yet, but there's a good chance of it changing in Perl 5.18.
  
  The functions of this module whose purpose is to load modules include
  workarounds for three old Perl core bugs regarding C<require>.  These
  workarounds are applied on any Perl version where the bugs exist, except
  for a case where one of the bugs cannot be adequately worked around in
  pure Perl.
  
  =head2 Module name syntax
  
  The usable module name syntax has not changed from Perl 5.000 up to
  Perl 5.15.7.  The syntax is composed entirely of ASCII characters.
  From Perl 5.6 onwards there has been some attempt to allow the use of
  non-ASCII Unicode characters in Perl source, but it was fundamentally
  broken (like the entirety of Perl 5.6's Unicode handling) and remained
  pretty much entirely unusable until it got some attention in the Perl
  5.15 series.  Although Unicode is now consistently accepted by the
  parser in some places, it remains broken for module names.  Furthermore,
  there has not yet been any work on how to map Unicode module names into
  filenames, so in that respect also Unicode module names are unusable.
  This may finally be addressed in the Perl 5.17 series.
  
  The module name syntax is, precisely: the string must consist of one or
  more segments separated by C<::>; each segment must consist of one or more
  identifier characters (ASCII alphanumerics plus "_"); the first character
  of the string must not be a digit.  Thus "C<IO::File>", "C<warnings>",
  and "C<foo::123::x_0>" are all valid module names, whereas "C<IO::>"
  and "C<1foo::bar>" are not.  C<'> separators are not permitted by this
  module, though they remain usable in Perl source, being translated to
  C<::> in the parser.
  
  =head2 Core bugs worked around
  
  The first bug worked around is core bug [perl #68590], which causes
  lexical state in one file to leak into another that is C<require>d/C<use>d
  from it.  This bug is present from Perl 5.6 up to Perl 5.10, and is
  fixed in Perl 5.11.0.  From Perl 5.9.4 up to Perl 5.10.0 no satisfactory
  workaround is possible in pure Perl.  The workaround means that modules
  loaded via this module don't suffer this pollution of their lexical
  state.  Modules loaded in other ways, or via this module on the Perl
  versions where the pure Perl workaround is impossible, remain vulnerable.
  The module L<Lexical::SealRequireHints> provides a complete workaround
  for this bug.
  
  The second bug worked around causes some kinds of failure in module
  loading, principally compilation errors in the loaded module, to be
  recorded in C<%INC> as if they were successful, so later attempts to load
  the same module immediately indicate success.  This bug is present up
  to Perl 5.8.9, and is fixed in Perl 5.9.0.  The workaround means that a
  compilation error in a module loaded via this module won't be cached as
  a success.  Modules loaded in other ways remain liable to produce bogus
  C<%INC> entries, and if a bogus entry exists then it will mislead this
  module if it is used to re-attempt loading.
  
  The third bug worked around causes the wrong context to be seen at
  file scope of a loaded module, if C<require> is invoked in a location
  that inherits context from a higher scope.  This bug is present up to
  Perl 5.11.2, and is fixed in Perl 5.11.3.  The workaround means that
  a module loaded via this module will always see the correct context.
  Modules loaded in other ways remain vulnerable.
  
  =cut
  
  package Module::Runtime;
  
  # Don't "use 5.006" here, because Perl 5.15.6 will load feature.pm if
  # the version check is done that way.
  BEGIN { require 5.006; }
  # Don't "use warnings" here, to avoid dependencies.  Do standardise the
  # warning status by lexical override; unfortunately the only safe bitset
  # to build in is the empty set, equivalent to "no warnings".
  BEGIN { ${^WARNING_BITS} = ""; }
  # Don't "use strict" here, to avoid dependencies.
  
  our $VERSION = "0.013";
  
  # Don't use Exporter here, to avoid dependencies.
  our @EXPORT_OK = qw(
  	$module_name_rx is_module_name is_valid_module_name check_module_name
  	module_notional_filename require_module
  	use_module use_package_optimistically
  	$top_module_spec_rx $sub_module_spec_rx
  	is_module_spec is_valid_module_spec check_module_spec
  	compose_module_name
  );
  my %export_ok = map { ($_ => undef) } @EXPORT_OK;
  sub import {
  	my $me = shift;
  	my $callpkg = caller(0);
  	my $errs = "";
  	foreach(@_) {
  		if(exists $export_ok{$_}) {
  			# We would need to do "no strict 'refs'" here
  			# if we had enabled strict at file scope.
  			if(/\A\$(.*)\z/s) {
  				*{$callpkg."::".$1} = \$$1;
  			} else {
  				*{$callpkg."::".$_} = \&$_;
  			}
  		} else {
  			$errs .= "\"$_\" is not exported by the $me module\n";
  		}
  	}
  	if($errs ne "") {
  		die "${errs}Can't continue after import errors ".
  			"at @{[(caller(0))[1]]} line @{[(caller(0))[2]]}.\n";
  	}
  }
  
  # Logic duplicated from Params::Classify.  Duplicating it here avoids
  # an extensive and potentially circular dependency graph.
  sub _is_string($) {
  	my($arg) = @_;
  	return defined($arg) && ref(\$arg) eq "SCALAR";
  }
  
  =head1 REGULAR EXPRESSIONS
  
  These regular expressions do not include any anchors, so to check
  whether an entire string matches a syntax item you must supply the
  anchors yourself.
  
  =over
  
  =item $module_name_rx
  
  Matches a valid Perl module name in bareword syntax.
  
  =cut
  
  our $module_name_rx = qr/[A-Z_a-z][0-9A-Z_a-z]*(?:::[0-9A-Z_a-z]+)*/;
  
  =item $top_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where no prefix is being used.
  
  =cut
  
  my $qual_module_spec_rx =
  	qr#(?:/|::)[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  my $unqual_top_module_spec_rx =
  	qr#[A-Z_a-z][0-9A-Z_a-z]*(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $top_module_spec_rx = qr/$qual_module_spec_rx|$unqual_top_module_spec_rx/o;
  
  =item $sub_module_spec_rx
  
  Matches a module specification for use with L</compose_module_name>,
  where a prefix is being used.
  
  =cut
  
  my $unqual_sub_module_spec_rx = qr#[0-9A-Z_a-z]+(?:(?:/|::)[0-9A-Z_a-z]+)*#;
  
  our $sub_module_spec_rx = qr/$qual_module_spec_rx|$unqual_sub_module_spec_rx/o;
  
  =back
  
  =head1 FUNCTIONS
  
  =head2 Basic module handling
  
  =over
  
  =item is_module_name(ARG)
  
  Returns a truth value indicating whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  
  =cut
  
  sub is_module_name($) { _is_string($_[0]) && $_[0] =~ /\A$module_name_rx\z/o }
  
  =item is_valid_module_name(ARG)
  
  Deprecated alias for L</is_module_name>.
  
  =cut
  
  *is_valid_module_name = \&is_module_name;
  
  =item check_module_name(ARG)
  
  Check whether I<ARG> is a plain string
  satisfying Perl module name syntax as described for L</$module_name_rx>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_name($) {
  	unless(&is_module_name) {
  		die +(_is_string($_[0]) ? "`$_[0]'" : "argument").
  			" is not a module name\n";
  	}
  }
  
  =item module_notional_filename(NAME)
  
  Generates a notional relative filename for a module, which is used in
  some Perl core interfaces.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The notional filename for the named module is generated and returned.
  This filename is always in Unix style, with C</> directory separators
  and a C<.pm> suffix.  This kind of filename can be used as an argument to
  C<require>, and is the key that appears in C<%INC> to identify a module,
  regardless of actual local filename syntax.
  
  =cut
  
  sub module_notional_filename($) {
  	&check_module_name;
  	my($name) = @_;
  	$name =~ s!::!/!g;
  	return $name.".pm";
  }
  
  =item require_module(NAME)
  
  This is essentially the bareword form of C<require>, in runtime form.
  The I<NAME> is a string, which should be a valid module name (one or
  more C<::>-separated segments).  If it is not a valid name, the function
  C<die>s.
  
  The module specified by I<NAME> is loaded, if it hasn't been already,
  in the manner of the bareword form of C<require>.  That means that a
  search through C<@INC> is performed, and a byte-compiled form of the
  module will be used if available.
  
  The return value is as for C<require>.  That is, it is the value returned
  by the module itself if the module is loaded anew, or C<1> if the module
  was already loaded.
  
  =cut
  
  # Don't "use constant" here, to avoid dependencies.
  BEGIN {
  	*_WORK_AROUND_HINT_LEAKAGE =
  		"$]" < 5.011 && !("$]" >= 5.009004 && "$]" < 5.010001)
  			? sub(){1} : sub(){0};
  	*_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
  }
  
  BEGIN { if(_WORK_AROUND_BROKEN_MODULE_STATE) { eval q{
  	sub Module::Runtime::__GUARD__::DESTROY {
  		delete $INC{$_[0]->[0]} if @{$_[0]};
  	}
  	1;
  }; die $@ if $@ ne ""; } }
  
  sub require_module($) {
  	# Localise %^H to work around [perl #68590], where the bug exists
  	# and this is a satisfactory workaround.  The bug consists of
  	# %^H state leaking into each required module, polluting the
  	# module's lexical state.
  	local %^H if _WORK_AROUND_HINT_LEAKAGE;
  	if(_WORK_AROUND_BROKEN_MODULE_STATE) {
  		my $notional_filename = &module_notional_filename;
  		my $guard = bless([ $notional_filename ],
  				"Module::Runtime::__GUARD__");
  		my $result = require($notional_filename);
  		pop @$guard;
  		return $result;
  	} else {
  		return scalar(require(&module_notional_filename));
  	}
  }
  
  =back
  
  =head2 Structured module use
  
  =over
  
  =item use_module(NAME[, VERSION])
  
  This is essentially C<use> in runtime form, but without the importing
  feature (which is fundamentally a compile-time thing).  The I<NAME> is
  handled just like in C<require_module> above: it must be a module name,
  and the named module is loaded as if by the bareword form of C<require>.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded module is
  called with the specified I<VERSION> as an argument.  This normally serves to
  ensure that the version loaded is at least the version required.  This is
  the same functionality provided by the I<VERSION> parameter of C<use>.
  
  On success, the name of the module is returned.  This is unlike
  L</require_module>, and is done so that the entire call to L</use_module>
  can be used as a class name to call a constructor, as in the example in
  the synopsis.
  
  =cut
  
  sub use_module($;$) {
  	my($name, $version) = @_;
  	require_module($name);
  	if(defined $version) {
  		$name->VERSION($version);
  	}
  	return $name;
  }
  
  =item use_package_optimistically(NAME[, VERSION])
  
  This is an analogue of L</use_module> for the situation where there is
  uncertainty as to whether a package/class is defined in its own module
  or by some other means.  It attempts to arrange for the named package to
  be available, either by loading a module or by doing nothing and hoping.
  
  An attempt is made to load the named module (as if by the bareword form
  of C<require>).  If the module cannot be found then it is assumed that
  the package was actually already loaded by other means, and no error
  is signalled.  That's the optimistic bit.
  
  This is mostly the same operation that is performed by the L<base> pragma
  to ensure that the specified base classes are available.  The behaviour
  of L<base> was simplified in version 2.18, and this function changed
  to match.
  
  If a I<VERSION> is specified, the C<VERSION> method of the loaded package is
  called with the specified I<VERSION> as an argument.  This normally serves
  to ensure that the version loaded is at least the version required.
  On success, the name of the package is returned.  These aspects of the
  function work just like L</use_module>.
  
  =cut
  
  sub use_package_optimistically($;$) {
  	my($name, $version) = @_;
  	check_module_name($name);
  	eval { local $SIG{__DIE__}; require_module($name); };
  	die $@ if $@ ne "" &&
  		$@ !~ /\ACan't locate .+ at \Q@{[__FILE__]}\E line/s;
  	$name->VERSION($version) if defined $version;
  	return $name;
  }
  
  =back
  
  =head2 Module name composition
  
  =over
  
  =item is_module_spec(PREFIX, SPEC)
  
  Returns a truth value indicating
  whether I<SPEC> is valid input for L</compose_module_name>.
  See below for what that entails.  Whether a I<PREFIX> is supplied affects
  the validity of I<SPEC>, but the exact value of the prefix is unimportant,
  so this function treats I<PREFIX> as a truth value.
  
  =cut
  
  sub is_module_spec($$) {
  	my($prefix, $spec) = @_;
  	return _is_string($spec) &&
  		$spec =~ ($prefix ? qr/\A$sub_module_spec_rx\z/o :
  				    qr/\A$top_module_spec_rx\z/o);
  }
  
  =item is_valid_module_spec(PREFIX, SPEC)
  
  Deprecated alias for L</is_module_spec>.
  
  =cut
  
  *is_valid_module_spec = \&is_module_spec;
  
  =item check_module_spec(PREFIX, SPEC)
  
  Check whether I<SPEC> is valid input for L</compose_module_name>.
  Return normally if it is, or C<die> if it is not.
  
  =cut
  
  sub check_module_spec($$) {
  	unless(&is_module_spec) {
  		die +(_is_string($_[1]) ? "`$_[1]'" : "argument").
  			" is not a module specification\n";
  	}
  }
  
  =item compose_module_name(PREFIX, SPEC)
  
  This function is intended to make it more convenient for a user to specify
  a Perl module name at runtime.  Users have greater need for abbreviations
  and context-sensitivity than programmers, and Perl module names get a
  little unwieldy.  I<SPEC> is what the user specifies, and this function
  translates it into a module name in standard form, which it returns.
  
  I<SPEC> has syntax approximately that of a standard module name: it
  should consist of one or more name segments, each of which consists
  of one or more identifier characters.  However, C</> is permitted as a
  separator, in addition to the standard C<::>.  The two separators are
  entirely interchangeable.
  
  Additionally, if I<PREFIX> is not C<undef> then it must be a module
  name in standard form, and it is prefixed to the user-specified name.
  The user can inhibit the prefix addition by starting I<SPEC> with a
  separator (either C</> or C<::>).
  
  =cut
  
  sub compose_module_name($$) {
  	my($prefix, $spec) = @_;
  	check_module_name($prefix) if defined $prefix;
  	&check_module_spec;
  	if($spec =~ s#\A(?:/|::)##) {
  		# OK
  	} else {
  		$spec = $prefix."::".$spec if defined $prefix;
  	}
  	$spec =~ s#/#::#g;
  	return $spec;
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<Lexical::SealRequireHints>,
  L<base>,
  L<perlfunc/require>,
  L<perlfunc/use>
  
  =head1 AUTHOR
  
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011, 2012
  Andrew Main (Zefram) <zefram@fysh.org>
  
  =head1 LICENSE
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
MODULE_RUNTIME

$fatpacked{"Moo.pm"} = <<'MOO';
  package Moo;
  
  use strictures 1;
  use Moo::_Utils;
  use B 'perlstring';
  use Sub::Defer ();
  
  our $VERSION = '1.003000'; # 1.3.0
  $VERSION = eval $VERSION;
  
  require Moo::sification;
  
  our %MAKERS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $MAKERS{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my $class = shift;
    strictures->import;
    if ($Role::Tiny::INFO{$target} and $Role::Tiny::INFO{$target}{is_role}) {
      die "Cannot import Moo into a role";
    }
    $MAKERS{$target} ||= {};
    _install_tracked $target => extends => sub {
      $class->_set_superclasses($target, @_);
      $class->_maybe_reset_handlemoose($target);
      return;
    };
    _install_tracked $target => with => sub {
      require Moo::Role;
      Moo::Role->apply_roles_to_package($target, @_);
      $class->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => has => sub {
      my ($name_proto, %spec) = @_;
      my $name_isref = ref $name_proto eq 'ARRAY';
      foreach my $name ($name_isref ? @$name_proto : $name_proto) {
        # Note that when $name_proto is an arrayref, each attribute
        # needs a separate \%specs hashref
        my $spec_ref = $name_isref ? +{%spec} : \%spec;
        $class->_constructor_maker_for($target)
              ->register_attribute_specs($name, $spec_ref);
        $class->_accessor_maker_for($target)
              ->generate_method($target, $name, $spec_ref);
        $class->_maybe_reset_handlemoose($target);
      }
      return;
    };
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        _install_modifier($target, $type, @_);
        return;
      };
    }
    return if $MAKERS{$target}{is_class}; # already exported into this package
    $MAKERS{$target}{is_class} = 1;
    {
      no strict 'refs';
      @{"${target}::ISA"} = do {
        require Moo::Object; ('Moo::Object');
      } unless @{"${target}::ISA"};
    }
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $MAKERS{$target});
  }
  
  sub _set_superclasses {
    my $class = shift;
    my $target = shift;
    foreach my $superclass (@_) {
      _load_module($superclass);
      if ($INC{"Role/Tiny.pm"} && $Role::Tiny::INFO{$superclass}) {
        require Carp;
        Carp::croak("Can't extend role '$superclass'");
      }
    }
    # Can't do *{...} = \@_ or 5.10.0's mro.pm stops seeing @ISA
    @{*{_getglob("${target}::ISA")}{ARRAY}} = @_;
    if (my $old = delete $Moo::MAKERS{$target}{constructor}) {
      delete _getstash($target)->{new};
      Moo->_constructor_maker_for($target)
         ->register_attribute_specs(%{$old->all_attribute_specs});
    }
    elsif (!$target->isa('Moo::Object')) {
      Moo->_constructor_maker_for($target);
    }
    no warnings 'once'; # piss off. -- mst
    $Moo::HandleMoose::MOUSE{$target} = [
      grep defined, map Mouse::Util::find_meta($_), @_
    ] if Mouse::Util->can('find_meta');
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _accessor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{accessor} ||= do {
      my $maker_class = do {
        if (my $m = do {
              if (my $defer_target = 
                    (Sub::Defer::defer_info($target->can('new'))||[])->[0]
                ) {
                my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
                $MAKERS{$pkg} && $MAKERS{$pkg}{accessor};
              } else {
                undef;
              }
            }) {
          ref($m);
        } else {
          require Method::Generate::Accessor;
          'Method::Generate::Accessor'
        }
      };
      $maker_class->new;
    }
  }
  
  sub _constructor_maker_for {
    my ($class, $target) = @_;
    return unless $MAKERS{$target};
    $MAKERS{$target}{constructor} ||= do {
      require Method::Generate::Constructor;
      require Sub::Defer;
      my ($moo_constructor, $con);
  
      my $t_new = $target->can('new');
      if ($t_new) {
        if ($t_new == Moo::Object->can('new')) {
          $moo_constructor = 1;
        } elsif (my $defer_target = (Sub::Defer::defer_info($t_new)||[])->[0]) {
          my ($pkg) = ($defer_target =~ /^(.*)::[^:]+$/);
          if ($MAKERS{$pkg}) {
            $moo_constructor = 1;
            $con = $MAKERS{$pkg}{constructor};
          }
        }
      } else {
        $moo_constructor = 1; # no other constructor, make a Moo one
      }
      ($con ? ref($con) : 'Method::Generate::Constructor')
        ->new(
          package => $target,
          accessor_generator => $class->_accessor_maker_for($target),
          construction_string => (
            $moo_constructor
              ? ($con ? $con->construction_string : undef)
              : ('$class->'.$target.'::SUPER::new($class->can(q[FOREIGNBUILDARGS]) ? $class->FOREIGNBUILDARGS(@_) : @_)')
          ),
          subconstructor_handler => (
            '      if ($Moo::MAKERS{$class}) {'."\n"
            .'        '.$class.'->_constructor_maker_for($class,'.perlstring($target).');'."\n"
            .'        return $class->new(@_)'.";\n"
            .'      } elsif ($INC{"Moose.pm"} and my $meta = Class::MOP::get_metaclass_by_name($class)) {'."\n"
            .'        return $meta->new_object($class->BUILDARGS(@_));'."\n"
            .'      }'."\n"
          ),
        )
        ->install_delayed
        ->register_attribute_specs(%{$con?$con->all_attribute_specs:{}})
    }
  }
  
  1;
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Moo - Minimalist Object Orientation (with Moose compatibility)
  
  =head1 SYNOPSIS
  
   package Cat::Food;
  
   use Moo;
  
   sub feed_lion {
     my $self = shift;
     my $amount = shift || 1;
  
     $self->pounds( $self->pounds - $amount );
   }
  
   has taste => (
     is => 'ro',
   );
  
   has brand => (
     is  => 'ro',
     isa => sub {
       die "Only SWEET-TREATZ supported!" unless $_[0] eq 'SWEET-TREATZ'
     },
   );
  
   has pounds => (
     is  => 'rw',
     isa => sub { die "$_[0] is too much cat food!" unless $_[0] < 15 },
   );
  
   1;
  
  And elsewhere:
  
   my $full = Cat::Food->new(
      taste  => 'DELICIOUS.',
      brand  => 'SWEET-TREATZ',
      pounds => 10,
   );
  
   $full->feed_lion;
  
   say $full->pounds;
  
  =head1 DESCRIPTION
  
  This module is an extremely light-weight subset of L<Moose> optimised for
  rapid startup and "pay only for what you use".
  
  It also avoids depending on any XS modules to allow simple deployments.  The
  name C<Moo> is based on the idea that it provides almost -- but not quite -- two
  thirds of L<Moose>.
  
  Unlike L<Mouse> this module does not aim at full compatibility with
  L<Moose>'s surface syntax, preferring instead of provide full interoperability
  via the metaclass inflation capabilities described in L</MOO AND MOOSE>.
  
  For a full list of the minor differences between L<Moose> and L<Moo>'s surface
  syntax, see L</INCOMPATIBILITIES WITH MOOSE>.
  
  =head1 WHY MOO EXISTS
  
  If you want a full object system with a rich Metaprotocol, L<Moose> is
  already wonderful.
  
  However, sometimes you're writing a command line script or a CGI script
  where fast startup is essential, or code designed to be deployed as a single
  file via L<App::FatPacker>, or you're writing a CPAN module and you want it
  to be usable by people with those constraints.
  
  I've tried several times to use L<Mouse> but it's 3x the size of Moo and
  takes longer to load than most of my Moo based CGI scripts take to run.
  
  If you don't want L<Moose>, you don't want "less metaprotocol" like L<Mouse>,
  you want "as little as possible" -- which means "no metaprotocol", which is
  what Moo provides.
  
  Better still, if you install and load L<Moose>, we set up metaclasses for your
  L<Moo> classes and L<Moo::Role> roles, so you can use them in L<Moose> code
  without ever noticing that some of your codebase is using L<Moo>.
  
  Hence, Moo exists as its name -- Minimal Object Orientation -- with a pledge
  to make it smooth to upgrade to L<Moose> when you need more than minimal
  features.
  
  =head1 MOO AND MOOSE
  
  If L<Moo> detects L<Moose> being loaded, it will automatically register
  metaclasses for your L<Moo> and L<Moo::Role> packages, so you should be able
  to use them in L<Moose> code without anybody ever noticing you aren't using
  L<Moose> everywhere.
  
  L<Moo> will also create L<Moose type constraints|Moose::Manual::Types> for
  classes and roles, so that C<< isa => 'MyClass' >> and C<< isa => 'MyRole' >>
  work the same as for L<Moose> classes and roles.
  
  Extending a L<Moose> class or consuming a L<Moose::Role> will also work.
  
  So will extending a L<Mouse> class or consuming a L<Mouse::Role> - but note
  that we don't provide L<Mouse> metaclasses or metaroles so the other way
  around doesn't work. This feature exists for L<Any::Moose> users porting to
  L<Moo>; enabling L<Mouse> users to use L<Moo> classes is not a priority for us.
  
  This means that there is no need for anything like L<Any::Moose> for Moo
  code - Moo and Moose code should simply interoperate without problem. To
  handle L<Mouse> code, you'll likely need an empty Moo role or class consuming
  or extending the L<Mouse> stuff since it doesn't register true L<Moose>
  metaclasses like L<Moo> does.
  
  If you want types to be upgraded to the L<Moose> types, use
  L<MooX::Types::MooseLike> and install the L<MooseX::Types> library to
  match the L<MooX::Types::MooseLike> library you're using - L<Moo> will
  load the L<MooseX::Types> library and use that type for the newly created
  metaclass.
  
  If you need to disable the metaclass creation, add:
  
    no Moo::sification;
  
  to your code before Moose is loaded, but bear in mind that this switch is
  currently global and turns the mechanism off entirely so don't put this
  in library code.
  
  =head1 MOO AND CLASS::XSACCESSOR
  
  If a new enough version of L<Class::XSAccessor> is available, it
  will be used to generate simple accessors, readers, and writers for
  a speed boost.  Simple accessors are those without lazy defaults,
  type checks/coercions, or triggers.  Readers and writers generated
  by L<Class::XSAccessor> will behave slightly differently: they will
  reject attempts to call them with the incorrect number of parameters.
  
  =head1 MOO VERSUS ANY::MOOSE
  
  L<Any::Moose> will load L<Mouse> normally, and L<Moose> in a program using
  L<Moose> - which theoretically allows you to get the startup time of L<Mouse>
  without disadvantaging L<Moose> users.
  
  Sadly, this doesn't entirely work, since the selection is load order dependent
  - L<Moo>'s metaclass inflation system explained above in L</MOO AND MOOSE> is
  significantly more reliable.
  
  So if you want to write a CPAN module that loads fast or has only pure perl
  dependencies but is also fully usable by L<Moose> users, you should be using
  L<Moo>.
  
  For a full explanation, see the article
  L<http://shadow.cat/blog/matt-s-trout/moo-versus-any-moose> which explains
  the differing strategies in more detail and provides a direct example of
  where L<Moo> succeeds and L<Any::Moose> fails.
  
  =head1 IMPORTED METHODS
  
  =head2 new
  
   Foo::Bar->new( attr1 => 3 );
  
  or
  
   Foo::Bar->new({ attr1 => 3 });
  
  =head2 BUILDARGS
  
   sub BUILDARGS {
     my ( $class, @args ) = @_;
  
     unshift @args, "attr1" if @args % 2 == 1;
  
     return { @args };
   };
  
   Foo::Bar->new( 3 );
  
  The default implementation of this method accepts a hash or hash reference of
  named parameters. If it receives a single argument that isn't a hash reference
  it throws an error.
  
  You can override this method in your class to handle other types of options
  passed to the constructor.
  
  This method should always return a hash reference of named options.
  
  =head2 FOREIGNBUILDARGS
  
  If you are inheriting from a non-Moo class, the arguments passed to the parent
  class constructor can be manipulated by defining a C<FOREIGNBUILDARGS> method.
  It will receive the same arguments as C<BUILDARGS>, and should return a list
  of arguments to pass to the parent class constructor.
  
  =head2 BUILD
  
  Define a C<BUILD> method on your class and the constructor will automatically
  call the C<BUILD> method from parent down to child after the object has
  been instantiated.  Typically this is used for object validation or possibly
  logging.
  
  =head2 DEMOLISH
  
  If you have a C<DEMOLISH> method anywhere in your inheritance hierarchy,
  a C<DESTROY> method is created on first object construction which will call
  C<< $instance->DEMOLISH($in_global_destruction) >> for each C<DEMOLISH>
  method from child upwards to parents.
  
  Note that the C<DESTROY> method is created on first construction of an object
  of your class in order to not add overhead to classes without C<DEMOLISH>
  methods; this may prove slightly surprising if you try and define your own.
  
  =head2 does
  
   if ($foo->does('Some::Role1')) {
     ...
   }
  
  Returns true if the object composes in the passed role.
  
  =head1 IMPORTED SUBROUTINES
  
  =head2 extends
  
   extends 'Parent::Class';
  
  Declares base class. Multiple superclasses can be passed for multiple
  inheritance (but please use roles instead).
  
  Calling extends more than once will REPLACE your superclasses, not add to
  them like 'use base' would.
  
  =head2 with
  
   with 'Some::Role1';
  
  or
  
   with 'Some::Role1', 'Some::Role2';
  
  Composes one or more L<Moo::Role> (or L<Role::Tiny>) roles into the current
  class.  An error will be raised if these roles have conflicting methods.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class.
  
   package Foo;
   use Moo;
   has 'attr' => (
     is => 'ro'
   );
  
   package Bar;
   use Moo;
   extends 'Foo';
   has '+attr' => (
     default => sub { "blah" },
   );
  
  Using the C<+> notation, it's possible to override an attribute.
  
  The options for C<has> are as follows:
  
  =over 2
  
  =item * is
  
  B<required>, may be C<ro>, C<lazy>, C<rwp> or C<rw>.
  
  C<ro> generates an accessor that dies if you attempt to write to it - i.e.
  a getter only - by defaulting C<reader> to the name of the attribute.
  
  C<lazy> generates a reader like C<ro>, but also sets C<lazy> to 1 and
  C<builder> to C<_build_${attribute_name}> to allow on-demand generated
  attributes.  This feature was my attempt to fix my incompetence when
  originally designing C<lazy_build>, and is also implemented by
  L<MooseX::AttributeShortcuts>. There is, however, nothing to stop you
  using C<lazy> and C<builder> yourself with C<rwp> or C<rw> - it's just that
  this isn't generally a good idea so we don't provide a shortcut for it.
  
  C<rwp> generates a reader like C<ro>, but also sets C<writer> to
  C<_set_${attribute_name}> for attributes that are designed to be written
  from inside of the class, but read-only from outside.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  C<rw> generates a normal getter/setter by defaulting C<accessor> to the
  name of the attribute.
  
  =item * isa
  
  Takes a coderef which is meant to validate the attribute.  Unlike L<Moose>, Moo
  does not include a basic type system, so instead of doing C<< isa => 'Num' >>,
  one should do
  
   isa => sub {
     die "$_[0] is not a number!" unless looks_like_number $_[0]
   },
  
  Note that the return value is ignored, only whether the sub lives or
  dies matters.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  Since L<Moo> does B<not> run the C<isa> check before C<coerce> if a coercion
  subroutine has been supplied, C<isa> checks are not structural to your code
  and can, if desired, be omitted on non-debug builds (although if this results
  in an uncaught bug causing your program to break, the L<Moo> authors guarantee
  nothing except that you get to keep both halves).
  
  If you want L<MooseX::Types> style named types, look at
  L<MooX::Types::MooseLike>.
  
  To cause your C<isa> entries to be automatically mapped to named
  L<Moose::Meta::TypeConstraint> objects (rather than the default behaviour
  of creating an anonymous type), set:
  
    $Moo::HandleMoose::TYPE_MAP{$isa_coderef} = sub {
      require MooseX::Types::Something;
      return MooseX::Types::Something::TypeName();
    };
  
  Note that this example is purely illustrative; anything that returns a
  L<Moose::Meta::TypeConstraint> object or something similar enough to it to
  make L<Moose> happy is fine.
  
  =item * coerce
  
  Takes a coderef which is meant to coerce the attribute.  The basic idea is to
  do something like the following:
  
   coerce => sub {
     $_[0] + 1 unless $_[0] % 2
   },
  
  Note that L<Moo> will always fire your coercion: this is to permit
  C<isa> entries to be used purely for bug trapping, whereas coercions are
  always structural to your code. We do, however, apply any supplied C<isa>
  check after the coercion has run to ensure that it returned a valid value.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * handles
  
  Takes a string
  
    handles => 'RobotRole'
  
  Where C<RobotRole> is a role (L<Moo::Role>) that defines an interface which
  becomes the list of methods to handle.
  
  Takes a list of methods
  
   handles => [ qw( one two ) ]
  
  Takes a hashref
  
   handles => {
     un => 'one',
   }
  
  =item * C<trigger>
  
  Takes a coderef which will get called any time the attribute is set. This
  includes the constructor, but not default or built values. Coderef will be
  invoked against the object with the new value as an argument.
  
  If you set this to just C<1>, it generates a trigger which calls the
  C<_trigger_${attr_name}> method on C<$self>. This feature comes from
  L<MooseX::AttributeShortcuts>.
  
  Note that Moose also passes the old value, if any; this feature is not yet
  supported.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<default>
  
  Takes a coderef which will get called with $self as its only argument
  to populate an attribute if no value is supplied to the constructor - or
  if the attribute is lazy, when the attribute is first retrieved if no
  value has yet been provided.
  
  If a simple scalar is provided, it will be inlined as a string. Any non-code
  reference (hash, array) will result in an error - for that case instead use
  a code reference that returns the desired value.
  
  Note that if your default is fired during new() there is no guarantee that
  other attributes have been populated yet so you should not rely on their
  existence.
  
  L<Sub::Quote aware|/SUB QUOTE AWARE>
  
  =item * C<predicate>
  
  Takes a method name which will return true if an attribute has a value.
  
  If you set this to just C<1>, the predicate is automatically named
  C<has_${attr_name}> if your attribute's name does not start with an
  underscore, or C<_has_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<builder>
  
  Takes a method name which will be called to create the attribute - functions
  exactly like default except that instead of calling
  
    $default->($self);
  
  Moo will call
  
    $self->$builder;
  
  The following features come from L<MooseX::AttributeShortcuts>:
  
  If you set this to just C<1>, the builder is automatically named
  C<_build_${attr_name}>.
  
  If you set this to a coderef or code-convertible object, that variable will be
  installed under C<$class::_build_${attr_name}> and the builder set to the same
  name.
  
  =item * C<clearer>
  
  Takes a method name which will clear the attribute.
  
  If you set this to just C<1>, the clearer is automatically named
  C<clear_${attr_name}> if your attribute's name does not start with an
  underscore, or <_clear_${attr_name_without_the_underscore}> if it does.
  This feature comes from L<MooseX::AttributeShortcuts>.
  
  =item * C<lazy>
  
  B<Boolean>.  Set this if you want values for the attribute to be grabbed
  lazily.  This is usually a good idea if you have a L</builder> which requires
  another attribute to be set.
  
  =item * C<required>
  
  B<Boolean>.  Set this if the attribute must be passed on instantiation.
  
  =item * C<reader>
  
  The value of this attribute will be the name of the method to get the value of
  the attribute.  If you like Java style methods, you might set this to
  C<get_foo>
  
  =item * C<writer>
  
  The value of this attribute will be the name of the method to set the value of
  the attribute.  If you like Java style methods, you might set this to
  C<set_foo>.
  
  =item * C<weak_ref>
  
  B<Boolean>.  Set this if you want the reference that the attribute contains to
  be weakened; use this when circular references are possible, which will cause
  leaks.
  
  =item * C<init_arg>
  
  Takes the name of the key to look for at instantiation time of the object.  A
  common use of this is to make an underscored attribute have a non-underscored
  initialization name. C<undef> means that passing the value in on instantiation
  is ignored.
  
  =item * C<moosify>
  
  Takes either a coderef or array of coderefs which is meant to transform the
  given attributes specifications if necessary when upgrading to a Moose role or
  class. You shouldn't need this by default, but is provided as a means of
  possible extensibility.
  
  =back
  
  =head2 before
  
   before foo => sub { ... };
  
  See L<< Class::Method::Modifiers/before method(s) => sub { ... } >> for full
  documentation.
  
  =head2 around
  
   around foo => sub { ... };
  
  See L<< Class::Method::Modifiers/around method(s) => sub { ... } >> for full
  documentation.
  
  =head2 after
  
   after foo => sub { ... };
  
  See L<< Class::Method::Modifiers/after method(s) => sub { ... } >> for full
  documentation.
  
  =head1 SUB QUOTE AWARE
  
  L<Sub::Quote/quote_sub> allows us to create coderefs that are "inlineable,"
  giving us a handy, XS-free speed boost.  Any option that is L<Sub::Quote>
  aware can take advantage of this.
  
  To do this, you can write
  
    use Moo;
    use Sub::Quote;
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ die "Not <3" unless $_[0] < 3 })
    );
  
  which will be inlined as
  
    do {
      local @_ = ($_[0]->{foo});
      die "Not <3" unless $_[0] < 3;
    }
  
  or to avoid localizing @_,
  
    has foo => (
      is => 'ro',
      isa => quote_sub(q{ my ($val) = @_; die "Not <3" unless $val < 3 })
    );
  
  which will be inlined as
  
    do {
      my ($val) = ($_[0]->{foo});
      die "Not <3" unless $val < 3;
    }
  
  See L<Sub::Quote> for more information, including how to pass lexical
  captures that will also be compiled into the subroutine.
  
  =head1 INCOMPATIBILITIES WITH MOOSE
  
  There is no built-in type system.  C<isa> is verified with a coderef; if you
  need complex types, just make a library of coderefs, or better yet, functions
  that return quoted subs. L<MooX::Types::MooseLike> provides a similar API
  to L<MooseX::Types::Moose> so that you can write
  
    has days_to_live => (is => 'ro', isa => Int);
  
  and have it work with both; it is hoped that providing only subrefs as an
  API will encourage the use of other type systems as well, since it's
  probably the weakest part of Moose design-wise.
  
  C<initializer> is not supported in core since the author considers it to be a
  bad idea and Moose best practices recommend avoiding it. Meanwhile C<trigger> or
  C<coerce> are more likely to be able to fulfill your needs.
  
  There is no meta object.  If you need this level of complexity you wanted
  L<Moose> - Moo succeeds at being small because it explicitly does not
  provide a metaprotocol. However, if you load L<Moose>, then
  
    Class::MOP::class_of($moo_class_or_role)
  
  will return an appropriate metaclass pre-populated by L<Moo>.
  
  No support for C<super>, C<override>, C<inner>, or C<augment> - the author
  considers augment to be a bad idea, and override can be translated:
  
    override foo => sub {
      ...
      super();
      ...
    };
  
    around foo => sub {
      my ($orig, $self) = (shift, shift);
      ...
      $self->$orig(@_);
      ...
    };
  
  The C<dump> method is not provided by default. The author suggests loading
  L<Devel::Dwarn> into C<main::> (via C<perl -MDevel::Dwarn ...> for example) and
  using C<$obj-E<gt>$::Dwarn()> instead.
  
  L</default> only supports coderefs and plain scalars, because passing a hash
  or array reference as a default is almost always incorrect since the value is
  then shared between all objects using that default.
  
  C<lazy_build> is not supported; you are instead encouraged to use the
  C<< is => 'lazy' >> option supported by L<Moo> and L<MooseX::AttributeShortcuts>.
  
  C<auto_deref> is not supported since the author considers it a bad idea and
  it has been considered best practice to avoid it for some time.
  
  C<documentation> will show up in a L<Moose> metaclass created from your class
  but is otherwise ignored. Then again, L<Moose> ignores it as well, so this
  is arguably not an incompatibility.
  
  Since C<coerce> does not require C<isa> to be defined but L<Moose> does
  require it, the metaclass inflation for coerce alone is a trifle insane
  and if you attempt to subtype the result will almost certainly break.
  
  Handling of warnings: when you C<use Moo> we enable FATAL warnings.  The nearest
  similar invocation for L<Moose> would be:
  
    use Moose;
    use warnings FATAL => "all";
  
  Additionally, L<Moo> supports a set of attribute option shortcuts intended to
  reduce common boilerplate.  The set of shortcuts is the same as in the L<Moose>
  module L<MooseX::AttributeShortcuts> as of its version 0.009+.  So if you:
  
      package MyClass;
      use Moo;
  
  The nearest L<Moose> invocation would be:
  
      package MyClass;
  
      use Moose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  or, if you're inheriting from a non-Moose class,
  
      package MyClass;
  
      use Moose;
      use MooseX::NonMoose;
      use warnings FATAL => "all";
      use MooseX::AttributeShortcuts;
  
  Finally, Moose requires you to call
  
      __PACKAGE__->meta->make_immutable;
  
  at the end of your class to get an inlined (i.e. not horribly slow)
  constructor. Moo does it automatically the first time ->new is called
  on your class. (C<make_immutable> is a no-op in Moo to ease migration.)
  
  An extension L<MooX::late> exists to ease translating Moose packages
  to Moo by providing a more Moose-like interface.
  
  =head1 SUPPORT
  
  Users' IRC: #moose on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#moose@irc.perl.org">(click for instant chatroom login)</a>
  
  Development and contribution IRC: #web-simple on irc.perl.org
  
  =for html <a href="http://chat.mibbit.com/#web-simple@irc.perl.org">(click for instant chatroom login)</a>
  
  Bugtracker: L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Moo>
  
  Git repository: L<git://git.shadowcat.co.uk/gitmo/Moo.git>
  
  Git web access: L<http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=gitmo/Moo.git>
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  dg - David Leadbeater (cpan:DGL) <dgl@dgl.cx>
  
  frew - Arthur Axel "fREW" Schmidt (cpan:FREW) <frioux@gmail.com>
  
  hobbs - Andrew Rodland (cpan:ARODLAND) <arodland@cpan.org>
  
  jnap - John Napiorkowski (cpan:JJNAPIORK) <jjn1056@yahoo.com>
  
  ribasushi - Peter Rabbitson (cpan:RIBASUSHI) <ribasushi@cpan.org>
  
  chip - Chip Salzenberg (cpan:CHIPS) <chip@pobox.com>
  
  ajgb - Alex J. G. Burzyński (cpan:AJGB) <ajgb@cpan.org>
  
  doy - Jesse Luehrs (cpan:DOY) <doy at tozt dot net>
  
  perigrin - Chris Prather (cpan:PERIGRIN) <chris@prather.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@googlemail.com>
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  tobyink - Toby Inkster (cpan:TOBYINK) <tobyink@cpan.org>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@cpan.org>
  
  mattp - Matt Phillips (cpan:MATTP) <mattp@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010-2011 the Moo L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself. See L<http://dev.perl.org/licenses/>.
  
  =cut
MOO

$fatpacked{"Moo/Conflicts.pm"} = <<'MOO_CONFLICTS';
  package # hide from PAUSE
      Moo::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Moo',
      -conflicts => {
          # enter conflicting downstream deps here, with the version indicating
          # the last *broken* version that *does not work*.
          'HTML::Restrict' => '2.1.5',
      },
  
      # these dists' ::Conflicts modules (if they exist) are also checked for
      # more incompatibilities -- should include all runtime prereqs here.
      -also => [ qw(
          Carp
          Class::Method::Modifiers
          strictures
          Module::Runtime
          Role::Tiny
          Devel::GlobalDestruction
      ) ],
  ;
  
  1;
MOO_CONFLICTS

$fatpacked{"Moo/HandleMoose.pm"} = <<'MOO_HANDLEMOOSE';
  package Moo::HandleMoose;
  
  use strictures 1;
  use Moo::_Utils;
  use B qw(perlstring);
  
  our %TYPE_MAP;
  
  our $SETUP_DONE;
  
  sub import { return if $SETUP_DONE; inject_all(); $SETUP_DONE = 1; }
  
  sub inject_all {
    require Class::MOP;
    inject_fake_metaclass_for($_)
      for grep $_ ne 'Moo::Object', do { no warnings 'once'; keys %Moo::MAKERS };
    inject_fake_metaclass_for($_) for keys %Moo::Role::INFO;
    require Moose::Meta::Method::Constructor;
    @Moo::HandleMoose::FakeConstructor::ISA = 'Moose::Meta::Method::Constructor';
  }
  
  sub maybe_reinject_fake_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    if (delete $DID_INJECT{$name}) {
      unless ($Moo::Role::INFO{$name}) {
        Moo->_constructor_maker_for($name)->install_delayed;
      }
      inject_fake_metaclass_for($name);
    }
  }
  
  sub inject_fake_metaclass_for {
    my ($name) = @_;
    require Class::MOP;
    require Moo::HandleMoose::FakeMetaClass;
    Class::MOP::store_metaclass_by_name(
      $name, bless({ name => $name }, 'Moo::HandleMoose::FakeMetaClass')
    );
    require Moose::Util::TypeConstraints;
    if ($Moo::Role::INFO{$name}) {
      Moose::Util::TypeConstraints::find_or_create_does_type_constraint($name);
    } else {
      Moose::Util::TypeConstraints::find_or_create_isa_type_constraint($name);
    }
  }
  
  {
    package Moo::HandleMoose::FakeConstructor;
  
    sub _uninlined_body { \&Moose::Object::new }
  }
      
  
  sub inject_real_metaclass_for {
    my ($name) = @_;
    our %DID_INJECT;
    return Class::MOP::get_metaclass_by_name($name) if $DID_INJECT{$name};
    require Moose; require Moo; require Moo::Role; require Scalar::Util;
    Class::MOP::remove_metaclass_by_name($name);
    my ($am_role, $meta, $attr_specs, $attr_order) = do {
      if (my $info = $Moo::Role::INFO{$name}) {
        my @attr_info = @{$info->{attributes}||[]};
        (1, Moose::Meta::Role->initialize($name),
         { @attr_info },
         [ @attr_info[grep !($_ % 2), 0..$#attr_info] ]
        )
      } elsif ( my $cmaker = Moo->_constructor_maker_for($name) ) {
        my $specs = $cmaker->all_attribute_specs;
        (0, Moose::Meta::Class->initialize($name), $specs,
         [ sort { $specs->{$a}{index} <=> $specs->{$b}{index} } keys %$specs ]
        );
      } else {
         # This codepath is used if $name does not exist in $Moo::MAKERS
         (0, Moose::Meta::Class->initialize($name), {}, [] )
      }
    };
  
    for my $spec (values %$attr_specs) {
      if (my $inflators = delete $spec->{moosify}) {
        $_->($spec) for @$inflators;
      }
    }
  
    my %methods = %{Role::Tiny->_concrete_methods_of($name)};
  
    # if stuff gets added afterwards, _maybe_reset_handlemoose should
    # trigger the recreation of the metaclass but we need to ensure the
    # Role::Tiny cache is cleared so we don't confuse Moo itself.
    if (my $info = $Role::Tiny::INFO{$name}) {
      delete $info->{methods};
    }
  
    # needed to ensure the method body is stable and get things named
    Sub::Defer::undefer_sub($_) for grep defined, values %methods;
    my @attrs;
    {
      # This local is completely not required for roles but harmless
      local @{_getstash($name)}{keys %methods};
      my %seen_name;
      foreach my $name (@$attr_order) {
        $seen_name{$name} = 1;
        my %spec = %{$attr_specs->{$name}};
        my %spec_map = (
          map { $_->name => $_->init_arg||$_->name }
          (
            (grep { $_->has_init_arg }
               $meta->attribute_metaclass->meta->get_all_attributes),
            grep { exists($_->{init_arg}) ? defined($_->init_arg) : 1 }
            map {
              my $meta = Moose::Util::resolve_metatrait_alias('Attribute', $_)
                           ->meta;
              map $meta->get_attribute($_), $meta->get_attribute_list
            }  @{$spec{traits}||[]}
          )
        );
        # have to hard code this because Moose's role meta-model is lacking
        $spec_map{traits} ||= 'traits';
  
        $spec{is} = 'ro' if $spec{is} eq 'lazy' or $spec{is} eq 'rwp';
        my $coerce = $spec{coerce};
        if (my $isa = $spec{isa}) {
          my $tc = $spec{isa} = do {
            if (my $mapped = $TYPE_MAP{$isa}) {
              my $type = $mapped->();
              Scalar::Util::blessed($type) && $type->isa("Moose::Meta::TypeConstraint")
                or die "error inflating attribute '$name' for package '$_[0]': \$TYPE_MAP{$isa} did not return a valid type constraint'";
              $coerce ? $type->create_child_type(name => $type->name) : $type;
            } else {
              Moose::Meta::TypeConstraint->new(
                constraint => sub { eval { &$isa; 1 } }
              );
            }
          };
          if ($coerce) {
            $tc->coercion(Moose::Meta::TypeCoercion->new)
               ->_compiled_type_coercion($coerce);
            $spec{coerce} = 1;
          }
        } elsif ($coerce) {
          my $attr = perlstring($name);
          my $tc = Moose::Meta::TypeConstraint->new(
                     constraint => sub { die "This is not going to work" },
                     inlined => sub {
                        'my $r = $_[42]{'.$attr.'}; $_[42]{'.$attr.'} = 1; $r'
                     },
                   );
          $tc->coercion(Moose::Meta::TypeCoercion->new)
             ->_compiled_type_coercion($coerce);
          $spec{isa} = $tc;
          $spec{coerce} = 1;
        }
        %spec =
          map { $spec_map{$_} => $spec{$_} }
          grep { exists $spec_map{$_} }
          keys %spec;
        push @attrs, $meta->add_attribute($name => %spec);
      }
      foreach my $mouse (do { our %MOUSE; @{$MOUSE{$name}||[]} }) {
        foreach my $attr ($mouse->get_all_attributes) {
          my %spec = %{$attr};
          delete @spec{qw(
            associated_class associated_methods __METACLASS__
            provides curries
          )};
          my $name = delete $spec{name};
          next if $seen_name{$name}++;
          push @attrs, $meta->add_attribute($name => %spec);
        }
      }
    }
    for my $meth_name (keys %methods) {
      my $meth_code = $methods{$meth_name};
      $meta->add_method($meth_name, $meth_code) if $meth_code;
    }
  
    if ($am_role) {
      my $info = $Moo::Role::INFO{$name};
      $meta->add_required_methods(@{$info->{requires}});
      foreach my $modifier (@{$info->{modifiers}}) {
        my ($type, @args) = @$modifier;
        my $code = pop @args;
        $meta->${\"add_${type}_method_modifier"}($_, $code) for @args;
      }
    } else {
      foreach my $attr (@attrs) {
        foreach my $method (@{$attr->associated_methods}) {
          $method->{body} = $name->can($method->name);
        }
      }
      bless(
        $meta->find_method_by_name('new'),
        'Moo::HandleMoose::FakeConstructor',
      );
    }
    $meta->add_role(Class::MOP::class_of($_))
      for grep !/\|/ && $_ ne $name, # reject Foo|Bar and same-role-as-self
        do { no warnings 'once'; keys %{$Role::Tiny::APPLIED_TO{$name}} };
    $DID_INJECT{$name} = 1;
    $meta;
  }
  
  1;
MOO_HANDLEMOOSE

$fatpacked{"Moo/HandleMoose/FakeMetaClass.pm"} = <<'MOO_HANDLEMOOSE_FAKEMETACLASS';
  package Moo::HandleMoose::FakeMetaClass;
  
  sub DESTROY { }
  
  sub AUTOLOAD {
    my ($meth) = (our $AUTOLOAD =~ /([^:]+)$/);
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->$meth(@_)
  }
  sub can {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->can(@_)
  }
  sub isa {
    require Moo::HandleMoose;
    Moo::HandleMoose::inject_real_metaclass_for((shift)->{name})->isa(@_)
  }
  sub make_immutable { $_[0] }
  
  1;
MOO_HANDLEMOOSE_FAKEMETACLASS

$fatpacked{"Moo/Object.pm"} = <<'MOO_OBJECT';
  package Moo::Object;
  
  use strictures 1;
  
  our %NO_BUILD;
  our %NO_DEMOLISH;
  our $BUILD_MAKER;
  our $DEMOLISH_MAKER;
  
  sub new {
    my $class = shift;
    unless (exists $NO_DEMOLISH{$class}) {
      unless ($NO_DEMOLISH{$class} = !$class->can('DEMOLISH')) {
        ($DEMOLISH_MAKER ||= do {
          require Method::Generate::DemolishAll;
          Method::Generate::DemolishAll->new
        })->generate_method($class);
      }
    }
    $NO_BUILD{$class} and
      return bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class);
    $NO_BUILD{$class} = !$class->can('BUILD') unless exists $NO_BUILD{$class};
    $NO_BUILD{$class}
      ? bless({ ref($_[0]) eq 'HASH' ? %{$_[0]} : @_ }, $class)
      : do {
          my $proto = ref($_[0]) eq 'HASH' ? $_[0] : { @_ };
          bless({ %$proto }, $class)->BUILDALL($proto);
        };
  }
  
  # Inlined into Method::Generate::Constructor::_generate_args() - keep in sync
  sub BUILDARGS {
      my $class = shift;
      if ( scalar @_ == 1 ) {
          unless ( defined $_[0] && ref $_[0] eq 'HASH' ) {
              die "Single parameters to new() must be a HASH ref"
                  ." data => ". $_[0] ."\n";
          }
          return { %{ $_[0] } };
      }
      elsif ( @_ % 2 ) {
          die "The new() method for $class expects a hash reference or a key/value list."
                  . " You passed an odd number of arguments\n";
      }
      else {
          return {@_};
      }
  }
  
  sub BUILDALL {
    my $self = shift;
    $self->${\(($BUILD_MAKER ||= do {
      require Method::Generate::BuildAll;
      Method::Generate::BuildAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub DEMOLISHALL {
    my $self = shift;
    $self->${\(($DEMOLISH_MAKER ||= do {
      require Method::Generate::DemolishAll;
      Method::Generate::DemolishAll->new
    })->generate_method(ref($self)))}(@_);
  }
  
  sub does {
    require Role::Tiny;
    { no warnings 'redefine'; *does = \&Role::Tiny::does_role }
    goto &Role::Tiny::does_role;
  }
  
  # duplicated in Moo::Role
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  1;
MOO_OBJECT

$fatpacked{"Moo/Role.pm"} = <<'MOO_ROLE';
  package Moo::Role;
  
  use strictures 1;
  use Moo::_Utils;
  use Role::Tiny ();
  use base qw(Role::Tiny);
  
  require Moo::sification;
  
  BEGIN { *INFO = \%Role::Tiny::INFO }
  
  our %INFO;
  our %APPLY_DEFAULTS;
  
  sub _install_tracked {
    my ($target, $name, $code) = @_;
    $INFO{$target}{exports}{$name} = $code;
    _install_coderef "${target}::${name}" => "Moo::Role::${name}" => $code;
  }
  
  sub import {
    my $target = caller;
    my ($me) = @_;
    strictures->import;
    if ($Moo::MAKERS{$target} and $Moo::MAKERS{$target}{is_class}) {
      die "Cannot import Moo::Role into a Moo class";
    }
    $INFO{$target} ||= {};
    # get symbol table reference
    my $stash = do { no strict 'refs'; \%{"${target}::"} };
    _install_tracked $target => has => sub {
      my ($name_proto, %spec) = @_;
      my $name_isref = ref $name_proto eq 'ARRAY';
      foreach my $name ($name_isref ? @$name_proto : $name_proto) {
        my $spec_ref = $name_isref ? +{%spec} : \%spec;
        ($INFO{$target}{accessor_maker} ||= do {
          require Method::Generate::Accessor;
          Method::Generate::Accessor->new
        })->generate_method($target, $name, $spec_ref);
        push @{$INFO{$target}{attributes}||=[]}, $name, $spec_ref;
        $me->_maybe_reset_handlemoose($target);
      }
    };
    # install before/after/around subs
    foreach my $type (qw(before after around)) {
      _install_tracked $target => $type => sub {
        require Class::Method::Modifiers;
        push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
        $me->_maybe_reset_handlemoose($target);
      };
    }
    _install_tracked $target => requires => sub {
      push @{$INFO{$target}{requires}||=[]}, @_;
      $me->_maybe_reset_handlemoose($target);
    };
    _install_tracked $target => with => sub {
      $me->apply_roles_to_package($target, @_);
      $me->_maybe_reset_handlemoose($target);
    };
    return if $INFO{$target}{is_role}; # already exported into this package
    $INFO{$target}{is_role} = 1;
    *{_getglob("${target}::meta")} = $me->can('meta');
    # grab all *non-constant* (stash slot is not a scalarref) subs present
    # in the symbol table and store their refaddrs (no need to forcibly
    # inflate constant subs into real subs) - also add '' to here (this
    # is used later) with a map to the coderefs in case of copying or re-use
    my @not_methods = ('', map { *$_{CODE}||() } grep !ref($_), values %$stash);
    @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
    # a role does itself
    $Role::Tiny::APPLIED_TO{$target} = { $target => undef };
  
    if ($INC{'Moo/HandleMoose.pm'}) {
      Moo::HandleMoose::inject_fake_metaclass_for($target);
    }
  }
  
  # duplicate from Moo::Object
  sub meta {
    require Moo::HandleMoose::FakeMetaClass;
    my $class = ref($_[0])||$_[0];
    bless({ name => $class }, 'Moo::HandleMoose::FakeMetaClass');
  }
  
  sub unimport {
    my $target = caller;
    _unimport_coderefs($target, $INFO{$target});
  }
  
  sub _maybe_reset_handlemoose {
    my ($class, $target) = @_;
    if ($INC{"Moo/HandleMoose.pm"}) {
      Moo::HandleMoose::maybe_reinject_fake_metaclass_for($target);
    }
  }
  
  sub _inhale_if_moose {
    my ($self, $role) = @_;
    _load_module($role);
    my $meta;
    if (!$INFO{$role}
        and (
          $INC{"Moose.pm"}
          and $meta = Class::MOP::class_of($role)
          and $meta->isa('Moose::Meta::Role')
        )
        or (
          Mouse::Util->can('find_meta')
          and $meta = Mouse::Util::find_meta($role)
          and $meta->isa('Mouse::Meta::Role')
       )
    ) {
      $INFO{$role}{methods} = {
        map +($_ => $role->can($_)),
          grep !$meta->get_method($_)->isa('Class::MOP::Method::Meta'),
            $meta->get_method_list
      };
      $Role::Tiny::APPLIED_TO{$role} = {
        map +($_->name => 1), $meta->calculate_all_roles
      };
      $INFO{$role}{requires} = [ $meta->get_required_method_list ];
      $INFO{$role}{attributes} = [
        map +($_ => do {
          my $attr = $meta->get_attribute($_);
          my $is_mouse = $meta->isa('Mouse::Meta::Role');
          my $spec = { %{ $is_mouse ? $attr : $attr->original_options } };
  
          if ($spec->{isa}) {
  
            my $get_constraint = do {
              my $pkg = $is_mouse
                          ? 'Mouse::Util::TypeConstraints'
                          : 'Moose::Util::TypeConstraints';
              _load_module($pkg);
              $pkg->can('find_or_create_isa_type_constraint');
            };
  
            my $tc = $get_constraint->($spec->{isa});
            my $check = $tc->_compiled_type_constraint;
  
            $spec->{isa} = sub {
              &$check or die "Type constraint failed for $_[0]"
            };
  
            if ($spec->{coerce}) {
  
               # Mouse has _compiled_type_coercion straight on the TC object
               $spec->{coerce} = $tc->${\(
                 $tc->can('coercion')||sub { $_[0] }
               )}->_compiled_type_coercion;
            }
          }
          $spec;
        }), $meta->get_attribute_list
      ];
      my $mods = $INFO{$role}{modifiers} = [];
      foreach my $type (qw(before after around)) {
        # Mouse pokes its own internals so we have to fall back to doing
        # the same thing in the absence of the Moose API method
        my $map = $meta->${\(
          $meta->can("get_${type}_method_modifiers_map")
          or sub { shift->{"${type}_method_modifiers"} }
        )};
        foreach my $method (keys %$map) {
          foreach my $mod (@{$map->{$method}}) {
            push @$mods, [ $type => $method => $mod ];
          }
        }
      }
      require Class::Method::Modifiers if @$mods;
      $INFO{$role}{inhaled_from_moose} = 1;
      $INFO{$role}{is_role} = 1;
    }
  }
  
  sub _maybe_make_accessors {
    my ($self, $target, $role) = @_;
    my $m;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}
        or $INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($target)
        and ref($m) ne 'Method::Generate::Accessor') {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors_if_moose {
    my ($self, $target, $role) = @_;
    if ($INFO{$role} && $INFO{$role}{inhaled_from_moose}) {
      $self->_make_accessors($target, $role);
    }
  }
  
  sub _make_accessors {
    my ($self, $target, $role) = @_;
    my $acc_gen = ($Moo::MAKERS{$target}{accessor} ||= do {
      require Method::Generate::Accessor;
      Method::Generate::Accessor->new
    });
    my $con_gen = $Moo::MAKERS{$target}{constructor};
    my @attrs = @{$INFO{$role}{attributes}||[]};
    while (my ($name, $spec) = splice @attrs, 0, 2) {
      # needed to ensure we got an index for an arrayref based generator
      if ($con_gen) {
        $spec = $con_gen->all_attribute_specs->{$name};
      }
      $acc_gen->generate_method($target, $name, $spec);
    }
  }
  
  sub role_application_steps {
    qw(_handle_constructor _maybe_make_accessors),
      $_[0]->SUPER::role_application_steps;
  }
  
  sub apply_roles_to_package {
    my ($me, $to, @roles) = @_;
    foreach my $role (@roles) {
      $me->_inhale_if_moose($role);
      die "${role} is not a Moo::Role" unless $INFO{$role};
    }
    $me->SUPER::apply_roles_to_package($to, @roles);
  }
  
  sub apply_single_role_to_package {
    my ($me, $to, $role) = @_;
    $me->_inhale_if_moose($role);
    die "${role} is not a Moo::Role" unless $INFO{$role};
    $me->SUPER::apply_single_role_to_package($to, $role);
  }
  
  sub create_class_with_roles {
    my ($me, $superclass, @roles) = @_;
  
    my $new_name = join(
      '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
    );
  
    return $new_name if $Role::Tiny::COMPOSED{class}{$new_name};
  
    foreach my $role (@roles) {
        $me->_inhale_if_moose($role);
    }
  
    my $m;
    if ($INC{"Moo.pm"}
        and $m = Moo->_accessor_maker_for($superclass)
        and ref($m) ne 'Method::Generate::Accessor') {
      # old fashioned way time.
      *{_getglob("${new_name}::ISA")} = [ $superclass ];
      $me->apply_roles_to_package($new_name, @roles);
      return $new_name;
    }
  
    require Sub::Quote;
  
    $me->SUPER::create_class_with_roles($superclass, @roles);
  
    foreach my $role (@roles) {
      die "${role} is not a Role::Tiny" unless $INFO{$role};
    }
  
    $Moo::MAKERS{$new_name} = {is_class => 1};
  
    $me->_handle_constructor($new_name, $_) for @roles;
  
    return $new_name;
  }
  
  sub apply_roles_to_object {
    my ($me, $object, @roles) = @_;
    my $new = $me->SUPER::apply_roles_to_object($object, @roles);
  
    my $apply_defaults = $APPLY_DEFAULTS{ref $new} ||= do {
      my %attrs = map { @{$INFO{$_}{attributes}||[]} } @roles;
  
      if ($INC{'Moo.pm'}
          and keys %attrs
          and my $con_gen = Moo->_constructor_maker_for(ref $new)
          and my $m = Moo->_accessor_maker_for(ref $new)) {
        require Sub::Quote;
  
        my $specs = $con_gen->all_attribute_specs;
  
        my $assign = '';
        my %captures;
        foreach my $name ( keys %attrs ) {
          my $spec = $specs->{$name};
          if ($m->has_eager_default($name, $spec)) {
            my ($has, $has_cap)
              = $m->generate_simple_has('$_[0]', $name, $spec);
            my ($code, $pop_cap)
              = $m->generate_use_default('$_[0]', $name, $spec, $has);
  
            $assign .= $code;
            @captures{keys %$has_cap, keys %$pop_cap}
              = (values %$has_cap, values %$pop_cap);
          }
        }
        Sub::Quote::quote_sub($assign, \%captures);
      }
      else {
        sub {};
      }
    };
    $new->$apply_defaults;
    return $new;
  }
  
  sub _composable_package_for {
    my ($self, $role) = @_;
    my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
    return $composed_name if $Role::Tiny::COMPOSED{role}{$composed_name};
    $self->_make_accessors_if_moose($composed_name, $role);
    $self->SUPER::_composable_package_for($role);
  }
  
  sub _install_single_modifier {
    my ($me, @args) = @_;
    _install_modifier(@args);
  }
  
  sub _handle_constructor {
    my ($me, $to, $role) = @_;
    my $attr_info = $INFO{$role} && $INFO{$role}{attributes};
    return unless $attr_info && @$attr_info;
    if ($INFO{$to}) {
      push @{$INFO{$to}{attributes}||=[]}, @$attr_info;
    } else {
      # only fiddle with the constructor if the target is a Moo class
      if ($INC{"Moo.pm"}
          and my $con = Moo->_constructor_maker_for($to)) {
        # shallow copy of the specs since the constructor will assign an index
        $con->register_attribute_specs(map ref() ? { %$_ } : $_, @$attr_info);
      }
    }
  }
  
  1;
  
  =head1 NAME
  
  Moo::Role - Minimal Object Orientation support for Roles
  
  =head1 SYNOPSIS
  
   package My::Role;
  
   use Moo::Role;
  
   sub foo { ... }
  
   sub bar { ... }
  
   has baz => (
     is => 'ro',
   );
  
   1;
  
  And elsewhere:
  
   package Some::Class;
  
   use Moo;
  
   # bar gets imported, but not foo
   with('My::Role');
  
   sub foo { ... }
  
   1;
  
  =head1 DESCRIPTION
  
  C<Moo::Role> builds upon L<Role::Tiny>, so look there for most of the
  documentation on how this works.  The main addition here is extra bits to make
  the roles more "Moosey;" which is to say, it adds L</has>.
  
  =head1 IMPORTED SUBROUTINES
  
  See L<Role::Tiny/IMPORTED SUBROUTINES> for all the other subroutines that are
  imported by this module.
  
  =head2 has
  
   has attr => (
     is => 'ro',
   );
  
  Declares an attribute for the class to be composed into.  See
  L<Moo/has> for all options.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
MOO_ROLE

$fatpacked{"Moo/_Utils.pm"} = <<'MOO__UTILS';
  package Moo::_Utils;
  
  no warnings 'once'; # guard against -w
  
  sub _getglob { \*{$_[0]} }
  sub _getstash { \%{"$_[0]::"} }
  
  use constant lt_5_8_3 => ( $] < 5.008003 or $ENV{MOO_TEST_PRE_583} ) ? 1 : 0;
  use constant can_haz_subname => eval { require Sub::Name };
  
  use strictures 1;
  use Module::Runtime qw(require_module);
  use Devel::GlobalDestruction ();
  use base qw(Exporter);
  use Moo::_mro;
  
  our @EXPORT = qw(
      _getglob _install_modifier _load_module _maybe_load_module
      _get_linear_isa _getstash _install_coderef _name_coderef
      _unimport_coderefs _in_global_destruction
  );
  
  sub _in_global_destruction ();
  *_in_global_destruction = \&Devel::GlobalDestruction::in_global_destruction;
  
  sub _install_modifier {
    my ($into, $type, $name, $code) = @_;
  
    if (my $to_modify = $into->can($name)) { # CMM will throw for us if not
      require Sub::Defer;
      Sub::Defer::undefer_sub($to_modify);
    }
  
    Class::Method::Modifiers::install_modifier(@_);
  }
  
  our %MAYBE_LOADED;
  
  sub _load_module {
    (my $proto = $_[0]) =~ s/::/\//g;
    return 1 if $INC{"${proto}.pm"};
    # can't just ->can('can') because a sub-package Foo::Bar::Baz
    # creates a 'Baz::' key in Foo::Bar's symbol table
    my $stash = _getstash($_[0])||{};
    return 1 if grep +(!ref($_) and *$_{CODE}), values %$stash;
    require_module($_[0]);
    return 1;
  }
  
  sub _maybe_load_module {
    return $MAYBE_LOADED{$_[0]} if exists $MAYBE_LOADED{$_[0]};
    (my $proto = $_[0]) =~ s/::/\//g;
    local $@;
    if (eval { require "${proto}.pm"; 1 }) {
      $MAYBE_LOADED{$_[0]} = 1;
    } else {
      if (exists $INC{"${proto}.pm"}) {
        warn "$_[0] exists but failed to load with error: $@";
      }
      $MAYBE_LOADED{$_[0]} = 0;
    }
    return $MAYBE_LOADED{$_[0]};
  }
  
  sub _get_linear_isa {
    return mro::get_linear_isa($_[0]);
  }
  
  sub _install_coderef {
    no warnings 'redefine';
    *{_getglob($_[0])} = _name_coderef(@_);
  }
  
  sub _name_coderef {
    shift if @_ > 2; # three args is (target, name, sub)
    can_haz_subname ? Sub::Name::subname(@_) : $_[1];
  }
  
  sub _unimport_coderefs {
    my ($target, $info) = @_;
    return unless $info and my $exports = $info->{exports};
    my %rev = reverse %$exports;
    my $stash = _getstash($target);
    foreach my $name (keys %$exports) {
      if ($stash->{$name} and defined(&{$stash->{$name}})) {
        if ($rev{$target->can($name)}) {
          my $old = delete $stash->{$name};
          my $full_name = join('::',$target,$name);
          # Copy everything except the code slot back into place (e.g. $has)
          foreach my $type (qw(SCALAR HASH ARRAY IO)) {
            next unless defined(*{$old}{$type});
            no strict 'refs';
            *$full_name = *{$old}{$type};
          }
        }
      }
    }
  }
  
  sub STANDARD_DESTROY {
    my $self = shift;
  
    my $e = do {
      local $?;
      local $@;
      eval {
        $self->DEMOLISHALL(_in_global_destruction);
      };
      $@;
    };
  
    no warnings 'misc';
    die $e if $e; # rethrow
  }
  
  1;
MOO__UTILS

$fatpacked{"Moo/_mro.pm"} = <<'MOO__MRO';
  package Moo::_mro;
  
  if ($] >= 5.010) {
    require mro;
  } else {
    require MRO::Compat;
  }
  
  1;
MOO__MRO

$fatpacked{"Moo/sification.pm"} = <<'MOO_SIFICATION';
  package Moo::sification;
  
  use strictures 1;
  use Moo::_Utils ();
  
  sub unimport { our $disarmed = 1 }
  
  sub Moo::HandleMoose::AuthorityHack::DESTROY {
    unless (our $disarmed or Moo::_Utils::_in_global_destruction) {
      require Moo::HandleMoose;
      Moo::HandleMoose->import;
    }
  }
  
  if ($INC{"Moose.pm"}) {
    require Moo::HandleMoose;
    Moo::HandleMoose->import;
  } else {
    $Moose::AUTHORITY = bless({}, 'Moo::HandleMoose::AuthorityHack');
  }
  
  1;
MOO_SIFICATION

$fatpacked{"Package/Stash.pm"} = <<'PACKAGE_STASH';
  package Package::Stash;
  BEGIN {
    $Package::Stash::AUTHORITY = 'cpan:DOY';
  }
  {
    $Package::Stash::VERSION = '0.35';
  }
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: routines for manipulating stashes
  
  our $IMPLEMENTATION;
  
  use Module::Implementation 0.06;
  
  BEGIN {
      local $ENV{PACKAGE_STASH_IMPLEMENTATION} = $IMPLEMENTATION
        if ( $IMPLEMENTATION and not $ENV{PACKAGE_STASH_IMPLEMENTATION} );
  
      Module::Implementation::build_loader_sub(
          implementations => [ 'XS', 'PP' ]
      )->();
      $IMPLEMENTATION = Module::Implementation::implementation_for(__PACKAGE__);
  
      my $impl = "Package::Stash::$IMPLEMENTATION";
      my $from = $impl->new($impl);
      my $to = $impl->new(__PACKAGE__);
      my $methods = $from->get_all_symbols('CODE');
      for my $meth (keys %$methods) {
          $to->add_symbol("&$meth" => $methods->{$meth});
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash - routines for manipulating stashes
  
  =head1 VERSION
  
  version 0.35
  
  =head1 SYNOPSIS
  
    my $stash = Package::Stash->new('Foo');
    $stash->add_symbol('%foo', {bar => 1});
    # $Foo::foo{bar} == 1
    $stash->has_symbol('$foo') # false
    my $namespace = $stash->namespace;
    *{ $namespace->{foo} }{HASH} # {bar => 1}
  
  =head1 DESCRIPTION
  
  Manipulating stashes (Perl's symbol tables) is occasionally necessary, but
  incredibly messy, and easy to get wrong. This module hides all of that behind a
  simple API.
  
  NOTE: Most methods in this class require a variable specification that includes
  a sigil. If this sigil is absent, it is assumed to represent the IO slot.
  
  Due to limitations in the typeglob API available to perl code, and to typeglob
  manipulation in perl being quite slow, this module provides two
  implementations - one in pure perl, and one using XS. The XS implementation is
  to be preferred for most usages; the pure perl one is provided for cases where
  XS modules are not a possibility. The current implementation in use can be set
  by setting C<$ENV{PACKAGE_STASH_IMPLEMENTATION}> or
  C<$Package::Stash::IMPLEMENTATION> before loading Package::Stash (with the
  environment variable taking precedence), otherwise, it will use the XS
  implementation if possible, falling back to the pure perl one.
  
  =head1 METHODS
  
  =head2 new $package_name
  
  Creates a new C<Package::Stash> object, for the package given as the only
  argument.
  
  =head2 name
  
  Returns the name of the package that this object represents.
  
  =head2 namespace
  
  Returns the raw stash itself.
  
  =head2 add_symbol $variable $value %opts
  
  Adds a new package symbol, for the symbol given as C<$variable>, and optionally
  gives it an initial value of C<$value>. C<$variable> should be the name of
  variable including the sigil, so
  
    Package::Stash->new('Foo')->add_symbol('%foo')
  
  will create C<%Foo::foo>.
  
  Valid options (all optional) are C<filename>, C<first_line_num>, and
  C<last_line_num>.
  
  C<$opts{filename}>, C<$opts{first_line_num}>, and C<$opts{last_line_num}> can
  be used to indicate where the symbol should be regarded as having been defined.
  Currently these values are only used if the symbol is a subroutine ('C<&>'
  sigil) and only if C<$^P & 0x10> is true, in which case the special C<%DB::sub>
  hash is updated to record the values of C<filename>, C<first_line_num>, and
  C<last_line_num> for the subroutine. If these are not passed, their values are
  inferred (as much as possible) from C<caller> information.
  
  This is especially useful for debuggers and profilers, which use C<%DB::sub> to
  determine where the source code for a subroutine can be found.  See
  L<http://perldoc.perl.org/perldebguts.html#Debugger-Internals> for more
  information about C<%DB::sub>.
  
  =head2 remove_glob $name
  
  Removes all package variables with the given name, regardless of sigil.
  
  =head2 has_symbol $variable
  
  Returns whether or not the given package variable (including sigil) exists.
  
  =head2 get_symbol $variable
  
  Returns the value of the given package variable (including sigil).
  
  =head2 get_or_add_symbol $variable
  
  Like C<get_symbol>, except that it will return an empty hashref or
  arrayref if the variable doesn't exist.
  
  =head2 remove_symbol $variable
  
  Removes the package variable described by C<$variable> (which includes the
  sigil); other variables with the same name but different sigils will be
  untouched.
  
  =head2 list_all_symbols $type_filter
  
  Returns a list of package variable names in the package, without sigils. If a
  C<type_filter> is passed, it is used to select package variables of a given
  type, where valid types are the slots of a typeglob ('SCALAR', 'CODE', 'HASH',
  etc). Note that if the package contained any C<BEGIN> blocks, perl will leave
  an empty typeglob in the C<BEGIN> slot, so this will show up if no filter is
  used (and similarly for C<INIT>, C<END>, etc).
  
  =head2 get_all_symbols $type_filter
  
  Returns a hashref, keyed by the variable names in the package. If
  C<$type_filter> is passed, the hash will contain every variable of that type in
  the package as values, otherwise, it will contain the typeglobs corresponding
  to the variable names (basically, a clone of the stash).
  
  =head1 BUGS / CAVEATS
  
  =over 4
  
  =item * Prior to perl 5.10, scalar slots are only considered to exist if they are defined
  
  This is due to a shortcoming within perl itself. See
  L<perlref/Making References> point 7 for more information.
  
  =item * GLOB and FORMAT variables are not (yet) accessible through this module.
  
  =item * Also, see the BUGS section for the specific backends (L<Package::Stash::XS> and L<Package::Stash::PP>)
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH

$fatpacked{"Package/Stash/Conflicts.pm"} = <<'PACKAGE_STASH_CONFLICTS';
  package # hide from PAUSE
      Package::Stash::Conflicts;
  
  use strict;
  use warnings;
  
  use Dist::CheckConflicts
      -dist      => 'Package::Stash',
      -conflicts => {
          'Class::MOP' => '1.08',
          'MooseX::Method::Signatures' => '0.36',
          'MooseX::Role::WithOverloading' => '0.08',
          'namespace::clean' => '0.18',
      },
  
  ;
  
  1;
  
  # ABSTRACT: Provide information on conflicts for Package::Stash
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash::Conflicts - Provide information on conflicts for Package::Stash
  
  =head1 VERSION
  
  version 0.35
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_CONFLICTS

$fatpacked{"Package/Stash/PP.pm"} = <<'PACKAGE_STASH_PP';
  package Package::Stash::PP;
  BEGIN {
    $Package::Stash::PP::AUTHORITY = 'cpan:DOY';
  }
  {
    $Package::Stash::PP::VERSION = '0.35';
  }
  use strict;
  use warnings;
  # ABSTRACT: pure perl implementation of the Package::Stash API
  
  use B;
  use Carp qw(confess);
  use Scalar::Util qw(blessed reftype weaken);
  use Symbol;
  # before 5.12, assigning to the ISA glob would make it lose its magical ->isa
  # powers
  use constant BROKEN_ISA_ASSIGNMENT => ($] < 5.012);
  # before 5.10, stashes don't ever seem to drop to a refcount of zero, so
  # weakening them isn't helpful
  use constant BROKEN_WEAK_STASH     => ($] < 5.010);
  # before 5.10, the scalar slot was always treated as existing if the
  # glob existed
  use constant BROKEN_SCALAR_INITIALIZATION => ($] < 5.010);
  # add_method on anon stashes triggers rt.perl #1804 otherwise
  # fixed in perl commit v5.13.3-70-g0fe688f
  use constant BROKEN_GLOB_ASSIGNMENT => ($] < 5.013004);
  # pre-5.10, ->isa lookups were cached in the ::ISA::CACHE:: slot
  use constant HAS_ISA_CACHE => ($] < 5.010);
  
  
  sub new {
      my $class = shift;
      my ($package) = @_;
  
      if (!defined($package) || (ref($package) && reftype($package) ne 'HASH')) {
          confess "Package::Stash->new must be passed the name of the "
                . "package to access";
      }
      elsif (ref($package) && reftype($package) eq 'HASH') {
          confess "The PP implementation of Package::Stash does not support "
                . "anonymous stashes before perl 5.14"
              if BROKEN_GLOB_ASSIGNMENT;
  
          return bless {
              'namespace' => $package,
          }, $class;
      }
      elsif ($package =~ /\A[0-9A-Z_a-z]+(?:::[0-9A-Z_a-z]+)*\z/) {
          return bless {
              'package' => $package,
          }, $class;
      }
      else {
          confess "$package is not a module name";
      }
  
  }
  
  sub name {
      confess "Can't call name as a class method"
          unless blessed($_[0]);
      confess "Can't get the name of an anonymous package"
          unless defined($_[0]->{package});
      return $_[0]->{package};
  }
  
  sub namespace {
      confess "Can't call namespace as a class method"
          unless blessed($_[0]);
  
      if (BROKEN_WEAK_STASH) {
          no strict 'refs';
          return \%{$_[0]->name . '::'};
      }
      else {
          return $_[0]->{namespace} if defined $_[0]->{namespace};
  
          {
              no strict 'refs';
              $_[0]->{namespace} = \%{$_[0]->name . '::'};
          }
  
          weaken($_[0]->{namespace});
  
          return $_[0]->{namespace};
      }
  }
  
  sub _is_anon {
      return !defined $_[0]->{package};
  }
  
  {
      my %SIGIL_MAP = (
          '$' => 'SCALAR',
          '@' => 'ARRAY',
          '%' => 'HASH',
          '&' => 'CODE',
          ''  => 'IO',
      );
  
      sub _deconstruct_variable_name {
          my ($self, $variable) = @_;
  
          my @ret;
          if (ref($variable) eq 'HASH') {
              @ret = @{$variable}{qw[name sigil type]};
          }
          else {
              (defined $variable && length $variable)
                  || confess "You must pass a variable name";
  
              my $sigil = substr($variable, 0, 1, '');
  
              if (exists $SIGIL_MAP{$sigil}) {
                  @ret = ($variable, $sigil, $SIGIL_MAP{$sigil});
              }
              else {
                  @ret = ("${sigil}${variable}", '', $SIGIL_MAP{''});
              }
          }
  
          # XXX in pure perl, this will access things in inner packages,
          # in xs, this will segfault - probably look more into this at
          # some point
          ($ret[0] !~ /::/)
              || confess "Variable names may not contain ::";
  
          return @ret;
      }
  }
  
  sub _valid_for_type {
      my $self = shift;
      my ($value, $type) = @_;
      if ($type eq 'HASH' || $type eq 'ARRAY'
       || $type eq 'IO'   || $type eq 'CODE') {
          return reftype($value) eq $type;
      }
      else {
          my $ref = reftype($value);
          return !defined($ref) || $ref eq 'SCALAR' || $ref eq 'REF' || $ref eq 'LVALUE' || $ref eq 'REGEXP' || $ref eq 'VSTRING';
      }
  }
  
  sub add_symbol {
      my ($self, $variable, $initial_value, %opts) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      if (@_ > 2) {
          $self->_valid_for_type($initial_value, $type)
              || confess "$initial_value is not of type $type";
  
          # cheap fail-fast check for PERLDBf_SUBLINE and '&'
          if ($^P and $^P & 0x10 && $sigil eq '&') {
              my $filename = $opts{filename};
              my $first_line_num = $opts{first_line_num};
  
              (undef, $filename, $first_line_num) = caller
                  if not defined $filename;
  
              my $last_line_num = $opts{last_line_num} || ($first_line_num ||= 0);
  
              # http://perldoc.perl.org/perldebguts.html#Debugger-Internals
              $DB::sub{$self->name . '::' . $name} = "$filename:$first_line_num-$last_line_num";
          }
      }
  
      if (BROKEN_GLOB_ASSIGNMENT) {
          if (@_ > 2) {
              no strict 'refs';
              no warnings 'redefine';
              *{ $self->name . '::' . $name } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              no strict 'refs';
              if (BROKEN_ISA_ASSIGNMENT && $name eq 'ISA') {
                  *{ $self->name . '::' . $name };
              }
              else {
                  my $undef = $self->_undef_ref_for_type($type);
                  *{ $self->name . '::' . $name } = $undef;
              }
          }
      }
      else {
          my $namespace = $self->namespace;
          {
              # using glob aliasing instead of Symbol::gensym, because otherwise,
              # magic doesn't get applied properly.
              # see <20120710063744.19360.qmail@lists-nntp.develooper.com> on p5p
              local *__ANON__:: = $namespace;
              no strict 'refs';
              no warnings 'void';
              *{"__ANON__::$name"};
          }
  
          if (@_ > 2) {
              no warnings 'redefine';
              *{ $namespace->{$name} } = ref $initial_value
                  ? $initial_value : \$initial_value;
          }
          else {
              return if BROKEN_ISA_ASSIGNMENT && $name eq 'ISA';
              *{ $namespace->{$name} } = $self->_undef_ref_for_type($type);
          }
      }
  }
  
  sub _undef_ref_for_type {
      my $self = shift;
      my ($type) = @_;
  
      if ($type eq 'ARRAY') {
          return [];
      }
      elsif ($type eq 'HASH') {
          return {};
      }
      elsif ($type eq 'SCALAR') {
          return \undef;
      }
      elsif ($type eq 'IO') {
          return Symbol::geniosym;
      }
      elsif ($type eq 'CODE') {
          confess "Don't know how to vivify CODE variables";
      }
      else {
          confess "Unknown type $type in vivication";
      }
  }
  
  sub remove_glob {
      my ($self, $name) = @_;
      delete $self->namespace->{$name};
  }
  
  sub has_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      return unless exists $namespace->{$name};
  
      my $entry_ref = \$namespace->{$name};
      if (reftype($entry_ref) eq 'GLOB') {
          if ($type eq 'SCALAR') {
              if (BROKEN_SCALAR_INITIALIZATION) {
                  return defined ${ *{$entry_ref}{$type} };
              }
              else {
                  my $sv = B::svref_2object($entry_ref)->SV;
                  return $sv->isa('B::SV')
                      || ($sv->isa('B::SPECIAL')
                       && $B::specialsv_name[$$sv] ne 'Nullsv');
              }
          }
          else {
              return defined *{$entry_ref}{$type};
          }
      }
      else {
          # a symbol table entry can be -1 (stub), string (stub with prototype),
          # or reference (constant)
          return $type eq 'CODE';
      }
  }
  
  sub get_symbol {
      my ($self, $variable, %opts) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      my $namespace = $self->namespace;
  
      if (!exists $namespace->{$name}) {
          if ($opts{vivify}) {
              $self->add_symbol($variable);
          }
          else {
              return undef;
          }
      }
  
      my $entry_ref = \$namespace->{$name};
  
      if (ref($entry_ref) eq 'GLOB') {
          return *{$entry_ref}{$type};
      }
      else {
          if ($type eq 'CODE') {
              if (BROKEN_GLOB_ASSIGNMENT || !$self->_is_anon) {
                  no strict 'refs';
                  return \&{ $self->name . '::' . $name };
              }
  
              # XXX we should really be able to support arbitrary anonymous
              # stashes here... (not just via Package::Anon)
              if (blessed($namespace) && $namespace->isa('Package::Anon')) {
                  # ->can will call gv_init for us, which inflates the glob
                  # don't know how to do this in general
                  $namespace->bless(\(my $foo))->can($name);
              }
              else {
                  confess "Don't know how to inflate a " . ref($entry_ref)
                        . " into a full coderef (perhaps you could use"
                        . " Package::Anon instead of a bare stash?)"
              }
  
              return *{ $namespace->{$name} }{CODE};
          }
          else {
              return undef;
          }
      }
  }
  
  sub get_or_add_symbol {
      my $self = shift;
      $self->get_symbol(@_, vivify => 1);
  }
  
  sub remove_symbol {
      my ($self, $variable) = @_;
  
      my ($name, $sigil, $type) = $self->_deconstruct_variable_name($variable);
  
      # FIXME:
      # no doubt this is grossly inefficient and
      # could be done much easier and faster in XS
  
      my %desc = (
          SCALAR => { sigil => '$', type => 'SCALAR', name => $name },
          ARRAY  => { sigil => '@', type => 'ARRAY',  name => $name },
          HASH   => { sigil => '%', type => 'HASH',   name => $name },
          CODE   => { sigil => '&', type => 'CODE',   name => $name },
          IO     => { sigil => '',  type => 'IO',     name => $name },
      );
      confess "This should never ever ever happen" if !$desc{$type};
  
      my @types_to_store = grep { $type ne $_ && $self->has_symbol($desc{$_}) }
                                keys %desc;
      my %values = map { $_, $self->get_symbol($desc{$_}) } @types_to_store;
  
      $values{SCALAR} = $self->get_symbol($desc{SCALAR})
        if !defined $values{SCALAR}
          && $type ne 'SCALAR'
          && BROKEN_SCALAR_INITIALIZATION;
  
      $self->remove_glob($name);
  
      $self->add_symbol($desc{$_} => $values{$_})
          for grep { defined $values{$_} } keys %values;
  }
  
  sub list_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      if (HAS_ISA_CACHE) {
          return grep { $_ ne '::ISA::CACHE::' } keys %{$namespace}
              unless defined $type_filter;
      }
      else {
          return keys %{$namespace}
              unless defined $type_filter;
      }
  
      # NOTE:
      # or we can filter based on
      # type (SCALAR|ARRAY|HASH|CODE)
      if ($type_filter eq 'CODE') {
          return grep {
              # any non-typeglob in the symbol table is a constant or stub
              ref(\$namespace->{$_}) ne 'GLOB'
                  # regular subs are stored in the CODE slot of the typeglob
                  || defined(*{$namespace->{$_}}{CODE})
          } keys %{$namespace};
      }
      elsif ($type_filter eq 'SCALAR') {
          return grep {
              !(HAS_ISA_CACHE && $_ eq '::ISA::CACHE::') &&
              (BROKEN_SCALAR_INITIALIZATION
                  ? (ref(\$namespace->{$_}) eq 'GLOB'
                        && defined(${*{$namespace->{$_}}{'SCALAR'}}))
                  : (do {
                        my $entry = \$namespace->{$_};
                        ref($entry) eq 'GLOB'
                            && B::svref_2object($entry)->SV->isa('B::SV')
                    }))
          } keys %{$namespace};
      }
      else {
          return grep {
              ref(\$namespace->{$_}) eq 'GLOB'
                  && defined(*{$namespace->{$_}}{$type_filter})
          } keys %{$namespace};
      }
  }
  
  sub get_all_symbols {
      my ($self, $type_filter) = @_;
  
      my $namespace = $self->namespace;
      return { %{$namespace} } unless defined $type_filter;
  
      return {
          map { $_ => $self->get_symbol({name => $_, type => $type_filter}) }
              $self->list_all_symbols($type_filter)
      }
  }
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash::PP - pure perl implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.35
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash> implemented in pure perl, for those without a compiler or who would like to use this inline in scripts.
  
  =head1 BUGS
  
  =over 4
  
  =item * remove_symbol also replaces the associated typeglob
  
  This can cause unexpected behavior when doing manipulation at compile time -
  removing subroutines will still allow them to be called from within the package
  as subroutines (although they will not be available as methods). This can be
  considered a feature in some cases (this is how L<namespace::clean> works, for
  instance), but should not be relied upon - use C<remove_glob> directly if you
  want this behavior.
  
  =item * Some minor memory leaks
  
  The pure perl implementation has a couple minor memory leaks (see the TODO
  tests in t/20-leaks.t) that I'm having a hard time tracking down - these may be
  core perl bugs, it's hard to tell.
  
  =back
  
  Please report any bugs through RT: email
  C<bug-package-stash at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Mostly copied from code from L<Class::MOP::Package>, by Stevan Little and the
  Moose Cabal.
  
  =for Pod::Coverage BROKEN_ISA_ASSIGNMENT
  add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy@tozt.net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
PACKAGE_STASH_PP

$fatpacked{"Path/Class.pm"} = <<'PATH_CLASS';
  use strict;
  
  package Path::Class;
  {
    $Path::Class::VERSION = '0.32';
  }
  
  {
    ## no critic
    no strict 'vars';
    @ISA = qw(Exporter);
    @EXPORT    = qw(file dir);
    @EXPORT_OK = qw(file dir foreign_file foreign_dir tempdir);
  }
  
  use Exporter;
  use Path::Class::File;
  use Path::Class::Dir;
  use File::Temp ();
  
  sub file { Path::Class::File->new(@_) }
  sub dir  { Path::Class::Dir ->new(@_) }
  sub foreign_file { Path::Class::File->new_foreign(@_) }
  sub foreign_dir  { Path::Class::Dir ->new_foreign(@_) }
  sub tempdir { Path::Class::Dir->new(File::Temp::tempdir(@_)) }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class - Cross-platform path specification manipulation
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class;
    
    my $dir  = dir('foo', 'bar');       # Path::Class::Dir object
    my $file = file('bob', 'file.txt'); # Path::Class::File object
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    # Stringifies to 'bob/file.txt' on Unix, 'bob\file.txt' on Windows
    print "file: $file\n";
    
    my $subdir  = $dir->subdir('baz');  # foo/bar/baz
    my $parent  = $subdir->parent;      # foo/bar
    my $parent2 = $parent->parent;      # foo
    
    my $dir2 = $file->dir;              # bob
  
    # Work with foreign paths
    use Path::Class qw(foreign_file foreign_dir);
    my $file = foreign_file('Mac', ':foo:file.txt');
    print $file->dir;                   # :foo:
    print $file->as_foreign('Win32');   # foo\file.txt
    
    # Interact with the underlying filesystem:
    
    # $dir_handle is an IO::Dir object
    my $dir_handle = $dir->open or die "Can't read $dir: $!";
    
    # $file_handle is an IO::File object
    my $file_handle = $file->open($mode) or die "Can't read $file: $!";
  
  =head1 DESCRIPTION
  
  C<Path::Class> is a module for manipulation of file and directory
  specifications (strings describing their locations, like
  C<'/home/ken/foo.txt'> or C<'C:\Windows\Foo.txt'>) in a cross-platform
  manner.  It supports pretty much every platform Perl runs on,
  including Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.
  
  The well-known module L<File::Spec> also provides this service, but
  it's sort of awkward to use well, so people sometimes avoid it, or use
  it in a way that won't actually work properly on platforms
  significantly different than the ones they've tested their code on.
  
  In fact, C<Path::Class> uses C<File::Spec> internally, wrapping all
  the unsightly details so you can concentrate on your application code.
  Whereas C<File::Spec> provides functions for some common path
  manipulations, C<Path::Class> provides an object-oriented model of the
  world of path specifications and their underlying semantics.
  C<File::Spec> doesn't create any objects, and its classes represent
  the different ways in which paths must be manipulated on various
  platforms (not a very intuitive concept).  C<Path::Class> creates
  objects representing files and directories, and provides methods that
  relate them to each other.  For instance, the following C<File::Spec>
  code:
  
   my $absolute = File::Spec->file_name_is_absolute(
                    File::Spec->catfile( @dirs, $file )
                  );
  
  can be written using C<Path::Class> as
  
   my $absolute = Path::Class::File->new( @dirs, $file )->is_absolute;
  
  or even as 
  
   my $absolute = file( @dirs, $file )->is_absolute;
  
  Similar readability improvements should happen all over the place when
  using C<Path::Class>.
  
  Using C<Path::Class> can help solve real problems in your code too -
  for instance, how many people actually take the "volume" (like C<C:>
  on Windows) into account when writing C<File::Spec>-using code?  I
  thought not.  But if you use C<Path::Class>, your file and directory objects
  will know what volumes they refer to and do the right thing.
  
  The guts of the C<Path::Class> code live in the L<Path::Class::File>
  and L<Path::Class::Dir> modules, so please see those
  modules' documentation for more details about how to use them.
  
  =head2 EXPORT
  
  The following functions are exported by default.
  
  =over 4
  
  =item file
  
  A synonym for C<< Path::Class::File->new >>.
  
  =item dir
  
  A synonym for C<< Path::Class::Dir->new >>.
  
  =back
  
  If you would like to prevent their export, you may explicitly pass an
  empty list to perl's C<use>, i.e. C<use Path::Class ()>.
  
  The following are exported only on demand.
  
  =over 4
  
  =item foreign_file
  
  A synonym for C<< Path::Class::File->new_foreign >>.
  
  =item foreign_dir
  
  A synonym for C<< Path::Class::Dir->new_foreign >>.
  
  =item tempdir
  
  Create a new Path::Class::Dir instance pointed to temporary directory.
  
    my $temp = Path::Class::tempdir(CLEANUP => 1);
  
  A synonym for C<< Path::Class::Dir->new(File::Temp::tempdir(@_)) >>.
  
  =back
  
  =head1 Notes on Cross-Platform Compatibility
  
  Although it is much easier to write cross-platform-friendly code with
  this module than with C<File::Spec>, there are still some issues to be
  aware of.
  
  =over 4
  
  =item *
  
  On some platforms, notably VMS and some older versions of DOS (I think),
  all filenames must have an extension.  Thus if you create a file
  called F<foo/bar> and then ask for a list of files in the directory
  F<foo>, you may find a file called F<bar.> instead of the F<bar> you
  were expecting.  Thus it might be a good idea to use an extension in
  the first place.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, KWILLIAMS@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  L<Path::Class::Dir>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS

$fatpacked{"Path/Class/Dir.pm"} = <<'PATH_CLASS_DIR';
  use strict;
  
  package Path::Class::Dir;
  {
    $Path::Class::Dir::VERSION = '0.32';
  }
  
  use Path::Class::File;
  use Carp();
  use base qw(Path::Class::Entity);
  
  use IO::Dir ();
  use File::Path ();
  use File::Temp ();
  use Scalar::Util ();
  
  # updir & curdir on the local machine, for screening them out in
  # children().  Note that they don't respect 'foreign' semantics.
  my $Updir  = __PACKAGE__->_spec->updir;
  my $Curdir = __PACKAGE__->_spec->curdir;
  
  sub new {
    my $self = shift->SUPER::new();
  
    # If the only arg is undef, it's probably a mistake.  Without this
    # special case here, we'd return the root directory, which is a
    # lousy thing to do to someone when they made a mistake.  Return
    # undef instead.
    return if @_==1 && !defined($_[0]);
  
    my $s = $self->_spec;
    
    my $first = (@_ == 0     ? $s->curdir :
  	       $_[0] eq '' ? (shift, $s->rootdir) :
  	       shift()
  	      );
    
    $self->{dirs} = [];
    if ( Scalar::Util::blessed($first) && $first->isa("Path::Class::Dir") ) {
      $self->{volume} = $first->{volume};
      push @{$self->{dirs}}, @{$first->{dirs}};
    }
    else {
      ($self->{volume}, my $dirs) = $s->splitpath( $s->canonpath("$first") , 1);
      push @{$self->{dirs}}, $dirs eq $s->rootdir ? "" : $s->splitdir($dirs);
    }
  
    push @{$self->{dirs}}, map {
      Scalar::Util::blessed($_) && $_->isa("Path::Class::Dir")
        ? @{$_->{dirs}}
        : $s->splitdir($_)
    } @_;
  
  
    return $self;
  }
  
  sub file_class { "Path::Class::File" }
  
  sub is_dir { 1 }
  
  sub as_foreign {
    my ($self, $type) = @_;
  
    my $foreign = do {
      local $self->{file_spec_class} = $self->_spec_class($type);
      $self->SUPER::new;
    };
    
    # Clone internal structure
    $foreign->{volume} = $self->{volume};
    my ($u, $fu) = ($self->_spec->updir, $foreign->_spec->updir);
    $foreign->{dirs} = [ map {$_ eq $u ? $fu : $_} @{$self->{dirs}}];
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    my $s = $self->_spec;
    return $s->catpath($self->{volume},
  		     $s->catdir(@{$self->{dirs}}),
  		     '');
  }
  
  sub volume { shift()->{volume} }
  
  sub file {
    local $Path::Class::Foreign = $_[0]->{file_spec_class} if $_[0]->{file_spec_class};
    return $_[0]->file_class->new(@_);
  }
  
  sub basename { shift()->{dirs}[-1] }
  
  sub dir_list {
    my $self = shift;
    my $d = $self->{dirs};
    return @$d unless @_;
    
    my $offset = shift;
    if ($offset < 0) { $offset = $#$d + $offset + 1 }
    
    return wantarray ? @$d[$offset .. $#$d] : $d->[$offset] unless @_;
    
    my $length = shift;
    if ($length < 0) { $length = $#$d + $length + 1 - $offset }
    return @$d[$offset .. $length + $offset - 1];
  }
  
  sub components {
    my $self = shift;
    return $self->dir_list(@_);
  }
  
  sub subdir {
    my $self = shift;
    return $self->new($self, @_);
  }
  
  sub parent {
    my $self = shift;
    my $dirs = $self->{dirs};
    my ($curdir, $updir) = ($self->_spec->curdir, $self->_spec->updir);
  
    if ($self->is_absolute) {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}} if @$dirs > 1;
      return $parent;
  
    } elsif ($self eq $curdir) {
      return $self->new($updir);
  
    } elsif (!grep {$_ ne $updir} @$dirs) {  # All updirs
      return $self->new($self, $updir); # Add one more
  
    } elsif (@$dirs == 1) {
      return $self->new($curdir);
  
    } else {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}};
      return $parent;
    }
  }
  
  sub relative {
    # File::Spec->abs2rel before version 3.13 returned the empty string
    # when the two paths were equal - work around it here.
    my $self = shift;
    my $rel = $self->_spec->abs2rel($self->stringify, @_);
    return $self->new( length $rel ? $rel : $self->_spec->curdir );
  }
  
  sub open  { IO::Dir->new(@_) }
  sub mkpath { File::Path::mkpath(shift()->stringify, @_) }
  sub rmtree { File::Path::rmtree(shift()->stringify, @_) }
  
  sub remove {
    rmdir( shift() );
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    my @children = $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse($callback, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    my @children = grep { $condition->($_) } $self->children;
    return $self->$callback(
      sub {
        my @inner_args = @_;
        return map { $_->traverse_if($callback, $condition, @inner_args) } @children;
      },
      @args
    );
  }
  
  sub recurse {
    my $self = shift;
    my %opts = (preorder => 1, depthfirst => 0, @_);
    
    my $callback = $opts{callback}
      or Carp::croak( "Must provide a 'callback' parameter to recurse()" );
    
    my @queue = ($self);
    
    my $visit_entry;
    my $visit_dir = 
      $opts{depthfirst} && $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            unshift @queue, $dir->children;
        }
      }
      : $opts{preorder}
      ? sub {
        my $dir = shift;
        my $ret = $callback->($dir);
        unless( ($ret||'') eq $self->PRUNE ) {
            push @queue, $dir->children;
        }
      }
      : sub {
        my $dir = shift;
        $visit_entry->($_) foreach $dir->children;
        $callback->($dir);
      };
    
    $visit_entry = sub {
      my $entry = shift;
      if ($entry->is_dir) { $visit_dir->($entry) } # Will call $callback
      else { $callback->($entry) }
    };
    
    while (@queue) {
      $visit_entry->( shift @queue );
    }
  }
  
  sub children {
    my ($self, %opts) = @_;
    
    my $dh = $self->open or Carp::croak( "Can't open directory $self: $!" );
    
    my @out;
    while (defined(my $entry = $dh->read)) {
      next if !$opts{all} && $self->_is_local_dot_dir($entry);
      next if ($opts{no_hidden} && $entry =~ /^\./);
      push @out, $self->file($entry);
      $out[-1] = $self->subdir($entry) if -d $out[-1];
    }
    return @out;
  }
  
  sub _is_local_dot_dir {
    my $self = shift;
    my $dir  = shift;
  
    return ($dir eq $Updir or $dir eq $Curdir);
  }
  
  sub next {
    my $self = shift;
    unless ($self->{dh}) {
      $self->{dh} = $self->open or Carp::croak( "Can't open directory $self: $!" );
    }
    
    my $next = $self->{dh}->read;
    unless (defined $next) {
      delete $self->{dh};
      ## no critic
      return undef;
    }
    
    # Figure out whether it's a file or directory
    my $file = $self->file($next);
    $file = $self->subdir($next) if -d $file;
    return $file;
  }
  
  sub subsumes {
    my ($self, $other) = @_;
    die "No second entity given to subsumes()" unless $other;
    
    $other = $self->new($other) unless UNIVERSAL::isa($other, __PACKAGE__);
    $other = $other->dir unless $other->is_dir;
    
    if ($self->is_absolute) {
      $other = $other->absolute;
    } elsif ($other->is_absolute) {
      $self = $self->absolute;
    }
  
    $self = $self->cleanup;
    $other = $other->cleanup;
  
    if ($self->volume) {
      return 0 unless $other->volume eq $self->volume;
    }
  
    # The root dir subsumes everything (but ignore the volume because
    # we've already checked that)
    return 1 if "@{$self->{dirs}}" eq "@{$self->new('')->{dirs}}";
    
    my $i = 0;
    while ($i <= $#{ $self->{dirs} }) {
      return 0 if $i > $#{ $other->{dirs} };
      return 0 if $self->{dirs}[$i] ne $other->{dirs}[$i];
      $i++;
    }
    return 1;
  }
  
  sub contains {
    my ($self, $other) = @_;
    return !!(-d $self and (-e $other or -l $other) and $self->subsumes($other));
  }
  
  sub tempfile {
    my $self = shift;
    return File::Temp::tempfile(@_, DIR => $self->stringify);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Dir - Objects representing directories
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class qw(dir);  # Export a short constructor
    
    my $dir = dir('foo', 'bar');       # Path::Class::Dir object
    my $dir = Path::Class::Dir->new('foo', 'bar');  # Same thing
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    if ($dir->is_absolute) { ... }
    if ($dir->is_relative) { ... }
    
    my $v = $dir->volume; # Could be 'C:' on Windows, empty string
                          # on Unix, 'Macintosh HD:' on Mac OS
    
    $dir->cleanup; # Perform logical cleanup of pathname
    $dir->resolve; # Perform physical cleanup of pathname
    
    my $file = $dir->file('file.txt'); # A file in this directory
    my $subdir = $dir->subdir('george'); # A subdirectory
    my $parent = $dir->parent; # The parent directory, 'foo'
    
    my $abs = $dir->absolute; # Transform to absolute path
    my $rel = $abs->relative; # Transform to relative path
    my $rel = $abs->relative('/foo'); # Relative to /foo
    
    print $dir->as_foreign('Mac');   # :foo:bar:
    print $dir->as_foreign('Win32'); #  foo\bar
  
    # Iterate with IO::Dir methods:
    my $handle = $dir->open;
    while (my $file = $handle->read) {
      $file = $dir->file($file);  # Turn into Path::Class::File object
      ...
    }
    
    # Iterate with Path::Class methods:
    while (my $file = $dir->next) {
      # $file is a Path::Class::File or Path::Class::Dir object
      ...
    }
  
  
  =head1 DESCRIPTION
  
  The C<Path::Class::Dir> class contains functionality for manipulating
  directory names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )
  
  =item $dir = dir( <dir1>, <dir2>, ... )
  
  Creates a new C<Path::Class::Dir> object and returns it.  The
  arguments specify names of directories which will be joined to create
  a single directory object.  A volume may also be specified as the
  first argument, or as part of the first argument.  You can use
  platform-neutral syntax:
  
    my $dir = dir( 'foo', 'bar', 'baz' );
  
  or platform-native syntax:
  
    my $dir = dir( 'foo/bar/baz' );
  
  or a mixture of the two:
  
    my $dir = dir( 'foo/bar', 'baz' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $dir = dir( '/var/tmp' );
  
  or use an empty string as the first argument:
  
    my $dir = dir( '', 'var', 'tmp' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place (many non-Unix platforms don't have a notion of a "root
  directory"), so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly natural,
  because paths like this may come from config files, user input, or
  whatever.
  
  As a special case, since it doesn't otherwise mean anything useful and
  it's convenient to define this way, C<< Path::Class::Dir->new() >> (or
  C<dir()>) refers to the current directory (C<< File::Spec->curdir >>).
  To get the current directory as an absolute path, do C<<
  dir()->absolute >>.
  
  Finally, as another special case C<dir(undef)> will return undef,
  since that's usually an accident on the part of the caller, and
  returning the root directory would be a nasty surprise just asking for
  trouble a few lines later.
  
  =item $dir->stringify
  
  This method is called internally when a C<Path::Class::Dir> object is
  used in a string context, so the following are equivalent:
  
    $string = $dir->stringify;
    $string = "$dir";
  
  =item $dir->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the directory object, if any.  Otherwise, returns the empty
  string.
  
  =item $dir->basename
  
  Returns the last directory name of the path as a string.
  
  =item $dir->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, L<Path::Class::File> objects always
  return false, and C<Path::Class::Dir> objects always return true.
  
  =item $dir->is_absolute
  
  Returns true or false depending on whether the directory refers to an
  absolute path specifier (like C</usr/local> or C<\Windows>).
  
  =item $dir->is_relative
  
  Returns true or false depending on whether the directory refers to a
  relative path specifier (like C<lib/foo> or C<./dir>).
  
  =item $dir->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/./foo')->cleanup;
    # $dir now represents '/foo/baz/foo';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/../foo')->resolve;
    # $dir now represents '/foo/foo', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $file = $dir->file( <dir1>, <dir2>, ..., <file> )
  
  Returns a L<Path::Class::File> object representing an entry in C<$dir>
  or one of its subdirectories.  Internally, this just calls C<<
  Path::Class::File->new( @_ ) >>.
  
  =item $subdir = $dir->subdir( <dir1>, <dir2>, ... )
  
  Returns a new C<Path::Class::Dir> object representing a subdirectory
  of C<$dir>.
  
  =item $parent = $dir->parent
  
  Returns the parent directory of C<$dir>.  Note that this is the
  I<logical> parent, not necessarily the physical parent.  It really
  means we just chop off entries from the end of the directory list
  until we cain't chop no more.  If the directory is relative, we start
  using the relative forms of parent directories.
  
  The following code demonstrates the behavior on absolute and relative
  directories:
  
    $dir = dir('/foo/bar');
    for (1..6) {
      print "Absolute: $dir\n";
      $dir = $dir->parent;
    }
    
    $dir = dir('foo/bar');
    for (1..6) {
      print "Relative: $dir\n";
      $dir = $dir->parent;
    }
    
    ########### Output on Unix ################
    Absolute: /foo/bar
    Absolute: /foo
    Absolute: /
    Absolute: /
    Absolute: /
    Absolute: /
    Relative: foo/bar
    Relative: foo
    Relative: .
    Relative: ..
    Relative: ../..
    Relative: ../../..
  
  =item @list = $dir->children
  
  Returns a list of L<Path::Class::File> and/or C<Path::Class::Dir>
  objects listed in this directory, or in scalar context the number of
  such objects.  Obviously, it is necessary for C<$dir> to
  exist and be readable in order to find its children.
  
  Note that the children are returned as subdirectories of C<$dir>,
  i.e. the children of F<foo> will be F<foo/bar> and F<foo/baz>, not
  F<bar> and F<baz>.
  
  Ordinarily C<children()> will not include the I<self> and I<parent>
  entries C<.> and C<..> (or their equivalents on non-Unix systems),
  because that's like I'm-my-own-grandpa business.  If you do want all
  directory entries including these special ones, pass a true value for
  the C<all> parameter:
  
    @c = $dir->children(); # Just the children
    @c = $dir->children(all => 1); # All entries
  
  In addition, there's a C<no_hidden> parameter that will exclude all
  normally "hidden" entries - on Unix this means excluding all entries
  that begin with a dot (C<.>):
  
    @c = $dir->children(no_hidden => 1); # Just normally-visible entries
  
  
  =item $abs = $dir->absolute
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as an
  absolute path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $dir->relative
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $boolean = $dir->subsumes($other)
  
  Returns true if this directory spec subsumes the other spec, and false
  otherwise.  Think of "subsumes" as "contains", but we only look at the
  I<specs>, not whether C<$dir> actually contains C<$other> on the
  filesystem.
  
  The C<$other> argument may be a C<Path::Class::Dir> object, a
  L<Path::Class::File> object, or a string.  In the latter case, we
  assume it's a directory.
  
    # Examples:
    dir('foo/bar' )->subsumes(dir('foo/bar/baz'))  # True
    dir('/foo/bar')->subsumes(dir('/foo/bar/baz')) # True
    dir('foo/bar' )->subsumes(dir('bar/baz'))      # False
    dir('/foo/bar')->subsumes(dir('foo/bar'))      # False
  
  
  =item $boolean = $dir->contains($other)
  
  Returns true if this directory actually contains C<$other> on the
  filesystem.  C<$other> doesn't have to be a direct child of C<$dir>,
  it just has to be subsumed.
  
  =item $foreign = $dir->as_foreign($type)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::Dir->new_foreign($type, @args)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item @list = $dir->dir_list([OFFSET, [LENGTH]])
  
  Returns the list of strings internally representing this directory
  structure.  Each successive member of the list is understood to be an
  entry in its predecessor's directory list.  By contract, C<<
  Path::Class->new( $dir->dir_list ) >> should be equivalent to C<$dir>.
  
  The semantics of this method are similar to Perl's C<splice> or
  C<substr> functions; they return C<LENGTH> elements starting at
  C<OFFSET>.  If C<LENGTH> is omitted, returns all the elements starting
  at C<OFFSET> up to the end of the list.  If C<LENGTH> is negative,
  returns the elements from C<OFFSET> onward except for C<-LENGTH>
  elements at the end.  If C<OFFSET> is negative, it counts backward
  C<OFFSET> elements from the end of the list.  If C<OFFSET> and
  C<LENGTH> are both omitted, the entire list is returned.
  
  In a scalar context, C<dir_list()> with no arguments returns the
  number of entries in the directory list; C<dir_list(OFFSET)> returns
  the single element at that offset; C<dir_list(OFFSET, LENGTH)> returns
  the final element that would have been returned in a list context.
  
  =item $dir->components
  
  Identical to c<dir_list()>.  It exists because there's an analogous
  method C<dir_list()> in the C<Path::Class::File> class that also
  returns the basename string, so this method lets someone call
  C<components()> without caring whether the object is a file or a
  directory.
  
  =item $fh = $dir->open()
  
  Passes C<$dir> to C<< IO::Dir->open >> and returns the result as an
  L<IO::Dir> object.  If the opening fails, C<undef> is returned and
  C<$!> is set.
  
  =item $dir->mkpath($verbose, $mode)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::mkpath()
  >> and returns the result (a list of all directories created).
  
  =item $dir->rmtree($verbose, $cautious)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::rmtree()
  >> and returns the result (the number of files successfully deleted).
  
  =item $dir->remove()
  
  Removes the directory, which must be empty.  Returns a boolean value
  indicating whether or not the directory was successfully removed.
  This method is mainly provided for consistency with
  C<Path::Class::File>'s C<remove()> method.
  
  =item $dir->tempfile(...)
  
  An interface to L<File::Temp>'s C<tempfile()> function.  Just like
  that function, if you call this in a scalar context, the return value
  is the filehandle and the file is C<unlink>ed as soon as possible
  (which is immediately on Unix-like platforms).  If called in a list
  context, the return values are the filehandle and the filename.
  
  The given directory is passed as the C<DIR> parameter.
  
  Here's an example of pretty good usage which doesn't allow race
  conditions, won't leave yucky tempfiles around on your filesystem,
  etc.:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some data...\n";
    seek($fh, 0, 0);
    while (<$fh>) { do something... }
  
  Or in combination with a C<fork>:
  
    my $fh = $dir->tempfile;
    print $fh "Here's some more data...\n";
    seek($fh, 0, 0);
    if ($pid=fork()) {
      wait;
    } else {
      something($_) while <$fh>;
    }
  
  
  =item $dir_or_file = $dir->next()
  
  A convenient way to iterate through directory contents.  The first
  time C<next()> is called, it will C<open()> the directory and read the
  first item from it, returning the result as a C<Path::Class::Dir> or
  L<Path::Class::File> object (depending, of course, on its actual
  type).  Each subsequent call to C<next()> will simply iterate over the
  directory's contents, until there are no more items in the directory,
  and then the undefined value is returned.  For example, to iterate
  over all the regular files in a directory:
  
    while (my $file = $dir->next) {
      next unless -f $file;
      my $fh = $file->open('r') or die "Can't read $file: $!";
      ...
    }
  
  If an error occurs when opening the directory (for instance, it
  doesn't exist or isn't readable), C<next()> will throw an exception
  with the value of C<$!>.
  
  =item $dir->traverse( sub { ... }, @args )
  
  Calls the given callback for the root, passing it a continuation
  function which, when called, will call this recursively on each of its
  children. The callback function should be of the form:
  
    sub {
      my ($child, $cont, @args) = @_;
      # ...
    }
  
  For instance, to calculate the number of files in a directory, you
  can do this:
  
    my $nfiles = $dir->traverse(sub {
      my ($child, $cont) = @_;
      return sum($cont->(), ($child->is_dir ? 0 : 1));
    });
  
  or to calculate the maximum depth of a directory:
  
    my $depth = $dir->traverse(sub {
      my ($child, $cont, $depth) = @_;
      return max($cont->($depth + 1), $depth);
    }, 0);
  
  You can also choose not to call the callback in certain situations:
  
    $dir->traverse(sub {
      my ($child, $cont) = @_;
      return if -l $child; # don't follow symlinks
      # do something with $child
      return $cont->();
    });
  
  =item $dir->traverse_if( sub { ... }, sub { ... }, @args )
  
  traverse with additional "should I visit this child" callback.
  Particularly useful in case examined tree contains inaccessible
  directories.
  
  Canonical example:
  
    $dir->traverse_if(
      sub {
         my ($child, $cont) = @_;
         # do something with $child
         return $cont->();
      }, 
      sub {
         my ($child) = @_;
         # Process only readable items
         return -r $child;
      });
  
  Second callback gets single parameter: child. Only children for
  which it returns true will be processed by the first callback.
  
  Remaining parameters are interpreted as in traverse, in particular
  C<traverse_if(callback, sub { 1 }, @args> is equivalent to
  C<traverse(callback, @args)>.
  
  =item $dir->recurse( callback => sub {...} )
  
  Iterates through this directory and all of its children, and all of
  its children's children, etc., calling the C<callback> subroutine for
  each entry.  This is a lot like what the L<File::Find> module does,
  and of course C<File::Find> will work fine on L<Path::Class> objects,
  but the advantage of the C<recurse()> method is that it will also feed
  your callback routine C<Path::Class> objects rather than just pathname
  strings.
  
  The C<recurse()> method requires a C<callback> parameter specifying
  the subroutine to invoke for each entry.  It will be passed the
  C<Path::Class> object as its first argument.
  
  C<recurse()> also accepts two boolean parameters, C<depthfirst> and
  C<preorder> that control the order of recursion.  The default is a
  preorder, breadth-first search, i.e. C<< depthfirst => 0, preorder => 1 >>.
  At the time of this writing, all combinations of these two parameters
  are supported I<except> C<< depthfirst => 0, preorder => 0 >>.
  
  C<callback> is normally not required to return any value. If it
  returns special constant C<Path::Class::Entity::PRUNE()> (more easily
  available as C<$item->PRUNE>),  no children of analyzed
  item will be analyzed (mostly as if you set C<$File::Find::prune=1>). Of course
  pruning is available only in C<preorder>, in postorder return value
  has no effect.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this directory and returns a
  C<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the directory the link points to.
  
  =item $class = $file->file_class()
  
  Returns the class which should be used to create file objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::File>, L<File::Spec>
  
  =cut
PATH_CLASS_DIR

$fatpacked{"Path/Class/Entity.pm"} = <<'PATH_CLASS_ENTITY';
  use strict;
  
  package Path::Class::Entity;
  {
    $Path::Class::Entity::VERSION = '0.32';
  }
  
  use File::Spec 3.26;
  use File::stat ();
  use Cwd;
  use Carp();
  
  use overload
    (
     q[""] => 'stringify',
     'bool' => 'boolify',
     fallback => 1,
    );
  
  sub new {
    my $from = shift;
    my ($class, $fs_class) = (ref($from)
  			    ? (ref $from, $from->{file_spec_class})
  			    : ($from, $Path::Class::Foreign));
    return bless {file_spec_class => $fs_class}, $class;
  }
  
  sub is_dir { 0 }
  
  sub _spec_class {
    my ($class, $type) = @_;
  
    die "Invalid system type '$type'" unless ($type) = $type =~ /^(\w+)$/;  # Untaint
    my $spec = "File::Spec::$type";
    ## no critic
    eval "require $spec; 1" or die $@;
    return $spec;
  }
  
  sub new_foreign {
    my ($class, $type) = (shift, shift);
    local $Path::Class::Foreign = $class->_spec_class($type);
    return $class->new(@_);
  }
  
  sub _spec { (ref($_[0]) && $_[0]->{file_spec_class}) || 'File::Spec' }
  
  sub boolify { 1 }
    
  sub is_absolute { 
    # 5.6.0 has a bug with regexes and stringification that's ticked by
    # file_name_is_absolute().  Help it along with an explicit stringify().
    $_[0]->_spec->file_name_is_absolute($_[0]->stringify) 
  }
  
  sub is_relative { ! $_[0]->is_absolute }
  
  sub cleanup {
    my $self = shift;
    my $cleaned = $self->new( $self->_spec->canonpath("$self") );
    %$self = %$cleaned;
    return $self;
  }
  
  sub resolve {
    my $self = shift;
    Carp::croak($! . " $self") unless -e $self;  # No such file or directory
    my $cleaned = $self->new( scalar Cwd::realpath($self->stringify) );
  
    # realpath() always returns absolute path, kind of annoying
    $cleaned = $cleaned->relative if $self->is_relative;
  
    %$self = %$cleaned;
    return $self;
  }
  
  sub absolute {
    my $self = shift;
    return $self if $self->is_absolute;
    return $self->new($self->_spec->rel2abs($self->stringify, @_));
  }
  
  sub relative {
    my $self = shift;
    return $self->new($self->_spec->abs2rel($self->stringify, @_));
  }
  
  sub stat  { File::stat::stat("$_[0]") }
  sub lstat { File::stat::lstat("$_[0]") }
  
  sub PRUNE { return \&PRUNE; }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Entity - Base class for files and directories
  
  =head1 VERSION
  
  version 0.32
  
  =head1 DESCRIPTION
  
  This class is the base class for C<Path::Class::File> and
  C<Path::Class::Dir>, it is not used directly by callers.
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class
  
  =cut
PATH_CLASS_ENTITY

$fatpacked{"Path/Class/File.pm"} = <<'PATH_CLASS_FILE';
  use strict;
  
  package Path::Class::File;
  {
    $Path::Class::File::VERSION = '0.32';
  }
  
  use Path::Class::Dir;
  use base qw(Path::Class::Entity);
  use Carp;
  
  use IO::File ();
  
  sub new {
    my $self = shift->SUPER::new;
    my $file = pop();
    my @dirs = @_;
  
    my ($volume, $dirs, $base) = $self->_spec->splitpath($file);
    
    if (length $dirs) {
      push @dirs, $self->_spec->catpath($volume, $dirs, '');
    }
    
    $self->{dir}  = @dirs ? $self->dir_class->new(@dirs) : undef;
    $self->{file} = $base;
    
    return $self;
  }
  
  sub dir_class { "Path::Class::Dir" }
  
  sub as_foreign {
    my ($self, $type) = @_;
    local $Path::Class::Foreign = $self->_spec_class($type);
    my $foreign = ref($self)->SUPER::new;
    $foreign->{dir} = $self->{dir}->as_foreign($type) if defined $self->{dir};
    $foreign->{file} = $self->{file};
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    return $self->{file} unless defined $self->{dir};
    return $self->_spec->catfile($self->{dir}->stringify, $self->{file});
  }
  
  sub dir {
    my $self = shift;
    return $self->{dir} if defined $self->{dir};
    return $self->dir_class->new($self->_spec->curdir);
  }
  BEGIN { *parent = \&dir; }
  
  sub volume {
    my $self = shift;
    return '' unless defined $self->{dir};
    return $self->{dir}->volume;
  }
  
  sub components {
    my $self = shift;
    die "Arguments are not currently supported by File->components()" if @_;
    return ($self->dir->components, $self->basename);
  }
  
  sub basename { shift->{file} }
  sub open  { IO::File->new(@_) }
  
  sub openr { $_[0]->open('r') or croak "Can't read $_[0]: $!"  }
  sub openw { $_[0]->open('w') or croak "Can't write to $_[0]: $!" }
  sub opena { $_[0]->open('a') or croak "Can't append to $_[0]: $!" }
  
  sub touch {
    my $self = shift;
    if (-e $self) {
      my $now = time();
      utime $now, $now, $self;
    } else {
      $self->openw;
    }
  }
  
  sub slurp {
    my ($self, %args) = @_;
    my $iomode = $args{iomode} || 'r';
    my $fh = $self->open($iomode) or croak "Can't read $self: $!";
  
    if (wantarray) {
      my @data = <$fh>;
      chomp @data if $args{chomped} or $args{chomp};
  
      if ( my $splitter = $args{split} ) {
        @data = map { [ split $splitter, $_ ] } @data;
      }
  
      return @data;
    }
  
  
    croak "'split' argument can only be used in list context"
      if $args{split};
  
  
    if ($args{chomped} or $args{chomp}) {
      chomp( my @data = <$fh> );
      return join '', @data;
    }
  
  
    local $/;
    return <$fh>;
  }
  
  sub spew {
      my $self = shift;
      my %args = splice( @_, 0, @_-1 );
  
      my $iomode = $args{iomode} || 'w';
      my $fh = $self->open( $iomode ) or croak "Can't write to $self: $!";
  
      if (ref($_[0]) eq 'ARRAY') {
          # Use old-school for loop to avoid copying.
          for (my $i = 0; $i < @{ $_[0] }; $i++) {
              print $fh $_[0]->[$i];
          }
      }
      else {
          print $fh $_[0];
      }
  
      return;
  }
  
  sub remove {
    my $file = shift->stringify;
    return unlink $file unless -e $file; # Sets $! correctly
    1 while unlink $file;
    return not -e $file;
  }
  
  sub traverse {
    my $self = shift;
    my ($callback, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  sub traverse_if {
    my $self = shift;
    my ($callback, $condition, @args) = @_;
    return $self->$callback(sub { () }, @args);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::File - Objects representing files
  
  =head1 VERSION
  
  version 0.32
  
  =head1 SYNOPSIS
  
    use Path::Class qw(file);  # Export a short constructor
    
    my $file = file('foo', 'bar.txt');  # Path::Class::File object
    my $file = Path::Class::File->new('foo', 'bar.txt'); # Same thing
    
    # Stringifies to 'foo/bar.txt' on Unix, 'foo\bar.txt' on Windows, etc.
    print "file: $file\n";
    
    if ($file->is_absolute) { ... }
    if ($file->is_relative) { ... }
    
    my $v = $file->volume; # Could be 'C:' on Windows, empty string
                           # on Unix, 'Macintosh HD:' on Mac OS
    
    $file->cleanup; # Perform logical cleanup of pathname
    $file->resolve; # Perform physical cleanup of pathname
    
    my $dir = $file->dir;  # A Path::Class::Dir object
    
    my $abs = $file->absolute; # Transform to absolute path
    my $rel = $file->relative; # Transform to relative path
  
  =head1 DESCRIPTION
  
  The C<Path::Class::File> class contains functionality for manipulating
  file names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $file = Path::Class::File->new( <dir1>, <dir2>, ..., <file> )
  
  =item $file = file( <dir1>, <dir2>, ..., <file> )
  
  Creates a new C<Path::Class::File> object and returns it.  The
  arguments specify the path to the file.  Any volume may also be
  specified as the first argument, or as part of the first argument.
  You can use platform-neutral syntax:
  
    my $file = file( 'foo', 'bar', 'baz.txt' );
  
  or platform-native syntax:
  
    my $file = file( 'foo/bar/baz.txt' );
  
  or a mixture of the two:
  
    my $file = file( 'foo/bar', 'baz.txt' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $file = file( '/var/tmp/foo.txt' );
  
  or use an empty string as the first argument:
  
    my $file = file( '', 'var', 'tmp', 'foo.txt' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place, so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly fine,
  because paths like this may come from config files, user input, or
  whatever.
  
  =item $file->stringify
  
  This method is called internally when a C<Path::Class::File> object is
  used in a string context, so the following are equivalent:
  
    $string = $file->stringify;
    $string = "$file";
  
  =item $file->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the object, if any.  Otherwise, returns the empty string.
  
  =item $file->basename
  
  Returns the name of the file as a string, without the directory
  portion (if any).
  
  =item $file->components
  
  Returns a list of the directory components of this file, followed by
  the basename.
  
  Note: unlike C<< $dir->components >>, this method currently does not
  accept any arguments to select which elements of the list will be
  returned.  It may do so in the future.  Currently it throws an
  exception if such arguments are present.
  
  
  =item $file->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, C<Path::Class::File> objects always
  return false, and L<Path::Class::Dir> objects always return true.
  
  =item $file->is_absolute
  
  Returns true or false depending on whether the file refers to an
  absolute path specifier (like C</usr/local/foo.txt> or C<\Windows\Foo.txt>).
  
  =item $file->is_relative
  
  Returns true or false depending on whether the file refers to a
  relative path specifier (like C<lib/foo.txt> or C<.\Foo.txt>).
  
  =item $file->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $file = file('/foo//baz/./foo.txt')->cleanup;
    # $file now represents '/foo/baz/foo.txt';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $file = file('/foo/baz/../foo.txt')->resolve;
    # $file now represents '/foo/foo.txt', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $dir = $file->dir
  
  Returns a C<Path::Class::Dir> object representing the directory
  containing this file.
  
  =item $dir = $file->parent
  
  A synonym for the C<dir()> method.
  
  =item $abs = $file->absolute
  
  Returns a C<Path::Class::File> object representing C<$file> as an
  absolute path.  An optional argument, given as either a string or a
  L<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $file->relative
  
  Returns a C<Path::Class::File> object representing C<$file> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $foreign = $file->as_foreign($type)
  
  Returns a C<Path::Class::File> object representing C<$file> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::File->new_foreign($type, @args)
  
  Returns a C<Path::Class::File> object representing a file as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item $fh = $file->open($mode, $permissions)
  
  Passes the given arguments, including C<$file>, to C<< IO::File->new >>
  (which in turn calls C<< IO::File->open >> and returns the result
  as an L<IO::File> object.  If the opening
  fails, C<undef> is returned and C<$!> is set.
  
  =item $fh = $file->openr()
  
  A shortcut for
  
   $fh = $file->open('r') or croak "Can't read $file: $!";
  
  =item $fh = $file->openw()
  
  A shortcut for
  
   $fh = $file->open('w') or croak "Can't write to $file: $!";
  
  =item $fh = $file->opena()
  
  A shortcut for
  
   $fh = $file->open('a') or croak "Can't append to $file: $!";
  
  =item $file->touch
  
  Sets the modification and access time of the given file to right now,
  if the file exists.  If it doesn't exist, C<touch()> will I<make> it
  exist, and - YES! - set its modification and access time to now.
  
  =item $file->slurp()
  
  In a scalar context, returns the contents of C<$file> in a string.  In
  a list context, returns the lines of C<$file> (according to how C<$/>
  is set) as a list.  If the file can't be read, this method will throw
  an exception.
  
  If you want C<chomp()> run on each line of the file, pass a true value
  for the C<chomp> or C<chomped> parameters:
  
    my @lines = $file->slurp(chomp => 1);
  
  You may also use the C<iomode> parameter to pass in an IO mode to use
  when opening the file, usually IO layers (though anything accepted by
  the MODE argument of C<open()> is accepted here).  Just make sure it's
  a I<reading> mode.
  
    my @lines = $file->slurp(iomode => ':crlf');
    my $lines = $file->slurp(iomode => '<:encoding(UTF-8)');
  
  The default C<iomode> is C<r>.
  
  Lines can also be automatically splitted, mimicking the perl command-line
  option C<-a> by using the C<split> parameter. If this parameter is used,
  each line will be returned as an array ref.
  
      my @lines = $file->slurp( chomp => 1, split => qr/\s*,\s*/ );
  
  The C<split> parameter can only be used in a list context.
  
  =item $file->spew( $content );
  
  The opposite of L</slurp>, this takes a list of strings and prints them
  to the file in write mode.  If the file can't be written to, this method
  will throw an exception.
  
  The content to be written can be either an array ref or a plain scalar.
  If the content is an array ref then each entry in the array will be
  written to the file.
  
  You may use the C<iomode> parameter to pass in an IO mode to use when
  opening the file, just like L</slurp> supports.
  
    $file->spew(iomode => '>:raw', $content);
  
  The default C<iomode> is C<w>.
  
  =item $file->traverse(sub { ... }, @args)
  
  Calls the given callback on $file. This doesn't do much on its own,
  but see the associated documentation in L<Path::Class::Dir>.
  
  =item $file->remove()
  
  This method will remove the file in a way that works well on all
  platforms, and returns a boolean value indicating whether or not the
  file was successfully removed.  
  
  C<remove()> is better than simply calling Perl's C<unlink()> function,
  because on some platforms (notably VMS) you actually may need to call
  C<unlink()> several times before all versions of the file are gone -
  the C<remove()> method handles this process for you.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this file and returns a
  L<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the file the link points to.
  
  =item $class = $file->dir_class()
  
  Returns the class which should be used to create directory objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  L<Path::Class>, L<Path::Class::Dir>, L<File::Spec>
  
  =cut
PATH_CLASS_FILE

$fatpacked{"Sub/Defer.pm"} = <<'SUB_DEFER';
  package Sub::Defer;
  
  use strictures 1;
  use base qw(Exporter);
  use Moo::_Utils;
  
  our @EXPORT = qw(defer_sub undefer_sub);
  
  our %DEFERRED;
  
  sub undefer_sub {
    my ($deferred) = @_;
    my ($target, $maker, $undeferred_ref) = @{
      $DEFERRED{$deferred}||return $deferred
    };
    ${$undeferred_ref} = my $made = $maker->();
  
    # make sure the method slot has not changed since deferral time
    if (defined($target) && $deferred eq *{_getglob($target)}{CODE}||'') {
      no warnings 'redefine';
  
      # I believe $maker already evals with the right package/name, so that
      # _install_coderef calls are not necessary --ribasushi
      *{_getglob($target)} = $made;
    }
    push @{$DEFERRED{$made} = $DEFERRED{$deferred}}, $made;
  
    return $made;
  }
  
  sub defer_info {
    my ($deferred) = @_;
    $DEFERRED{$deferred||''};
  }
  
  sub defer_sub {
    my ($target, $maker) = @_;
    my $undeferred;
    my $deferred_string;
    my $deferred = sub {
      goto &{$undeferred ||= undefer_sub($deferred_string)};
    };
    $deferred_string = "$deferred";
    $DEFERRED{$deferred} = [ $target, $maker, \$undeferred ];
    _install_coderef($target => $deferred) if defined $target;
    return $deferred;
  }
  
  1;
  
  =head1 NAME
  
  Sub::Defer - defer generation of subroutines until they are first called
  
  =head1 SYNOPSIS
  
   use Sub::Defer;
  
   my $deferred = defer_sub 'Logger::time_since_first_log' => sub {
      my $t = time;
      sub { time - $t };
   };
  
    Logger->time_since_first_log; # returns 0 and replaces itself
    Logger->time_since_first_log; # returns time - $t
  
  =head1 DESCRIPTION
  
  These subroutines provide the user with a convenient way to defer creation of
  subroutines and methods until they are first called.
  
  =head1 SUBROUTINES
  
  =head2 defer_sub
  
   my $coderef = defer_sub $name => sub { ... };
  
  This subroutine returns a coderef that encapsulates the provided sub - when
  it is first called, the provided sub is called and is -itself- expected to
  return a subroutine which will be goto'ed to on subsequent calls.
  
  If a name is provided, this also installs the sub as that name - and when
  the subroutine is undeferred will re-install the final version for speed.
  
  =head2 undefer_sub
  
   my $coderef = undefer_sub \&Foo::name;
  
  If the passed coderef has been L<deferred|/defer_sub> this will "undefer" it.
  If the passed coderef has not been deferred, this will just return it.
  
  If this is confusing, take a look at the example in the L</SYNOPSIS>.
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
SUB_DEFER

$fatpacked{"Sub/Exporter/Progressive.pm"} = <<'SUB_EXPORTER_PROGRESSIVE';
  package Sub::Exporter::Progressive;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.001010';
  
  use Carp 'croak';
  use List::Util 'first';
  
  sub import {
     my ($self, @args) = @_;
  
     my $inner_target = caller;
     my $export_data = sub_export_options($inner_target, @args);
  
     my $full_exporter;
     no strict 'refs';
     @{"${inner_target}::EXPORT_OK"} = @{$export_data->{exports}};
     @{"${inner_target}::EXPORT"} = @{$export_data->{defaults}};
     %{"${inner_target}::EXPORT_TAGS"} = %{$export_data->{tags}};
     *{"${inner_target}::import"} = sub {
        use strict;
        my ($self, @args) = @_;
  
        if (first { ref || !m/ \A [:-]? \w+ \z /xm } @args) {
           croak 'your usage of Sub::Exporter::Progressive requires Sub::Exporter to be installed'
              unless eval { require Sub::Exporter };
           $full_exporter ||= Sub::Exporter::build_exporter($export_data->{original});
  
           goto $full_exporter;
        } elsif (defined(my $num = first { !ref and m/^\d/ } @args)) {
           die "cannot export symbols with a leading digit: '$num'";
        } else {
           require Exporter;
           s/ \A - /:/xm for @args;
           @_ = ($self, @args);
           goto \&Exporter::import;
        }
     };
     return;
  }
  
  my $too_complicated = <<'DEATH';
  You are using Sub::Exporter::Progressive, but the features your program uses from
  Sub::Exporter cannot be implemented without Sub::Exporter, so you might as well
  just use vanilla Sub::Exporter
  DEATH
  
  sub sub_export_options {
     my ($inner_target, $setup, $options) = @_;
  
     my @exports;
     my @defaults;
     my %tags;
  
     if ($setup eq '-setup') {
        my %options = %$options;
  
        OPTIONS:
        for my $opt (keys %options) {
           if ($opt eq 'exports') {
  
              croak $too_complicated if ref $options{exports} ne 'ARRAY';
              @exports = @{$options{exports}};
              croak $too_complicated if first { ref } @exports;
  
           } elsif ($opt eq 'groups') {
              %tags = %{$options{groups}};
              for my $tagset (values %tags) {
                 croak $too_complicated if first { / \A - (?! all \b ) /x || ref } @{$tagset};
              }
              @defaults = @{$tags{default} || [] };
           } else {
              croak $too_complicated;
           }
        }
        @{$_} = map { / \A  [:-] all \z /x ? @exports : $_ } @{$_} for \@defaults, values %tags;
        $tags{all} ||= [ @exports ];
        my %exports = map { $_ => 1 } @exports;
        my @errors = grep { not $exports{$_} } @defaults;
        croak join(', ', @errors) . " is not exported by the $inner_target module\n" if @errors;
     }
  
     return {
        exports => \@exports,
        defaults => \@defaults,
        original => $options,
        tags => \%tags,
     };
  }
  
  1;
  
  =encoding utf8
  
  =head1 NAME
  
  Sub::Exporter::Progressive - Only use Sub::Exporter if you need it
  
  =head1 SYNOPSIS
  
   package Syntax::Keyword::Gather;
  
   use Sub::Exporter::Progressive -setup => {
     exports => [qw( break gather gathered take )],
     groups => {
       defaults => [qw( break gather gathered take )],
     },
   };
  
   # elsewhere
  
   # uses Exporter for speed
   use Syntax::Keyword::Gather;
  
   # somewhere else
  
   # uses Sub::Exporter for features
   use Syntax::Keyword::Gather 'gather', take => { -as => 'grab' };
  
  =head1 DESCRIPTION
  
  L<Sub::Exporter> is an incredibly powerful module, but with that power comes
  great responsibility, er- as well as some runtime penalties.  This module
  is a C<Sub::Exporter> wrapper that will let your users just use L<Exporter>
  if all they are doing is picking exports, but use C<Sub::Exporter> if your
  users try to use C<Sub::Exporter>'s more advanced features features, like
  renaming exports, if they try to use them.
  
  Note that this module will export C<@EXPORT>, C<@EXPORT_OK> and
  C<%EXPORT_TAGS> package variables for C<Exporter> to work.  Additionally, if
  your package uses advanced C<Sub::Exporter> features like currying, this module
  will only ever use C<Sub::Exporter>, so you might as well use it directly.
  
  =head1 AUTHOR
  
  frew - Arthur Axel Schmidt (cpan:FREW) <frioux+cpan@gmail.com>
  
  =head1 CONTRIBUTORS
  
  ilmari - Dagfinn Ilmari Mannsåker (cpan:ILMARI) <ilmari@ilmari.org>
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  leont - Leon Timmermans (cpan:LEONT) <leont@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2012 the Sub::Exporter::Progressive L</AUTHOR> and
  L</CONTRIBUTORS> as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
SUB_EXPORTER_PROGRESSIVE

$fatpacked{"Sub/Quote.pm"} = <<'SUB_QUOTE';
  package Sub::Quote;
  
  use strictures 1;
  
  sub _clean_eval { eval $_[0] }
  
  use Sub::Defer;
  use B 'perlstring';
  use Scalar::Util qw(weaken);
  use base qw(Exporter);
  
  our @EXPORT = qw(quote_sub unquote_sub quoted_from_sub);
  
  our %QUOTED;
  
  our %WEAK_REFS;
  
  sub capture_unroll {
    my ($from, $captures, $indent) = @_;
    join(
      '',
      map {
        /^([\@\%\$])/
          or die "capture key should start with \@, \% or \$: $_";
        (' ' x $indent).qq{my ${_} = ${1}{${from}->{${\perlstring $_}}};\n};
      } keys %$captures
    );
  }
  
  sub inlinify {
    my ($code, $args, $extra, $local) = @_;
    my $do = 'do { '.($extra||'');
    if (my ($code_args, $body) = $code =~ / +my \(([^)]+)\) = \@_;(.*)$/s) {
      if ($code_args eq $args) {
        $do.$body.' }'
      } else {
        $do.'my ('.$code_args.') = ('.$args.'); '.$body.' }';
      }
    } else {
      my $assign = '';
      if ($local || $args ne '@_') {
        $assign = ($local ? 'local ' : '').'@_ = ('.$args.'); ';
      }
      $do.$assign.$code.' }';
    }
  }
  
  sub quote_sub {
    # HOLY DWIMMERY, BATMAN!
    # $name => $code => \%captures => \%options
    # $name => $code => \%captures
    # $name => $code
    # $code => \%captures => \%options
    # $code
    my $options =
      (ref($_[-1]) eq 'HASH' and ref($_[-2]) eq 'HASH')
        ? pop
        : {};
    my $captures = pop if ref($_[-1]) eq 'HASH';
    undef($captures) if $captures && !keys %$captures;
    my $code = pop;
    my $name = $_[0];
    my $outstanding;
    my $deferred = defer_sub +($options->{no_install} ? undef : $name) => sub {
      unquote_sub($outstanding);
    };
    $outstanding = "$deferred";
    $QUOTED{$outstanding} = [ $name, $code, $captures ];
    weaken($WEAK_REFS{$outstanding} = $deferred);
    return $deferred;
  }
  
  sub quoted_from_sub {
    my ($sub) = @_;
    $WEAK_REFS{$sub||''} and $QUOTED{$sub||''};
  }
  
  sub unquote_sub {
    my ($sub) = @_;
    unless ($QUOTED{$sub}[3]) {
      my ($name, $code, $captures) = @{$QUOTED{$sub}};
  
      my $make_sub = "{\n";
  
      if (keys %$captures) {
        $make_sub .= capture_unroll("\$_[1]", $captures, 2);
      }
  
      my $o_quoted = perlstring $sub;
      $make_sub .= (
        $name
            # disable the 'variable $x will not stay shared' warning since
            # we're not letting it escape from this scope anyway so there's
            # nothing trying to share it
          ? "  no warnings 'closure';\n  sub ${name} {\n"
          : "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = sub {\n"
      );
      $make_sub .= $code;
      $make_sub .= "  }".($name ? '' : ';')."\n";
      if ($name) {
        $make_sub .= "  \$Sub::Quote::QUOTED{${o_quoted}}[3] = \\&${name}\n";
      }
      $make_sub .= "}\n1;\n";
      $ENV{SUB_QUOTE_DEBUG} && warn $make_sub;
      {
        local $@;
        no strict 'refs';
        local *{$name} if $name;
        unless (_clean_eval $make_sub, $captures) {
          die "Eval went very, very wrong:\n\n${make_sub}\n\n$@";
        }
      }
    }
    $QUOTED{$sub}[3];
  }
  
  1;
  
  =head1 NAME
  
  Sub::Quote - efficient generation of subroutines via string eval
  
  =head1 SYNOPSIS
  
   package Silly;
  
   use Sub::Quote qw(quote_sub unquote_sub quoted_from_sub);
  
   quote_sub 'Silly::kitty', q{ print "meow" };
  
   quote_sub 'Silly::doggy', q{ print "woof" };
  
   my $sound = 0;
  
   quote_sub 'Silly::dagron',
     q{ print ++$sound % 2 ? 'burninate' : 'roar' },
     { '$sound' => \$sound };
  
  And elsewhere:
  
   Silly->kitty;  # meow
   Silly->doggy;  # woof
   Silly->dagron; # burninate
   Silly->dagron; # roar
   Silly->dagron; # burninate
  
  =head1 DESCRIPTION
  
  This package provides performant ways to generate subroutines from strings.
  
  =head1 SUBROUTINES
  
  =head2 quote_sub
  
   my $coderef = quote_sub 'Foo::bar', q{ print $x++ . "\n" }, { '$x' => \0 };
  
  Arguments: ?$name, $code, ?\%captures, ?\%options
  
  C<$name> is the subroutine where the coderef will be installed.
  
  C<$code> is a string that will be turned into code.
  
  C<\%captures> is a hashref of variables that will be made available to the
  code.  See the L</SYNOPSIS>'s C<Silly::dagron> for an example using captures.
  
  =head3 options
  
  =over 2
  
  =item * no_install
  
  B<Boolean>.  Set this option to not install the generated coderef into the
  passed subroutine name on undefer.
  
  =back
  
  =head2 unquote_sub
  
   my $coderef = unquote_sub $sub;
  
  Forcibly replace subroutine with actual code.
  
  If $sub is not a quoted sub, this is a no-op.
  
  =head2 quoted_from_sub
  
   my $data = quoted_from_sub $sub;
  
   my ($name, $code, $captures, $compiled_sub) = @$data;
  
  Returns original arguments to quote_sub, plus the compiled version if this
  sub has already been unquoted.
  
  Note that $sub can be either the original quoted version or the compiled
  version for convenience.
  
  =head2 inlinify
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   };
  
   my $inlined_code = inlinify q{
     my ($x, $y) = @_;
  
     print $x + $y . "\n";
   }, '$x, $y', $prelude;
  
  Takes a string of code, a string of arguments, a string of code which acts as a
  "prelude", and a B<Boolean> representing whether or not to localize the
  arguments.
  
  =head2 capture_unroll
  
   my $prelude = capture_unroll '$captures', {
     '$x' => 1,
     '$y' => 2,
   }, 4;
  
  Arguments: $from, \%captures, $indent
  
  Generates a snippet of code which is suitable to be used as a prelude for
  L</inlinify>.  C<$from> is a string will be used as a hashref in the resulting
  code.  The keys of C<%captures> are the names of the variables and the values
  are ignored.  C<$indent> is the number of spaces to indent the result by.
  
  =head1 CAVEATS
  
  Much of this is just string-based code-generation, and as a result, a few caveats
  apply.
  
  =head2 return
  
  Calling C<return> from a quote_sub'ed sub will not likely do what you intend.
  Instead of returning from the code you defined in C<quote_sub>, it will return
  from the overall function it is composited into.
  
  So when you pass in:
  
     quote_sub q{  return 1 if $condition; $morecode }
  
  It might turn up in the intended context as follows:
  
    sub foo {
  
      <important code a>
      do {
        return 1 if $condition;
        $morecode
      };
      <important code b>
  
    }
  
  Which will obviously return from foo, when all you meant to do was return from
  the code context in quote_sub and proceed with running important code b.
  
  =head2 strictures
  
  Sub::Quote compiles quoted subs in an environment where C<< use strictures >>
  is in effect. L<strictures> enables L<strict> and FATAL L<warnings>.
  
  The following dies I<< Use of uninitialized value in print... >>
  
   no warnings;
   quote_sub 'Silly::kitty', q{ print undef };
  
  If you need to disable parts of strictures, do it within the quoted sub:
  
   quote_sub 'Silly::kitty', q{ no warnings; print undef };
  
  =head1 SUPPORT
  
  See L<Moo> for support and contact information.
  
  =head1 AUTHORS
  
  See L<Moo> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<Moo> for the copyright and license.
SUB_QUOTE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  BEGIN {
    $Try::Tiny::AUTHORITY = 'cpan:NUFFIN';
  }
  {
    $Try::Tiny::VERSION = '0.16';
  }
  use 5.006;
  # ABSTRACT: minimal try/catch with proper preservation of $@
  
  use strict;
  use warnings;
  
  use base 'Exporter';
  our @EXPORT = our @EXPORT_OK = qw(try catch finally);
  
  use Carp;
  $Carp::Internal{+__PACKAGE__}++;
  
  BEGIN { eval "use Sub::Name; 1" or *{subname} = sub {1} }
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
    my ( $try, @code_refs ) = @_;
  
    # we need to save this here, the eval block will be in scalar context due
    # to $failed
    my $wantarray = wantarray;
  
    my ( $catch, @finally );
  
    # find labeled blocks in the argument list.
    # catch and finally tag the blocks by blessing a scalar reference to them.
    foreach my $code_ref (@code_refs) {
  
      if ( ref($code_ref) eq 'Try::Tiny::Catch' ) {
        croak 'A try() may not be followed by multiple catch() blocks'
          if $catch;
        $catch = ${$code_ref};
      } elsif ( ref($code_ref) eq 'Try::Tiny::Finally' ) {
        push @finally, ${$code_ref};
      } else {
        croak(
          'try() encountered an unexpected argument ('
        . ( defined $code_ref ? $code_ref : 'undef' )
        . ') - perhaps a missing semi-colon before or'
        );
      }
    }
  
    # FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
    # not perfect, but we could provide a list of additional errors for
    # $catch->();
  
    # name the blocks if we have Sub::Name installed
    my $caller = caller;
    subname("${caller}::try {...} " => $try);
    subname("${caller}::catch {...} " => $catch) if $catch;
    subname("${caller}::finally {...} " => $_) foreach @finally;
  
    # save the value of $@ so we can set $@ back to it in the beginning of the eval
    # and restore $@ after the eval finishes
    my $prev_error = $@;
  
    my ( @ret, $error );
  
    # failed will be true if the eval dies, because 1 will not be returned
    # from the eval body
    my $failed = not eval {
      $@ = $prev_error;
  
      # evaluate the try block in the correct context
      if ( $wantarray ) {
        @ret = $try->();
      } elsif ( defined $wantarray ) {
        $ret[0] = $try->();
      } else {
        $try->();
      };
  
      return 1; # properly set $fail to false
    };
  
    # preserve the current error and reset the original value of $@
    $error = $@;
    $@ = $prev_error;
  
    # set up a scope guard to invoke the finally block at the end
    my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
    # at this point $failed contains a true value if the eval died, even if some
    # destructor overwrote $@ as the eval was unwinding.
    if ( $failed ) {
      # if we got an error, invoke the catch block.
      if ( $catch ) {
        # This works like given($error), but is backwards compatible and
        # sets $_ in the dynamic scope for the body of C<$catch>
        for ($error) {
          return $catch->($error);
        }
  
        # in case when() was used without an explicit return, the C<for>
        # loop will be aborted and there's no useful return value
      }
  
      return;
    } else {
      # no failure, $@ is back to what it was, everything is fine
      return $wantarray ? @ret : $ret[0];
    }
  }
  
  sub catch (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare catch()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Catch'),
      @rest,
    );
  }
  
  sub finally (&;@) {
    my ( $block, @rest ) = @_;
  
    croak 'Useless bare finally()' unless wantarray;
  
    return (
      bless(\$block, 'Try::Tiny::Finally'),
      @rest,
    );
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    use constant UNSTABLE_DOLLARAT => ($] < '5.013002') ? 1 : 0;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my ($code, @args) = @{ $_[0] };
  
      local $@ if UNSTABLE_DOLLARAT;
      eval {
        $code->(@args);
        1;
      } or do {
        warn
          "Execution of finally() block $code resulted in an exception, which "
        . '*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. '
        . 'Your program will continue as if this event never took place. '
        . "Original exception text follows:\n\n"
        . (defined $@ ? $@ : '$@ left undefined...')
        . "\n"
        ;
      }
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper preservation of $@
  
  =head1 VERSION
  
  version 0.16
  
  =head1 SYNOPSIS
  
  You can use Try::Tiny's C<try> and C<catch> to expect and handle exceptional
  conditions, avoiding quirks in Perl and common mistakes:
  
    # handle errors with a catch handler
    try {
      die "foo";
    } catch {
      warn "caught error: $_"; # not $@
    };
  
  You can also use it like a standalone C<eval> to catch and ignore any error
  conditions.  Obviously, this is an extreme measure not to be undertaken
  lightly:
  
    # just silence errors
    try {
      die "foo";
    };
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the C<try> block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L</BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the C<try> block dies, it returns the value of the last statement executed in
  the C<catch> block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following examples all
  assign C<"bar"> to C<$x>:
  
    my $x = try { die "foo" } catch { "bar" };
    my $x = try { die "foo" } || { "bar" };
    my $x = (try { die "foo" }) // { "bar" };
  
    my $x = eval { die "foo" } || "bar";
  
  You can add C<finally> blocks, yielding the following:
  
    my $x;
    try { die 'foo' } finally { $x = 'bar' };
    try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  C<finally> blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many C<finally> blocks to a
  given C<try> block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory C<try> subroutine, an optional C<catch> subroutine and C<finally>
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the C<finally> block, if given, will execute.
  
  =item catch (&;@)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
    catch { ... }
  
  Inside the C<catch> block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
    local $@ = $_;
  
  =item finally (&;@)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. C<finally> blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the C<finally> block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  (Note that the C<finally> block does not
  localize C<$_> with the error, since unlike in a C<catch> block, there is no way
  to know if C<$_ == undef> implies that there were no errors.) In other words,
  the following code does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the C<finally> block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  Furthermore B<exceptions in C<finally> blocks are not trappable and are unable
  to influence the execution of your program>. This is due to limitation of
  C<DESTROY>-based scope guards, which C<finally> is implemented on top of. This
  may change in a future version of Try::Tiny.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an C<eval> block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (the one
  available before entering the C<try> block) in the beginning of the C<eval>
  block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an C<eval> block, C<die> behaves sort of like:
  
    sub die {
      $@ = $_[0];
      return_undef_from_eval();
    }
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
    my $error = do {
      local $@;
      eval { ... };
      $@;
    };
  
    ...
    die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
    if ( $@ ) {
      ...
    }
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
    sub Object::DESTROY {
      eval { ... }
    }
  
    eval {
      my $obj = Object->new;
  
      die "foo";
    };
  
    if ( $@ ) {
  
    }
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the C<eval> was aborted due to an error:
  
    my $failed = not eval {
      ...
  
      return 1;
    };
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
    try {
      require Foo;
    } catch {
      when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
      default { die $_ }
    };
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
    sub foo {
      my ( $self, @args ) = @_;
      try { $self->bar(@args) }
    }
  
  or
  
    sub bar_in_place {
      my $self = shift;
      my $args = \@_;
      try { $_ = $self->bar($_) for @$args }
    }
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
    sub parent_sub {
      try {
        die;
      }
      catch {
        return;
      };
  
      say "this text WILL be displayed, even though an exception is thrown";
    }
  
  Instead, you should capture the return value:
  
    sub parent_sub {
      my $success = try {
        die;
        1;
      };
      return unless $success;
  
      say "This text WILL NEVER appear!";
    }
  
  Note that if you have a C<catch> block, it must return C<undef> for this to work,
  since if a C<catch> block exists, its return value is returned in place of C<undef>
  when an exception is thrown.
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
    my $obj = try {
      MightFail->new;
    } catch {
      ...
  
      return; # avoid returning a true value;
    };
  
    return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
    given ($foo) {
      when (...) {
        try {
          ...
        } catch {
          warn $_; # will print $foo, not the error
          warn $_[0]; # instead, get the error like this
        }
      }
    }
  
  Note that this behavior was changed once again in L<Perl5 version 18
  |https://metacpan.org/module/perldelta#given-now-aliases-the-global-_>.
  However, since the entirety of lexical C<$_> is now L<considired experimental
  |https://metacpan.org/module/perldelta#Lexical-_-is-now-experimental>, it
  is unclear whether the new version 18 behavior is final.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://web.archive.org/web/20100628040134/http://nothingmuch.woobling.org/talks/takahashi.xul>
  
  Or read the source:
  
  L<http://web.archive.org/web/20100305133605/http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/doy/try-tiny/>
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Yuval Kogman <nothingmuch@woobling.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by Yuval Kogman.
  
  This is free software, licensed under:
  
    The MIT (X11) License
  
  =cut
TRY_TINY

$fatpacked{"namespace/clean.pm"} = <<'NAMESPACE_CLEAN';
  package namespace::clean;
  
  use warnings;
  use strict;
  
  use Package::Stash;
  
  our $VERSION = '0.24';
  our $STORAGE_VAR = '__NAMESPACE_CLEAN_STORAGE';
  
  use B::Hooks::EndOfScope 'on_scope_end';
  
  =head1 NAME
  
  namespace::clean - Keep imports and functions out of your namespace
  
  =head1 SYNOPSIS
  
    package Foo;
    use warnings;
    use strict;
  
    use Carp qw(croak);   # 'croak' will be removed
  
    sub bar { 23 }        # 'bar' will be removed
  
    # remove all previously defined functions
    use namespace::clean;
  
    sub baz { bar() }     # 'baz' still defined, 'bar' still bound
  
    # begin to collection function names from here again
    no namespace::clean;
  
    sub quux { baz() }    # 'quux' will be removed
  
    # remove all functions defined after the 'no' unimport
    use namespace::clean;
  
    # Will print: 'No', 'No', 'Yes' and 'No'
    print +(__PACKAGE__->can('croak') ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('bar')   ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('baz')   ? 'Yes' : 'No'), "\n";
    print +(__PACKAGE__->can('quux')  ? 'Yes' : 'No'), "\n";
  
    1;
  
  =head1 DESCRIPTION
  
  =head2 Keeping packages clean
  
  When you define a function, or import one, into a Perl package, it will
  naturally also be available as a method. This does not per se cause
  problems, but it can complicate subclassing and, for example, plugin
  classes that are included via multiple inheritance by loading them as
  base classes.
  
  The C<namespace::clean> pragma will remove all previously declared or
  imported symbols at the end of the current package's compile cycle.
  Functions called in the package itself will still be bound by their
  name, but they won't show up as methods on your class or instances.
  
  By unimporting via C<no> you can tell C<namespace::clean> to start
  collecting functions for the next C<use namespace::clean;> specification.
  
  You can use the C<-except> flag to tell C<namespace::clean> that you
  don't want it to remove a certain function or method. A common use would
  be a module exporting an C<import> method along with some functions:
  
    use ModuleExportingImport;
    use namespace::clean -except => [qw( import )];
  
  If you just want to C<-except> a single sub, you can pass it directly.
  For more than one value you have to use an array reference.
  
  =head2 Explicitly removing functions when your scope is compiled
  
  It is also possible to explicitly tell C<namespace::clean> what packages
  to remove when the surrounding scope has finished compiling. Here is an
  example:
  
    package Foo;
    use strict;
  
    # blessed NOT available
  
    sub my_class {
        use Scalar::Util qw( blessed );
        use namespace::clean qw( blessed );
  
        # blessed available
        return blessed shift;
    }
  
    # blessed NOT available
  
  =head2 Moose
  
  When using C<namespace::clean> together with L<Moose> you want to keep
  the installed C<meta> method. So your classes should look like:
  
    package Foo;
    use Moose;
    use namespace::clean -except => 'meta';
    ...
  
  Same goes for L<Moose::Role>.
  
  =head2 Cleaning other packages
  
  You can tell C<namespace::clean> that you want to clean up another package
  instead of the one importing. To do this you have to pass in the C<-cleanee>
  option like this:
  
    package My::MooseX::namespace::clean;
    use strict;
  
    use namespace::clean (); # no cleanup, just load
  
    sub import {
        namespace::clean->import(
          -cleanee => scalar(caller),
          -except  => 'meta',
        );
    }
  
  If you don't care about C<namespace::clean>s discover-and-C<-except> logic, and
  just want to remove subroutines, try L</clean_subroutines>.
  
  =head1 METHODS
  
  =head2 clean_subroutines
  
  This exposes the actual subroutine-removal logic.
  
    namespace::clean->clean_subroutines($cleanee, qw( subA subB ));
  
  will remove C<subA> and C<subB> from C<$cleanee>. Note that this will remove the
  subroutines B<immediately> and not wait for scope end. If you want to have this
  effect at a specific time (e.g. C<namespace::clean> acts on scope compile end)
  it is your responsibility to make sure it runs at that time.
  
  =cut
  
  # Constant to optimise away the unused code branches
  use constant FIXUP_NEEDED => $] < 5.015_005_1;
  use constant FIXUP_RENAME_SUB => $] > 5.008_008_9 && $] < 5.013_005_1;
  {
    no strict;
    delete ${__PACKAGE__."::"}{FIXUP_NEEDED};
    delete ${__PACKAGE__."::"}{FIXUP_RENAME_SUB};
  }
  
  # Debugger fixup necessary before perl 5.15.5
  #
  # In perl 5.8.9-5.12, it assumes that sub_fullname($sub) can
  # always be used to find the CV again.
  # In perl 5.8.8 and 5.14, it assumes that the name of the glob
  # passed to entersub can be used to find the CV.
  # since we are deleting the glob where the subroutine was originally
  # defined, those assumptions no longer hold.
  #
  # So in 5.8.9-5.12 we need to move it elsewhere and point the
  # CV's name to the new glob.
  #
  # In 5.8.8 and 5.14 we move it elsewhere and rename the
  # original glob by assigning the new glob back to it.
  my $sub_utils_loaded;
  my $DebuggerFixup = sub {
    my ($f, $sub, $cleanee_stash, $deleted_stash) = @_;
  
    if (FIXUP_RENAME_SUB) {
      if (! defined $sub_utils_loaded ) {
        $sub_utils_loaded = do {
  
          # when changing version also change in Makefile.PL
          my $sn_ver = 0.04;
          eval { require Sub::Name; Sub::Name->VERSION($sn_ver) }
            or die "Sub::Name $sn_ver required when running under -d or equivalent: $@";
  
          # when changing version also change in Makefile.PL
          my $si_ver = 0.04;
          eval { require Sub::Identify; Sub::Identify->VERSION($si_ver) }
            or die "Sub::Identify $si_ver required when running under -d or equivalent: $@";
  
          1;
        } ? 1 : 0;
      }
  
      if ( Sub::Identify::sub_fullname($sub) eq ($cleanee_stash->name . "::$f") ) {
        my $new_fq = $deleted_stash->name . "::$f";
        Sub::Name::subname($new_fq, $sub);
        $deleted_stash->add_symbol("&$f", $sub);
      }
    }
    else {
      $deleted_stash->add_symbol("&$f", $sub);
    }
  };
  
  my $RemoveSubs = sub {
      my $cleanee = shift;
      my $store   = shift;
      my $cleanee_stash = Package::Stash->new($cleanee);
      my $deleted_stash;
  
    SYMBOL:
      for my $f (@_) {
  
          # ignore already removed symbols
          next SYMBOL if $store->{exclude}{ $f };
  
          my $sub = $cleanee_stash->get_symbol("&$f")
            or next SYMBOL;
  
          my $need_debugger_fixup =
            FIXUP_NEEDED
              &&
            $^P
              &&
            ref(my $globref = \$cleanee_stash->namespace->{$f}) eq 'GLOB'
          ;
  
          if (FIXUP_NEEDED && $need_debugger_fixup) {
            # convince the Perl debugger to work
            # see the comment on top of $DebuggerFixup
            $DebuggerFixup->(
              $f,
              $sub,
              $cleanee_stash,
              $deleted_stash ||= Package::Stash->new("namespace::clean::deleted::$cleanee"),
            );
          }
  
          my @symbols = map {
              my $name = $_ . $f;
              my $def = $cleanee_stash->get_symbol($name);
              defined($def) ? [$name, $def] : ()
          } '$', '@', '%', '';
  
          $cleanee_stash->remove_glob($f);
  
          # if this perl needs no renaming trick we need to
          # rename the original glob after the fact
          # (see commend of $DebuggerFixup
          if (FIXUP_NEEDED && !FIXUP_RENAME_SUB && $need_debugger_fixup) {
            *$globref = $deleted_stash->namespace->{$f};
          }
  
          $cleanee_stash->add_symbol(@$_) for @symbols;
      }
  };
  
  sub clean_subroutines {
      my ($nc, $cleanee, @subs) = @_;
      $RemoveSubs->($cleanee, {}, @subs);
  }
  
  =head2 import
  
  Makes a snapshot of the current defined functions and installs a
  L<B::Hooks::EndOfScope> hook in the current scope to invoke the cleanups.
  
  =cut
  
  sub import {
      my ($pragma, @args) = @_;
  
      my (%args, $is_explicit);
  
    ARG:
      while (@args) {
  
          if ($args[0] =~ /^\-/) {
              my $key = shift @args;
              my $value = shift @args;
              $args{ $key } = $value;
          }
          else {
              $is_explicit++;
              last ARG;
          }
      }
  
      my $cleanee = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
      if ($is_explicit) {
          on_scope_end {
              $RemoveSubs->($cleanee, {}, @args);
          };
      }
      else {
  
          # calling class, all current functions and our storage
          my $functions = $pragma->get_functions($cleanee);
          my $store     = $pragma->get_class_store($cleanee);
          my $stash     = Package::Stash->new($cleanee);
  
          # except parameter can be array ref or single value
          my %except = map {( $_ => 1 )} (
              $args{ -except }
              ? ( ref $args{ -except } eq 'ARRAY' ? @{ $args{ -except } } : $args{ -except } )
              : ()
          );
  
          # register symbols for removal, if they have a CODE entry
          for my $f (keys %$functions) {
              next if     $except{ $f };
              next unless $stash->has_symbol("&$f");
              $store->{remove}{ $f } = 1;
          }
  
          # register EOF handler on first call to import
          unless ($store->{handler_is_installed}) {
              on_scope_end {
                  $RemoveSubs->($cleanee, $store, keys %{ $store->{remove} });
              };
              $store->{handler_is_installed} = 1;
          }
  
          return 1;
      }
  }
  
  =head2 unimport
  
  This method will be called when you do a
  
    no namespace::clean;
  
  It will start a new section of code that defines functions to clean up.
  
  =cut
  
  sub unimport {
      my ($pragma, %args) = @_;
  
      # the calling class, the current functions and our storage
      my $cleanee   = exists $args{ -cleanee } ? $args{ -cleanee } : scalar caller;
      my $functions = $pragma->get_functions($cleanee);
      my $store     = $pragma->get_class_store($cleanee);
  
      # register all unknown previous functions as excluded
      for my $f (keys %$functions) {
          next if $store->{remove}{ $f }
               or $store->{exclude}{ $f };
          $store->{exclude}{ $f } = 1;
      }
  
      return 1;
  }
  
  =head2 get_class_store
  
  This returns a reference to a hash in a passed package containing
  information about function names included and excluded from removal.
  
  =cut
  
  sub get_class_store {
      my ($pragma, $class) = @_;
      my $stash = Package::Stash->new($class);
      my $var = "%$STORAGE_VAR";
      $stash->add_symbol($var, {})
          unless $stash->has_symbol($var);
      return $stash->get_symbol($var);
  }
  
  =head2 get_functions
  
  Takes a class as argument and returns all currently defined functions
  in it as a hash reference with the function name as key and a typeglob
  reference to the symbol as value.
  
  =cut
  
  sub get_functions {
      my ($pragma, $class) = @_;
  
      my $stash = Package::Stash->new($class);
      return {
          map { $_ => $stash->get_symbol("&$_") }
              $stash->list_all_symbols('CODE')
      };
  }
  
  =head1 IMPLEMENTATION DETAILS
  
  This module works through the effect that a
  
    delete $SomePackage::{foo};
  
  will remove the C<foo> symbol from C<$SomePackage> for run time lookups
  (e.g., method calls) but will leave the entry alive to be called by
  already resolved names in the package itself. C<namespace::clean> will
  restore and therefor in effect keep all glob slots that aren't C<CODE>.
  
  A test file has been added to the perl core to ensure that this behaviour
  will be stable in future releases.
  
  Just for completeness sake, if you want to remove the symbol completely,
  use C<undef> instead.
  
  =head1 SEE ALSO
  
  L<B::Hooks::EndOfScope>
  
  =head1 THANKS
  
  Many thanks to Matt S Trout for the inspiration on the whole idea.
  
  =head1 AUTHORS
  
  =over
  
  =item *
  
  Robert 'phaylon' Sedlacek <rs@474.at>
  
  =item *
  
  Florian Ragwitz <rafl@debian.org>
  
  =item *
  
  Jesse Luehrs <doy@tozt.net>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =item *
  
  Father Chrysostomos <sprout@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2011 by L</AUTHORS>
  
  This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.
  
  =cut
  
  no warnings;
  'Danger! Laws of Thermodynamics may not apply.'
NAMESPACE_CLEAN

$fatpacked{"oo.pm"} = <<'OO';
  package oo;
  
  use strictures 1;
  use Moo::_Utils;
  
  sub moo {
    print <<'EOMOO';
   ______
  < Moo! >
   ------
          \   ^__^
           \  (oo)\_______
              (__)\       )\/\
                  ||----w |
                  ||     ||
  EOMOO
    exit 0;
  }
  
  BEGIN {
      my $package;
      sub import {
          moo() if $0 eq '-';
          $package = $_[1] || 'Class';
          if ($package =~ /^\+/) {
              $package =~ s/^\+//;
              _load_module($package);
          }
      }
      use Filter::Simple sub { s/^/package $package;\nuse Moo;\n/; }
  }
  
  1;
OO

$fatpacked{"strictures.pm"} = <<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  use constant _PERL_LT_5_8_4 => ($] < 5.008004) ? 1 : 0;
  
  our $VERSION = '1.004004'; # 1.4.4
  
  sub VERSION {
    for ($_[1]) {
      last unless defined && !ref && int != 1;
      die "Major version specified as $_ - this is strictures version 1";
    }
    # disable this since Foo->VERSION(undef) correctly returns the version
    # and that can happen either if our caller passes undef explicitly or
    # because the for above autovivified $_[1] - I could make it stop but
    # it's pointless since we don't want to blow up if the caller does
    # something valid either.
    no warnings 'uninitialized';
    shift->SUPER::VERSION(@_);
  }
  
  my $extra_load_states;
  
  our $Smells_Like_VCS = (-e '.git' || -e '.svn'
    || (-e '../../dist.ini' && (-e '../../.git' || -e '../../.svn')));
  
  sub import {
    strict->import;
    warnings->import(FATAL => 'all');
  
    my $extra_tests = do {
      if (exists $ENV{PERL_STRICTURES_EXTRA}) {
        if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
          die 'PERL_STRICTURES_EXTRA checks are not available on perls older than 5.8.4: '
            . "please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
        }
        $ENV{PERL_STRICTURES_EXTRA};
      } elsif (! _PERL_LT_5_8_4) {
        !!((caller)[1] =~ /^(?:t|xt|lib|blib)/
           and $Smells_Like_VCS)
      }
    };
    if ($extra_tests) {
      $extra_load_states ||= do {
  
        my (%rv, @failed);
        foreach my $mod (qw(indirect multidimensional bareword::filehandles)) {
          eval "require $mod; \$rv{'$mod'} = 1;" or do {
            push @failed, $mod;
  
            # courtesy of the 5.8 require bug
            # (we do a copy because 5.16.2 at least uses the same read-only
            # scalars for the qw() list and it doesn't seem worth a $^V check)
  
            (my $file = $mod) =~ s|::|/|g;
            delete $INC{"${file}.pm"};
          };
        }
  
        if (@failed) {
          my $failed = join ' ', @failed;
          print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan indirect multidimensional bareword::filehandles
  
  but these modules are not required by your users.
  EOE
        }
  
        \%rv;
      };
  
      indirect->unimport(':fatal') if $extra_load_states->{indirect};
      multidimensional->unimport if $extra_load_states->{multidimensional};
      bareword::filehandles->unimport if $extra_load_states->{'bareword::filehandles'};
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - turn on strict and make all warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)/
  
  and when either C<.git> or C<.svn> is present in the current directory (with
  the intention of only forcing extra tests on the author side) -- or when C<.git>
  or C<.svn> is present two directories up along with C<dist.ini> (which would
  indicate we are in a C<dzil test> operation, via L<Dist::Zilla>) --
  or when the C<PERL_STRICTURES_EXTRA> environment variable is set, in which case
  
    use strictures 1;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with only a minor
  version increase, but any changes to the effect of C<use strictures> in
  normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version increase (e.g.
  1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the mechanism of
  this code will result in a sub-version increase (e.g. 1.000000 to 1.000001
  (1.0.1)).
  
  If the behaviour of C<use strictures> in normal mode changes in any way, that
  will constitute a major version increase -- and the code already checks
  when its version is tested to ensure that
  
    use strictures 1;
  
  will continue to only introduce the current set of strictures even if 2.0 is
  installed.
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as possible,
  and will allow any future discussion on the subject to focus on "how do we
  minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  None required yet. Maybe this module is perfect (hahahahaha ...).
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"x86_64-linux/Class/XSAccessor.pm"} = <<'X86_64-LINUX_CLASS_XSACCESSOR';
  package Class::XSAccessor;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor::Heavy;
  use XSLoader;
  
  our $VERSION = '1.18';
  
  XSLoader::load('Class::XSAccessor', $VERSION);
  
  sub _make_hash {
    my $ref = shift;
  
    if (ref ($ref)) {
      if (ref($ref) eq 'ARRAY') {
        $ref = { map { $_ => $_ } @$ref }
      } 
    } else {
      $ref = { $ref, $ref };
    }
  
    return $ref;
  }
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    # TODO: Refactor. Move more duplicated code to ::Heavy
    my $read_subs      = _make_hash($opts{getters} || {});
    my $set_subs       = _make_hash($opts{setters} || {});
    my $acc_subs       = _make_hash($opts{accessors} || {});
    my $lvacc_subs     = _make_hash($opts{lvalue_accessors} || {});
    my $pred_subs      = _make_hash($opts{predicates} || {});
    my $ex_pred_subs   = _make_hash($opts{exists_predicates} || {});
    my $def_pred_subs  = _make_hash($opts{defined_predicates} || {});
    my $test_subs      = _make_hash($opts{__tests__} || {});
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["test", $test_subs],
                          ["ex_predicate", $ex_pred_subs],
                          ["def_predicate", $def_pred_subs],
                          ["def_predicate", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $hashkey = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $hashkey, \%opts, $subtype->[0]);
      }
    }
  
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $hashkey, $opts, $type) = @_;
  
    croak("Cannot use undef as a hash key for generating an XS $type accessor. (Sub: $subname)")
      if not defined $hashkey;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $hashkey);
    }
    elsif ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $hashkey);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $hashkey, $opts->{chained}||0);
    }
    elsif ($type eq 'def_predicate') {
      newxs_defined_predicate($subname, $hashkey);
    }
    elsif ($type eq 'ex_predicate') {
      newxs_exists_predicate($subname, $hashkey);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      newxs_boolean($subname, 0);
    }
    elsif ($type eq 'test') {
      newxs_test($subname, $hashkey);
    }
    else {
      newxs_accessor($subname, $hashkey, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
  
    package MyClass;
    use Class::XSAccessor
      replace     => 1,   # Replace existing methods (if any)
      constructor => 'new',
      getters     => {
        get_foo => 'foo', # 'foo' is the hash key to access
        get_bar => 'bar',
      },
      setters => {
        set_foo => 'foo',
        set_bar => 'bar',
      },
      accessors => {
        foo => 'foo',
        bar => 'bar',
      },
      # "predicates" is an alias for "defined_predicates"
      defined_predicates => {
        defined_foo => 'foo',
        defined_bar => 'bar',
      },
      exists_predicates => {
        has_foo => 'foo',
        has_bar => 'bar',
      },
      lvalue_accessors => { # see below
        baz => 'baz', # ...
      },
      true  => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference, if preferred,
    # which can also help Perl::Tidy to format the statement correctly.
    use Class::XSAccessor {
       # If the name => key values are always identical,
       # the following shorthand can be used.
       accessors => [ 'foo', 'bar' ],
    };
  
  =head1 DESCRIPTION
  
  Class::XSAccessor implements fast read, write and read/write accessors in XS.
  Additionally, it can provide predicates such as C<has_foo()> for testing
  whether the attribute C<foo> exists in the object (which is different from
  "is defined within the object").
  It only works with objects that are implemented as ordinary hashes.
  L<Class::XSAccessor::Array> implements the same interface for objects
  that use arrays for their internal representation.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS). Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless { @_ }, ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Parameters to C<new()> are added to the
  object.
  
  The XS accessor methods are between 3 and 4 times faster than typical
  pure-Perl accessors in some simple benchmarking.
  The lower factor applies to the potentially slightly obscure
  C<sub set_foo_pp {$_[0]-E<gt>{foo} = $_[1]}>, so if you usually
  write clear code, a factor of 3.5 speed-up is a good estimate.
  If in doubt, do your own benchmarking!
  
  The method names may be fully qualified. The example in the synopsis could
  have been written as C<MyClass::get_foo> instead
  of C<get_foo>. This way, methods can be installed in classes other
  than the current class. See also: the C<class> option below.
  
  By default, the setters return the new value that was set,
  and the accessors (mutators) do the same. This behaviour can be changed
  with the C<chained> option - see below. The predicates return a boolean.
  
  Since version 1.01, C<Class::XSAccessor> can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then consider a large class hierarchy
  with interfaces such as L<PPI>. These methods are provided by the C<true>
  and C<false> options - see the synopsis.
  
  C<defined_predicates> check whether a given object attribute is defined.
  C<predicates> is an alias for C<defined_predicates> for compatibility with
  older versions of C<Class::XSAccessor>. C<exists_predicates> checks
  whether the given attribute exists in the object using C<exists>.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, additional options
  can be supplied which modify behaviour. The options are specified as key/value pairs
  in the same manner as the accessor declaration. For example:
  
    use Class::XSAccessor
      getters => {
        get_foo => 'foo',
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. The
  the C<class> option allows the target class to be specified.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 'zip' };
    
    package main;
    my $address = Address->new(zip => 2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably won't work for objects based on I<tied> hashes. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  that's only known at run-time. Note that compiling C code at run-time a la L<Inline::C|Inline::C>
  is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed>. Previously, a small amount of
  memory would leak if C<Class::XSAccessor>-based classes were loaded in a subthread without having
  been loaded in the "main" thread. If the subthread then terminated, a hash key and an int per
  associated method used to be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation, as of 1.00, the memory will still not be released, in the same situation,
  but it will be recycled when the same class, or a similar class, is loaded again in B<any> thread.
  
  =head1 SEE ALSO
  
  =over
  
  =item * L<Class::XSAccessor::Array>
  
  =item * L<AutoXS>
  
  =back
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX_CLASS_XSACCESSOR

$fatpacked{"x86_64-linux/Class/XSAccessor/Array.pm"} = <<'X86_64-LINUX_CLASS_XSACCESSOR_ARRAY';
  package Class::XSAccessor::Array;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw/croak/;
  use Class::XSAccessor;
  use Class::XSAccessor::Heavy;
  
  our $VERSION = '1.18';
  
  sub import {
    my $own_class = shift;
    my ($caller_pkg) = caller();
  
    # Support both { getters => ... } and plain getters => ...
    my %opts = ref($_[0]) eq 'HASH' ? %{$_[0]} : @_;
  
    $caller_pkg = $opts{class} if defined $opts{class};
  
    my $read_subs      = $opts{getters} || {};
    my $set_subs       = $opts{setters} || {};
    my $acc_subs       = $opts{accessors} || {};
    my $lvacc_subs     = $opts{lvalue_accessors} || {};
    my $pred_subs      = $opts{predicates} || {};
    my $construct_subs = $opts{constructors} || [defined($opts{constructor}) ? $opts{constructor} : ()];  
    my $true_subs      = $opts{true} || [];
    my $false_subs     = $opts{false} || [];
  
  
    foreach my $subtype ( ["getter", $read_subs],
                          ["setter", $set_subs],
                          ["accessor", $acc_subs],
                          ["lvalue_accessor", $lvacc_subs],
                          ["pred_subs", $pred_subs] )
    {
      my $subs = $subtype->[1];
      foreach my $subname (keys %$subs) {
        my $array_index = $subs->{$subname};
        _generate_method($caller_pkg, $subname, $array_index, \%opts, $subtype->[0]);
      }
    }
     
    foreach my $subtype ( ["constructor", $construct_subs],
                          ["true", $true_subs],
                          ["false", $false_subs] )
    {
      foreach my $subname (@{$subtype->[1]}) {
        _generate_method($caller_pkg, $subname, "", \%opts, $subtype->[0]);
      }
    }
  }
  
  sub _generate_method {
    my ($caller_pkg, $subname, $array_index, $opts, $type) = @_;
  
    croak("Cannot use undef as a array index for generating an XS $type accessor. (Sub: $subname)")
      if not defined $array_index;
  
    $subname = "${caller_pkg}::$subname" if $subname !~ /::/;
  
    Class::XSAccessor::Heavy::check_sub_existence($subname) if not $opts->{replace};
    no warnings 'redefine'; # don't warn about an explicitly requested redefine
  
    if ($type eq 'getter') {
      newxs_getter($subname, $array_index);
    }
    if ($type eq 'lvalue_accessor') {
      newxs_lvalue_accessor($subname, $array_index);
    }
    elsif ($type eq 'setter') {
      newxs_setter($subname, $array_index, $opts->{chained}||0);
    }
    elsif ($type eq 'predicate') {
      newxs_predicate($subname, $array_index);
    }
    elsif ($type eq 'constructor') {
      newxs_constructor($subname);
    }
    elsif ($type eq 'true') {
      Class::XSAccessor::newxs_boolean($subname, 1);
    }
    elsif ($type eq 'false') {
      Class::XSAccessor::newxs_boolean($subname, 0);
    }
    else {
      newxs_accessor($subname, $array_index, $opts->{chained}||0);
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation
  
  =head1 SYNOPSIS
    
    package MyClassUsingArraysAsInternalStorage;
    use Class::XSAccessor::Array
      constructor => 'new',
      getters => {
        get_foo => 0, # 0 is the array index to access
        get_bar => 1,
      },
      setters => {
        set_foo => 0,
        set_bar => 1,
      },
      accessors => { # a mutator
        buz => 2,
      },
      predicates => { # test for definedness
        has_buz => 2,
      },
      lvalue_accessors => { # see below
        baz => 3,
      },
      true => [ 'is_token', 'is_whitespace' ],
      false => [ 'significant' ];
    
    # The imported methods are implemented in fast XS.
    
    # normal class code here.
  
  As of version 1.05, some alternative syntax forms are available:
  
    package MyClass;
    
    # Options can be passed as a HASH reference if you prefer it,
    # which can also help PerlTidy to flow the statement correctly.
    use Class::XSAccessor {
      getters => {
        get_foo => 0,
        get_bar => 1,
      },
    };
  
  =head1 DESCRIPTION
  
  The module implements fast XS accessors both for getting at and
  setting an object attribute. Additionally, the module supports
  mutators and simple predicates (C<has_foo()> like tests for definedness
  of an attributes).
  The module works only with objects
  that are implemented as B<arrays>. Using it on hash-based objects is
  bound to make your life miserable. Refer to L<Class::XSAccessor> for
  an implementation that works with hash-based objects.
  
  A simple benchmark showed a significant performance
  advantage over writing accessors in Perl.
  
  Since version 0.10, the module can also generate simple constructors
  (implemented in XS) for you. Simply supply the
  C<constructor =E<gt> 'constructor_name'> option or the
  C<constructors =E<gt> ['new', 'create', 'spawn']> option.
  These constructors do the equivalent of the following Perl code:
  
    sub new {
      my $class = shift;
      return bless [], ref($class)||$class;
    }
  
  That means they can be called on objects and classes but will not
  clone objects entirely. Note that any parameters to new() will be
  discarded! If there is a better idiom for array-based objects, let
  me know.
  
  While generally more obscure than hash-based objects,
  objects using blessed arrays as internal representation
  are a bit faster as its somewhat faster to access arrays than hashes.
  Accordingly, this module is slightly faster (~10-15%) than
  L<Class::XSAccessor>, which works on hash-based objects.
  
  The method names may be fully qualified. In the example of the
  synopsis, you could have written C<MyClass::get_foo> instead
  of C<get_foo>. This way, you can install methods in classes other
  than the current class. See also: The C<class> option below.
  
  Since version 1.01, you can generate extremely simple methods which
  just return true or false (and always do so). If that seems like a
  really superfluous thing to you, then think of a large class hierarchy
  with interfaces such as PPI. This is implemented as the C<true>
  and C<false> options, see synopsis.
  
  =head1 OPTIONS
  
  In addition to specifying the types and names of accessors, you can add options
  which modify behaviour. The options are specified as key/value pairs just as the
  accessor declaration. Example:
  
    use Class::XSAccessor::Array
      getters => {
        get_foo => 0,
      },
      replace => 1;
  
  The list of available options is:
  
  =head2 replace
  
  Set this to a true value to prevent C<Class::XSAccessor::Array> from
  complaining about replacing existing subroutines.
  
  =head2 chained
  
  Set this to a true value to change the return value of setters
  and mutators (when called with an argument).
  If C<chained> is enabled, the setters and accessors/mutators will
  return the object. Mutators called without an argument still
  return the value of the associated attribute.
  
  As with the other options, C<chained> affects all methods generated
  in the same C<use Class::XSAccessor::Array ...> statement.
  
  =head2 class
  
  By default, the accessors are generated in the calling class. Using
  the C<class> option, you can explicitly specify where the methods
  are to be generated.
  
  =head1 LVALUES
  
  Support for lvalue accessors via the keyword C<lvalue_accessors>
  was added in version 1.08. At this point, B<THEY ARE CONSIDERED HIGHLY
  EXPERIMENTAL>. Furthermore, their performance hasn't been benchmarked
  yet.
  
  The following example demonstrates an lvalue accessor:
  
    package Address;
    use Class::XSAccessor
      constructor => 'new',
      lvalue_accessors => { zip_code => 0 };
    
    package main;
    my $address = Address->new(2);
    print $address->zip_code, "\n"; # prints 2
    $address->zip_code = 76135; # <--- This is it!
    print $address->zip_code, "\n"; # prints 76135
  
  =head1 CAVEATS
  
  Probably wouldn't work if your objects are I<tied>. But that's a strange thing to do anyway.
  
  Scary code exploiting strange XS features.
  
  If you think writing an accessor in XS should be a laughably simple exercise, then
  please contemplate how you could instantiate a new XS accessor for a new hash key
  or array index that's only known at run-time. Note that compiling C code at run-time
  a la Inline::C is a no go.
  
  Threading. With version 1.00, a memory leak has been B<fixed> that would leak a small amount of
  memory if you loaded C<Class::XSAccessor>-based classes in a subthread that hadn't been loaded
  in the "main" thread before. If the subthread then terminated, a hash key and an int per
  associated method used ot be lost. Note that this mattered only if classes were B<only> loaded
  in a sort of throw-away thread.
  
  In the new implementation as of 1.00, the memory will not be released again either in the above
  situation. But it will be recycled when the same class or a similar class is loaded
  again in B<any> thread.
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  
  L<AutoXS>
  
  =head1 AUTHOR
  
  Steffen Mueller E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
X86_64-LINUX_CLASS_XSACCESSOR_ARRAY

$fatpacked{"x86_64-linux/Class/XSAccessor/Heavy.pm"} = <<'X86_64-LINUX_CLASS_XSACCESSOR_HEAVY';
  package # hide from PAUSE
      Class::XSAccessor::Heavy;
  
  use 5.008;
  use strict;
  use warnings;
  use Carp;
  
  our $VERSION  = '1.18';
  our @CARP_NOT = qw(
          Class::XSAccessor
          Class::XSAccessor::Array
  );
  
  # TODO Move more duplicated code from XSA and XSA::Array here
  
  
  sub check_sub_existence {
    my $subname = shift;
  
    my $sub_package = $subname;
    $sub_package =~ s/([^:]+)$// or die;
    my $bare_subname = $1;
      
    my $sym;
    {
      no strict 'refs';
      $sym = \%{"$sub_package"};
    }
    no warnings;
    local *s = $sym->{$bare_subname};
    my $coderef = *s{CODE};
    if ($coderef) {
      $sub_package =~ s/::$//;
      Carp::croak("Cannot replace existing subroutine '$bare_subname' in package '$sub_package' with an XS implementation. If you wish to force a replacement, add the 'replace => 1' parameter to the arguments of 'use ".(caller())[0]."'.");
    }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::XSAccessor::Heavy - Guts you don't care about
  
  =head1 SYNOPSIS
    
    use Class::XSAccessor!
  
  =head1 DESCRIPTION
  
  Common guts for Class::XSAccessor and Class::XSAccessor::Array.
  No user-serviceable parts inside!
  
  =head1 SEE ALSO
  
  L<Class::XSAccessor>
  L<Class::XSAccessor::Array>
  
  =head1 AUTHOR
  
  Steffen Mueller, E<lt>smueller@cpan.orgE<gt>
  
  chocolateboy, E<lt>chocolate@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2008, 2009, 2010, 2011, 2012, 2013 by Steffen Mueller
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.8 or,
  at your option, any later version of Perl 5 you may have available.
  
  =cut
  
X86_64-LINUX_CLASS_XSACCESSOR_HEAVY

$fatpacked{"x86_64-linux/Package/Stash/XS.pm"} = <<'X86_64-LINUX_PACKAGE_STASH_XS';
  package Package::Stash::XS;
  BEGIN {
    $Package::Stash::XS::AUTHORITY = 'cpan:DOY';
  }
  {
    $Package::Stash::XS::VERSION = '0.26';
  }
  use strict;
  use warnings;
  use 5.008001;
  # ABSTRACT: faster and more correct implementation of the Package::Stash API
  
  use XSLoader;
  XSLoader::load(
      __PACKAGE__,
      # we need to be careful not to touch $VERSION at compile time, otherwise
      # DynaLoader will assume it's set and check against it, which will cause
      # fail when being run in the checkout without dzil having set the actual
      # $VERSION
      exists $Package::Stash::XS::{VERSION}
          ? ${ $Package::Stash::XS::{VERSION} } : (),
  );
  
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Package::Stash::XS - faster and more correct implementation of the Package::Stash API
  
  =head1 VERSION
  
  version 0.26
  
  =head1 SYNOPSIS
  
    use Package::Stash;
  
  =head1 DESCRIPTION
  
  This is a backend for L<Package::Stash>, which provides the functionality in a
  way that's less buggy and much faster. It will be used by default if it's
  installed, and should be preferred in all environments with a compiler.
  
  =head1 BUGS
  
  No known bugs (but see the BUGS section in L<Package::Stash>).
  
  Please report any bugs through RT: email
  C<bug-package-stash-xs at rt.cpan.org>, or browse to
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Package-Stash-XS>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Class::MOP::Package>
  
  This module is a factoring out of code that used to live here
  
  =back
  
  =head1 SUPPORT
  
  You can find this documentation for this module with the perldoc command.
  
      perldoc Package::Stash::XS
  
  You can also look for information at:
  
  =over 4
  
  =item * AnnoCPAN: Annotated CPAN documentation
  
  L<http://annocpan.org/dist/Package-Stash-XS>
  
  =item * CPAN Ratings
  
  L<http://cpanratings.perl.org/d/Package-Stash-XS>
  
  =item * RT: CPAN's request tracker
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Package-Stash-XS>
  
  =item * Search CPAN
  
  L<http://search.cpan.org/dist/Package-Stash-XS>
  
  =back
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  Based on code from L<Class::MOP::Package>, by Stevan Little and the Moose
  Cabal.
  
  =for Pod::Coverage add_symbol
  get_all_symbols
  get_or_add_symbol
  get_symbol
  has_symbol
  list_all_symbols
  name
  namespace
  new
  remove_glob
  remove_symbol
  
  =head1 AUTHOR
  
  Jesse Luehrs <doy at tozt dot net>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2013 by Jesse Luehrs.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX_PACKAGE_STASH_XS

$fatpacked{"x86_64-linux/Sub/Name.pm"} = <<'X86_64-LINUX_SUB_NAME';
  package Sub::Name;
  
  =head1 NAME
  
  Sub::Name - (re)name a sub
  
  =head1 SYNOPSIS
  
      use Sub::Name;
  
      subname $name, $subref;
  
      $subref = subname foo => sub { ... };
  
  =head1 DESCRIPTION
  
  This module has only one function, which is also exported by default:
  
  =head2 subname NAME, CODEREF
  
  Assigns a new name to referenced sub.  If package specification is omitted in 
  the name, then the current package is used.  The return value is the sub.
  
  The name is only used for informative routines (caller, Carp, etc).  You won't 
  be able to actually invoke the sub by the given name.  To allow that, you need 
  to do glob-assignment yourself.
  
  Note that for anonymous closures (subs that reference lexicals declared outside 
  the sub itself) you can name each instance of the closure differently, which 
  can be very useful for debugging.
  
  =head1 AUTHOR
  
  Matthijs van Duin <xmath@cpan.org>
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  This program is free software; you can redistribute it and/or modify 
  it under the same terms as Perl itself.
  
  =cut
  
  use 5.006;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.05';
  
  use base 'Exporter';
  use base 'DynaLoader';
  
  our @EXPORT = qw(subname);
  our @EXPORT_OK = @EXPORT;
  
  bootstrap Sub::Name $VERSION;
  
  1;
X86_64-LINUX_SUB_NAME

$fatpacked{"x86_64-linux/Variable/Magic.pm"} = <<'X86_64-LINUX_VARIABLE_MAGIC';
  package Variable::Magic;
  
  use 5.008;
  
  use strict;
  use warnings;
  
  =head1 NAME
  
  Variable::Magic - Associate user-defined magic to variables from Perl.
  
  =head1 VERSION
  
  Version 0.52
  
  =cut
  
  our $VERSION;
  BEGIN {
   $VERSION = '0.52';
  }
  
  =head1 SYNOPSIS
  
      use Variable::Magic qw<wizard cast VMG_OP_INFO_NAME>;
  
      { # A variable tracer
       my $wiz = wizard(
        set  => sub { print "now set to ${$_[0]}!\n" },
        free => sub { print "destroyed!\n" },
       );
  
       my $a = 1;
       cast $a, $wiz;
       $a = 2;        # "now set to 2!"
      }               # "destroyed!"
  
      { # A hash with a default value
       my $wiz = wizard(
        data     => sub { $_[1] },
        fetch    => sub { $_[2] = $_[1] unless exists $_[0]->{$_[2]}; () },
        store    => sub { print "key $_[2] stored in $_[-1]\n" },
        copy_key => 1,
        op_info  => VMG_OP_INFO_NAME,
       );
  
       my %h = (_default => 0, apple => 2);
       cast %h, $wiz, '_default';
       print $h{banana}, "\n"; # "0" (there is no 'banana' key in %h)
       $h{pear} = 1;           # "key pear stored in helem"
      }
  
  =head1 DESCRIPTION
  
  Magic is Perl's way of enhancing variables.
  This mechanism lets the user add extra data to any variable and hook syntactical operations (such as access, assignment or destruction) that can be applied to it.
  With this module, you can add your own magic to any variable without having to write a single line of XS.
  
  You'll realize that these magic variables look a lot like tied variables.
  It is not surprising, as tied variables are implemented as a special kind of magic, just like any 'irregular' Perl variable : scalars like C<$!>, C<$(> or C<$^W>, the C<%ENV> and C<%SIG> hashes, the C<@ISA> array,  C<vec()> and C<substr()> lvalues, L<threads::shared> variables...
  They all share the same underlying C API, and this module gives you direct access to it.
  
  Still, the magic made available by this module differs from tieing and overloading in several ways :
  
  =over 4
  
  =item *
  
  Magic is not copied on assignment.
  
  You attach it to variables, not values (as for blessed references).
  
  =item *
  
  Magic does not replace the original semantics.
  
  Magic callbacks usually get triggered before the original action takes place, and cannot prevent it from happening.
  This also makes catching individual events easier than with C<tie>, where you have to provide fallbacks methods for all actions by usually inheriting from the correct C<Tie::Std*> class and overriding individual methods in your own class.
  
  =item *
  
  Magic is multivalued.
  
  You can safely apply different kinds of magics to the same variable, and each of them will be invoked successively.
  
  =item *
  
  Magic is type-agnostic.
  
  The same magic can be applied on scalars, arrays, hashes, subs or globs.
  But the same hook (see below for a list) may trigger differently depending on the the type of the variable.
  
  =item *
  
  Magic is invisible at Perl level.
  
  Magical and non-magical variables cannot be distinguished with C<ref>, C<tied> or another trick.
  
  =item *
  
  Magic is notably faster.
  
  Mainly because perl's way of handling magic is lighter by nature, and because there is no need for any method resolution.
  Also, since you don't have to reimplement all the variable semantics, you only pay for what you actually use.
  
  =back
  
  The operations that can be overloaded are :
  
  =over 4
  
  =item *
  
  I<get>
  
  This magic is invoked when the variable is evaluated.
  It is never called for arrays and hashes.
  
  =item *
  
  I<set>
  
  This magic is called each time the value of the variable changes.
  It is called for array subscripts and slices, but never for hashes.
  
  =item *
  
  I<len>
  
  This magic only applies to arrays (though it used to also apply to scalars), and is triggered when the 'size' or the 'length' of the variable has to be known by Perl.
  This is typically the magic involved when an array is evaluated in scalar context, but also on array assignment and loops (C<for>, C<map> or C<grep>).
  The length is returned from the callback as an integer.
  
  Starting from perl 5.12, this magic is no longer called by the C<length> keyword, and starting from perl 5.17.4 it is also no longer called for scalars in any situation, making this magic only meaningful on arrays.
  You can use the constants L</VMG_COMPAT_SCALAR_LENGTH_NOLEN> and L</VMG_COMPAT_SCALAR_NOLEN> to see if this magic is available for scalars or not.
  
  =item *
  
  I<clear>
  
  This magic is invoked when the variable is reset, such as when an array is emptied.
  Please note that this is different from undefining the variable, even though the magic is called when the clearing is a result of the undefine (e.g. for an array, but actually a bug prevent it to work before perl 5.9.5 - see the L<history|/PERL MAGIC HISTORY>).
  
  =item *
  
  I<free>
  
  This magic is called when a variable is destroyed as the result of going out of scope (but not when it is undefined).
  It behaves roughly like Perl object destructors (i.e. C<DESTROY> methods), except that exceptions thrown from inside a I<free> callback will always be propagated to the surrounding code.
  
  =item *
  
  I<copy>
  
  This magic only applies to tied arrays and hashes, and fires when you try to access or change their elements.
  
  =item *
  
  I<dup>
  
  This magic is invoked when the variable is cloned across threads.
  It is currently not available.
  
  =item *
  
  I<local>
  
  When this magic is set on a variable, all subsequent localizations of the variable will trigger the callback.
  It is available on your perl if and only if C<MGf_LOCAL> is true.
  
  =back
  
  The following actions only apply to hashes and are available if and only if L</VMG_UVAR> is true.
  They are referred to as I<uvar> magics.
  
  =over 4
  
  =item *
  
  I<fetch>
  
  This magic is invoked each time an element is fetched from the hash.
  
  =item *
  
  I<store>
  
  This one is called when an element is stored into the hash.
  
  =item *
  
  I<exists>
  
  This magic fires when a key is tested for existence in the hash.
  
  =item *
  
  I<delete>
  
  This magic is triggered when a key is deleted in the hash, regardless of whether the key actually exists in it.
  
  =back
  
  You can refer to the tests to have more insight of where the different magics are invoked.
  
  =head1 FUNCTIONS
  
  =cut
  
  BEGIN {
   require XSLoader;
   XSLoader::load(__PACKAGE__, $VERSION);
  }
  
  =head2 C<wizard>
  
      wizard(
       data     => sub { ... },
       get      => sub { my ($ref, $data [, $op]) = @_; ... },
       set      => sub { my ($ref, $data [, $op]) = @_; ... },
       len      => sub {
        my ($ref, $data, $len [, $op]) = @_; ... ; return $newlen
       },
       clear    => sub { my ($ref, $data [, $op]) = @_; ... },
       free     => sub { my ($ref, $data [, $op]) = @_, ... },
       copy     => sub { my ($ref, $data, $key, $elt [, $op]) = @_; ... },
       local    => sub { my ($ref, $data [, $op]) = @_; ... },
       fetch    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       store    => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       exists   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       delete   => sub { my ($ref, $data, $key [, $op]) = @_; ... },
       copy_key => $bool,
       op_info  => [ 0 | VMG_OP_INFO_NAME | VMG_OP_INFO_OBJECT ],
      )
  
  This function creates a 'wizard', an opaque object that holds the magic information.
  It takes a list of keys / values as argument, whose keys can be :
  
  =over 4
  
  =item *
  
  C<data>
  
  A code (or string) reference to a private data constructor.
  It is called in scalar context each time the magic is cast onto a variable, with C<$_[0]> being a reference to this variable and C<@_[1 .. @_-1]> being all extra arguments that were passed to L</cast>.
  The scalar returned from this call is then attached to the variable and can be retrieved later with L</getdata>.
  
  =item *
  
  C<get>, C<set>, C<len>, C<clear>, C<free>, C<copy>, C<local>, C<fetch>, C<store>, C<exists> and C<delete>
  
  Code (or string) references to the respective magic callbacks.
  You don't have to specify all of them : the magic corresponding to undefined entries will simply not be hooked.
  
  When those callbacks are executed, C<$_[0]> is a reference to the magic variable and C<$_[1]> is the associated private data (or C<undef> when no private data constructor is supplied with the wizard).
  Other arguments depend on which kind of magic is involved :
  
  =over 8
  
  =item *
  
  I<len>
  
  C<$_[2]> contains the natural, non-magical length of the variable (which can only be a scalar or an array as I<len> magic is only relevant for these types).
  The callback is expected to return the new scalar or array length to use, or C<undef> to default to the normal length.
  
  =item *
  
  I<copy>
  
  C<$_[2]> is a either an alias or a copy of the current key, and C<$_[3]> is an alias to the current element (i.e. the value).
  Because C<$_[2]> might be a copy, it is useless to try to change it or cast magic on it.
  
  =item *
  
  I<fetch>, I<store>, I<exists> and I<delete>
  
  C<$_[2]> is an alias to the current key.
  Note that C<$_[2]> may rightfully be readonly if the key comes from a bareword, and as such it is unsafe to assign to it.
  You can ask for a copy instead by passing C<< copy_key => 1 >> to L</wizard> which, at the price of a small performance hit, allows you to safely assign to C<$_[2]> in order to e.g. redirect the action to another key.
  
  =back
  
  Finally, if C<< op_info => $num >> is also passed to C<wizard>, then one extra element is appended to C<@_>.
  Its nature depends on the value of C<$num> :
  
  =over 8
  
  =item *
  
  C<VMG_OP_INFO_NAME>
  
  C<$_[-1]> is the current op name.
  
  =item *
  
  C<VMG_OP_INFO_OBJECT>
  
  C<$_[-1]> is the C<B::OP> object for the current op.
  
  =back
  
  Both result in a small performance hit, but just getting the name is lighter than getting the op object.
  
  These callbacks are executed in scalar context and are expected to return an integer, which is then passed straight to the perl magic API.
  However, only the return value of the I<len> magic callback currently holds a meaning.
  
  =back
  
  Each callback can be specified as :
  
  =over 4
  
  =item *
  
  a code reference, which will be called as a subroutine.
  
  =item *
  
  a string reference, where the string denotes which subroutine is to be called when magic is triggered.
  If the subroutine name is not fully qualified, then the current package at the time the magic is invoked will be used instead.
  
  =item *
  
  a reference to C<undef>, in which case a no-op magic callback is installed instead of the default one.
  This may especially be helpful for I<local> magic, where an empty callback prevents magic from being copied during localization.
  
  =back
  
  Note that I<free> magic is never called during global destruction, as there is no way to ensure that the wizard object and the callback were not destroyed before the variable.
  
  Here is a simple usage example :
  
      # A simple scalar tracer
      my $wiz = wizard(
       get  => sub { print STDERR "got ${$_[0]}\n" },
       set  => sub { print STDERR "set to ${$_[0]}\n" },
       free => sub { print STDERR "${$_[0]} was deleted\n" },
      );
  
  =cut
  
  sub wizard {
   if (@_ % 2) {
    require Carp;
    Carp::croak('Wrong number of arguments for wizard()');
   }
  
   my %opts = @_;
  
   my @keys = qw<op_info data get set len clear free copy dup>;
   push @keys, 'local' if MGf_LOCAL;
   push @keys, qw<fetch store exists delete copy_key> if VMG_UVAR;
  
   my ($wiz, $err);
   {
    local $@;
    $wiz = eval { _wizard(map $opts{$_}, @keys) };
    $err = $@;
   }
   if ($err) {
    $err =~ s/\sat\s+.*?\n//;
    require Carp;
    Carp::croak($err);
   }
  
   return $wiz;
  }
  
  =head2 C<cast>
  
      cast [$@%&*]var, $wiz, @args
  
  This function associates C<$wiz> magic to the supplied variable, without overwriting any other kind of magic.
  It returns true on success or when C<$wiz> magic is already attached, and croaks on error.
  When C<$wiz> provides a data constructor, it is called just before magic is cast onto the variable, and it receives a reference to the target variable in C<$_[0]> and the content of C<@args> in C<@_[1 .. @args]>.
  Otherwise, C<@args> is ignored.
  
      # Casts $wiz onto $x, passing (\$x, '1') to the data constructor.
      my $x;
      cast $x, $wiz, 1;
  
  The C<var> argument can be an array or hash value.
  Magic for these scalars behaves like for any other, except that it is dispelled when the entry is deleted from the container.
  For example, if you want to call C<POSIX::tzset> each time the C<'TZ'> environment variable is changed in C<%ENV>, you can use :
  
      use POSIX;
      cast $ENV{TZ}, wizard set => sub { POSIX::tzset(); () };
  
  If you want to handle the possible deletion of the C<'TZ'> entry, you must also specify I<store> magic.
  
  =head2 C<getdata>
  
      getdata [$@%&*]var, $wiz
  
  This accessor fetches the private data associated with the magic C<$wiz> in the variable.
  It croaks when C<$wiz> does not represent a valid magic object, and returns an empty list if no such magic is attached to the variable or when the wizard has no data constructor.
  
      # Get the data attached to $wiz in $x, or undef if $wiz
      # did not attach any.
      my $data = getdata $x, $wiz;
  
  =head2 C<dispell>
  
      dispell [$@%&*]variable, $wiz
  
  The exact opposite of L</cast> : it dissociates C<$wiz> magic from the variable.
  This function returns true on success, C<0> when no magic represented by C<$wiz> could be found in the variable, and croaks if the supplied wizard is invalid.
  
      # Dispell now.
      die 'no such magic in $x' unless dispell $x, $wiz;
  
  =head1 CONSTANTS
  
  =head2 C<MGf_COPY>
  
  Evaluates to true if and only if the I<copy> magic is available.
  This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
  
  =head2 C<MGf_DUP>
  
  Evaluates to true if and only if the I<dup> magic is available.
  This is the case for perl 5.7.3 and greater, which is ensured by the requirements of this module.
  
  =head2 C<MGf_LOCAL>
  
  Evaluates to true if and only if the I<local> magic is available.
  This is the case for perl 5.9.3 and greater.
  
  =head2 C<VMG_UVAR>
  
  When this constant is true, you can use the I<fetch>, I<store>, I<exists> and I<delete> magics on hashes.
  Initial L</VMG_UVAR> capability was introduced in perl 5.9.5, with a fully functional implementation shipped with perl 5.10.0.
  
  =head2 C<VMG_COMPAT_SCALAR_LENGTH_NOLEN>
  
  True for perls that don't call I<len> magic when taking the C<length> of a magical scalar.
  
  =head2 C<VMG_COMPAT_SCALAR_NOLEN>
  
  True for perls that don't call I<len> magic on scalars.
  Implies L</VMG_COMPAT_SCALAR_LENGTH_NOLEN>.
  
  =head2 C<VMG_COMPAT_ARRAY_PUSH_NOLEN>
  
  True for perls that don't call I<len> magic when you push an element in a magical array.
  Starting from perl 5.11.0, this only refers to pushes in non-void context and hence is false.
  
  =head2 C<VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID>
  
  True for perls that don't call I<len> magic when you push in void context an element in a magical array.
  
  =head2 C<VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID>
  
  True for perls that don't call I<len> magic when you unshift in void context an element in a magical array.
  
  =head2 C<VMG_COMPAT_ARRAY_UNDEF_CLEAR>
  
  True for perls that call I<clear> magic when undefining magical arrays.
  
  =head2 C<VMG_COMPAT_HASH_DELETE_NOUVAR_VOID>
  
  True for perls that don't call I<delete> magic when you delete an element from a hash in void context.
  
  =head2 C<VMG_COMPAT_GLOB_GET>
  
  True for perls that call I<get> magic for operations on globs.
  
  =head2 C<VMG_PERL_PATCHLEVEL>
  
  The perl patchlevel this module was built with, or C<0> for non-debugging perls.
  
  =head2 C<VMG_THREADSAFE>
  
  True if and only if this module could have been built with thread-safety features enabled.
  
  =head2 C<VMG_FORKSAFE>
  
  True if and only if this module could have been built with fork-safety features enabled.
  This is always true except on Windows where it is false for perl 5.10.0 and below.
  
  =head2 C<VMG_OP_INFO_NAME>
  
  Value to pass with C<op_info> to get the current op name in the magic callbacks.
  
  =head2 C<VMG_OP_INFO_OBJECT>
  
  Value to pass with C<op_info> to get a C<B::OP> object representing the current op in the magic callbacks.
  
  =head1 COOKBOOK
  
  =head2 Associate an object to any perl variable
  
  This technique can be useful for passing user data through limited APIs.
  It is similar to using inside-out objects, but without the drawback of having to implement a complex destructor.
  
      {
       package Magical::UserData;
  
       use Variable::Magic qw<wizard cast getdata>;
  
       my $wiz = wizard data => sub { \$_[1] };
  
       sub ud (\[$@%*&]) : lvalue {
        my ($var) = @_;
        my $data = &getdata($var, $wiz);
        unless (defined $data) {
         $data = \(my $slot);
         &cast($var, $wiz, $slot)
                   or die "Couldn't cast UserData magic onto the variable";
        }
        $$data;
       }
      }
  
      {
       BEGIN { *ud = \&Magical::UserData::ud }
  
       my $cb;
       $cb = sub { print 'Hello, ', ud(&$cb), "!\n" };
  
       ud(&$cb) = 'world';
       $cb->(); # Hello, world!
      }
  
  =head2 Recursively cast magic on datastructures
  
  C<cast> can be called from any magical callback, and in particular from C<data>.
  This allows you to recursively cast magic on datastructures :
  
      my $wiz;
      $wiz = wizard data => sub {
       my ($var, $depth) = @_;
       $depth ||= 0;
       my $r = ref $var;
       if ($r eq 'ARRAY') {
        &cast((ref() ? $_ : \$_), $wiz, $depth + 1) for @$var;
       } elsif ($r eq 'HASH') {
        &cast((ref() ? $_ : \$_), $wiz, $depth + 1) for values %$var;
       }
       return $depth;
      },
      free => sub {
       my ($var, $depth) = @_;
       my $r = ref $var;
       print "free $r at depth $depth\n";
       ();
      };
  
      {
       my %h = (
        a => [ 1, 2 ],
        b => { c => 3 }
       );
       cast %h, $wiz;
      }
  
  When C<%h> goes out of scope, this prints something among the lines of :
  
      free HASH at depth 0
      free HASH at depth 1
      free SCALAR at depth 2
      free ARRAY at depth 1
      free SCALAR at depth 3
      free SCALAR at depth 3
  
  Of course, this example does nothing with the values that are added after the C<cast>.
  
  =head1 PERL MAGIC HISTORY
  
  The places where magic is invoked have changed a bit through perl history.
  Here is a little list of the most recent ones.
  
  =over 4
  
  =item *
  
  B<5.6.x>
  
  I<p14416> : I<copy> and I<dup> magic.
  
  =item *
  
  B<5.8.9>
  
  I<p28160> : Integration of I<p25854> (see below).
  
  I<p32542> : Integration of I<p31473> (see below).
  
  =item *
  
  B<5.9.3>
  
  I<p25854> : I<len> magic is no longer called when pushing an element into a magic array.
  
  I<p26569> : I<local> magic.
  
  =item *
  
  B<5.9.5>
  
  I<p31064> : Meaningful I<uvar> magic.
  
  I<p31473> : I<clear> magic was not invoked when undefining an array.
  The bug is fixed as of this version.
  
  =item *
  
  B<5.10.0>
  
  Since C<PERL_MAGIC_uvar> is uppercased, C<hv_magic_check()> triggers I<copy> magic on hash stores for (non-tied) hashes that also have I<uvar> magic.
  
  =item *
  
  B<5.11.x>
  
  I<p32969> : I<len> magic is no longer invoked when calling C<length> with a magical scalar.
  
  I<p34908> : I<len> magic is no longer called when pushing / unshifting an element into a magical array in void context.
  The C<push> part was already covered by I<p25854>.
  
  I<g9cdcb38b> : I<len> magic is called again when pushing into a magical array in non-void context.
  
  =back
  
  =head1 EXPORT
  
  The functions L</wizard>, L</cast>, L</getdata> and L</dispell> are only exported on request.
  All of them are exported by the tags C<':funcs'> and C<':all'>.
  
  All the constants are also only exported on request, either individually or by the tags C<':consts'> and C<':all'>.
  
  =cut
  
  use base qw<Exporter>;
  
  our @EXPORT         = ();
  our %EXPORT_TAGS    = (
   'funcs' =>  [ qw<wizard cast getdata dispell> ],
   'consts' => [ qw<
     MGf_COPY MGf_DUP MGf_LOCAL VMG_UVAR
     VMG_COMPAT_SCALAR_LENGTH_NOLEN
     VMG_COMPAT_SCALAR_NOLEN
     VMG_COMPAT_ARRAY_PUSH_NOLEN VMG_COMPAT_ARRAY_PUSH_NOLEN_VOID
     VMG_COMPAT_ARRAY_UNSHIFT_NOLEN_VOID
     VMG_COMPAT_ARRAY_UNDEF_CLEAR
     VMG_COMPAT_HASH_DELETE_NOUVAR_VOID
     VMG_COMPAT_GLOB_GET
     VMG_PERL_PATCHLEVEL
     VMG_THREADSAFE VMG_FORKSAFE
     VMG_OP_INFO_NAME VMG_OP_INFO_OBJECT
   > ],
  );
  our @EXPORT_OK      = map { @$_ } values %EXPORT_TAGS;
  $EXPORT_TAGS{'all'} = [ @EXPORT_OK ];
  
  =head1 CAVEATS
  
  In order to hook hash operations with magic, you need at least perl 5.10.0 (see L</VMG_UVAR>).
  
  If you want to store a magic object in the private data slot, you will not be able to recover the magic with L</getdata>, since magic is not copied by assignment.
  You can work around this gotcha by storing a reference to the magic object instead.
  
  If you define a wizard with I<free> magic and cast it on itself, it results in a memory cycle, so this destructor will not be called when the wizard is freed.
  
  =head1 DEPENDENCIES
  
  L<perl> 5.8.
  
  A C compiler.
  This module may happen to build with a C++ compiler as well, but don't rely on it, as no guarantee is made in this regard.
  
  L<Carp> (core since perl 5), L<XSLoader> (since 5.006).
  
  Copy tests need L<Tie::Array> (core since perl 5.005) and L<Tie::Hash> (since 5.002).
  Some uvar tests need L<Hash::Util::FieldHash> (since 5.009004).
  Glob tests need L<Symbol> (since 5.002).
  Threads tests need L<threads> and L<threads::shared> (both since 5.007003).
  
  =head1 SEE ALSO
  
  L<perlguts> and L<perlapi> for internal information about magic.
  
  L<perltie> and L<overload> for other ways of enhancing objects.
  
  =head1 AUTHOR
  
  Vincent Pit, C<< <perl at profvince.com> >>, L<http://www.profvince.com>.
  
  You can contact me by mail or on C<irc.perl.org> (vincent).
  
  =head1 BUGS
  
  Please report any bugs or feature requests to C<bug-variable-magic at rt.cpan.org>, or through the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Variable-Magic>.
  I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.
  
  =head1 SUPPORT
  
  You can find documentation for this module with the perldoc command.
  
      perldoc Variable::Magic
  
  Tests code coverage report is available at L<http://www.profvince.com/perl/cover/Variable-Magic>.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2007,2008,2009,2010,2011,2012 Vincent Pit, all rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1; # End of Variable::Magic
X86_64-LINUX_VARIABLE_MAGIC

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE

# PODNAME: installer
# ABSTRACT: Install an .installer configuration file

use strict;
use warnings;
use Getopt::Long;
use App::Installer;

my ( $url, $file );

GetOptions(
  "u=s" => \$url,
  "f=s" => \$file,
);

my $target = shift @ARGV;

die "You can't give file and url at once" if defined $url and defined $file;
die "Need a target to deploy to" unless $target;

App::Installer->new(
  target => $target,
  defined $url ? ( url => $url ) : (),
  defined $file ? ( file => $file ) : (),
)->install_to_target;

=head1 SYNOPSIS

  # Directly usable without install via http://installer.pm
  curl -s -L http://installer.pm | perl - ~/myprojectenv

  # Will use .installer file in current directory
  installer ~/myprojectenv

  # Using a specific installer file
  installer -f /other/installer_file ~/myprojectenv

  # The .installer file can also be fetched by URL:
  installer -u http://stardestroyer.de/postgis.installer ~/myprojectenv

  # On shell do the following for using the environment after installation
  . ~/myprojectenv/export.sh

Sample .installer file might look like

  perl "5.18.1";
  url "http://ftp.postgresql.org/pub/source/v9.2.4/postgresql-9.2.4.tar.gz", with => {
    pgport => 15432,
  };
  url "http://download.osgeo.org/gdal/1.10.1/gdal-1.10.1.tar.gz";
  url "http://download.osgeo.org/geos/geos-3.4.2.tar.bz2";
  url "http://download.osgeo.org/postgis/source/postgis-2.1.0.tar.gz";
  cpanm "DBD::Pg";

=head1 DESCRIPTION

B<TOTALLY BETA, PLEASE TEST :D>

Bigger example for installer file options:

  url "http://host/file.tar.gz",
    with => {
      key => "value",
      other_key => undef,
    },
    enable => [qw( satan )],
    disable => [qw( god )],
    without => [qw( religion )],
    testable => 1;

Would endup with the following parameter on I<./configure>: B<--with-key=value
--with-other_key --enable-satan --disable-god --without-religion>. Also it
would run "make test" if there is a Makefile after configuration. Another
options possible (so far):

  url "http://host/file.tar.gz",
    custom_test => sub {
      $_[0]->run($_[0]->unpack_path,'testcommand','--args')
    },
    custom_configure => sub {
      $self->run($self->unpack_path,'./Configure','-des','-Dprefix='.$self->target_directory);
    },
    post_install => sub {
      $self->run(undef,'command'); # run in target directory after install
    },
    export_sh => sub {
      return "# extra lines", "# for getting added to", "# export.sh";
    };

Same options can go towards a local file:

  file "/some/local/file.tar.gz";

You can also run a custom command (it will be run inside the target directory):

  run "custom_command", "args", "args";

Install specific perl (so far no options):

  perl "5.8.8";

Or install packages via cpanm:

  cpanm qw( Yeb Dist::Zilla );

B<Be careful!> It doesn't care if you have installed a perl in the target
directory or not, and just fire up cpanm, so it would install on your local
perl installation, if you don't install perl before.

Or install packages via pip:

  pip qw( rtree imposm );

B<Be careful!> It doesn't care if you have installed pip in the target
directory or not, and just fire up pip, so it would install on your local
python environment, if you don't installed pip before.

=cut
